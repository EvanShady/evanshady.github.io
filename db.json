{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1574642653524},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1574642653524},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1574642653524},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1574642653527},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1574642653527},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1574642653527},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1574642653527},{"_id":"themes/next/README.md","hash":"cf9c999578085b9c8a20a13d19d9d8660926f847","modified":1574642653527},{"_id":"themes/next/_config.yml","hash":"b36c4a5bd21c2f00b5d0eabd8e35574fa8cfd6c9","modified":1574642653527},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1574642653527},{"_id":"themes/next/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1574642653531},{"_id":"themes/next/package.json","hash":"a2caa6dcace053aeaec9b3555ce2a29fbf878fa0","modified":1574642653534},{"_id":"source/_posts/Class.md","hash":"907c12aa251135aa28ad1e64b141148d9cd2fb49","modified":1560239395970},{"_id":"source/_posts/Code.md","hash":"59ff11fded3ec24fd18f139a2d0f96df70b144d1","modified":1560239395970},{"_id":"source/_posts/JustATest.md","hash":"2abc07297fd2f9079502cea5a253d1f052e284d6","modified":1568106514087},{"_id":"source/_posts/C-Book.md","hash":"5918dc8f8614554235863240e2da667d3f29a3c3","modified":1566305197251},{"_id":"source/_posts/Noteslinux1.md","hash":"b4a4f3610ef3bf58cdde5a546e03c0b14235c164","modified":1568805395347},{"_id":"source/_posts/c-Notes.md","hash":"62243885f10020c147bcd5f2449375a36d82310d","modified":1568272773334},{"_id":"source/_posts/constellation.md","hash":"cdf8536f3172f5390683bbd3b442ea102cb3cccd","modified":1568272739460},{"_id":"source/_posts/hello-world.md","hash":"c10282e1312d91f0e1dc8bba0e59486443cfa5b5","modified":1568106684860},{"_id":"source/_posts/file.md","hash":"206e96fee38e676acedcc5ce70e1be8816b09e05","modified":1568265150680},{"_id":"source/_posts/i3.md","hash":"5e17c974d513fb948199253e0a92b921a07be468","modified":1569233398297},{"_id":"source/_posts/mysql.md","hash":"17a9961d1382f30747ac6702936447ba2395f6d4","modified":1572937396296},{"_id":"source/_posts/java.md","hash":"fceb5bb0c665a5e84b76478243512673867abadd","modified":1574642230851},{"_id":"source/_posts/tar.md","hash":"b8f913bbb9f0df4e47396b149204f315a0d854da","modified":1568106574814},{"_id":"source/_posts/test-1.md","hash":"027eff4075eae7aacb7d5f6a48c0befe8a9f0bfe","modified":1568272603680},{"_id":"source/_posts/test-2.md","hash":"ff71ef457337fa635796595983eb62339ce49886","modified":1574642348548},{"_id":"source/_posts/test.md","hash":"6e5c3fb05074d92e7a32eee35191d38c538f11da","modified":1568272556084},{"_id":"source/_posts/test2.md","hash":"b01d29f698750557b16f16046b2095b911c77428","modified":1568106737820},{"_id":"source/_posts/小萝莉.md","hash":"4d936c74732b6aa2a64a37a75859e1d57d1bb1a4","modified":1570026872563},{"_id":"source/_posts/qt.md","hash":"b6873455a9fb498266b975bebf158eff7eb2bfbb","modified":1568272637430},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1574642653521},{"_id":"themes/next/.git/config","hash":"f832f515b1ca3e88e3ef1dbc4a8ae5b14c0f0965","modified":1574642653521},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1574642441230},{"_id":"themes/next/.git/packed-refs","hash":"a69284b7958fe097f93e51be2fcc354dca8e2c77","modified":1574642653521},{"_id":"themes/next/.git/index","hash":"7b03daaf0e2f4b5c7edb0c993f3fc709b1342f3d","modified":1574643053231},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1574642653524},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"f4825dd07e8c524f4be3fe99d36069828c1b8535","modified":1574642653527},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1574642653527},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"2a4ff75ccb91d9001032c08e22489096b850bf4f","modified":1574642653527},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1574642653527},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1574642653527},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1574642653527},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"b09c85aa449f46bc025317ed196ec33a877f7c23","modified":1574642653527},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1574642653527},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1574642653527},{"_id":"themes/next/.github/stale.yml","hash":"941209526c2f7d916c76163c9e1ac1af9d956679","modified":1574642653527},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"5b4c013e0598b3211ebd899265936cfdaf7c139f","modified":1574642653527},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1574642653527},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1574642653527},{"_id":"themes/next/docs/DATA-FILES.md","hash":"d0d46cb265f0efceffce82214cd36d8b82ddce13","modified":1574642653527},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1574642653527},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1574642653527},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1574642653527},{"_id":"themes/next/docs/MATH.md","hash":"f520b336f16665e164d6edf075bdcc6aa17b31bc","modified":1574642653527},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"199e9ef3cb5928af0fe801d03d2d1aeea704cea4","modified":1574642653527},{"_id":"themes/next/languages/de.yml","hash":"1b129c08abea18a0533b973d8d81bb8cdf4757f1","modified":1574642653531},{"_id":"themes/next/languages/en.yml","hash":"ed4c633c9bbf792edeb0923afe7071ef881f571d","modified":1574642653531},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1574642653527},{"_id":"themes/next/languages/default.yml","hash":"ed4c633c9bbf792edeb0923afe7071ef881f571d","modified":1574642653531},{"_id":"themes/next/languages/es.yml","hash":"5d58eabdace2dda0ac2a1ec134dd53307ba558f6","modified":1574642653531},{"_id":"themes/next/languages/fr.yml","hash":"c62b46c6958650773475e161f0c22a7416923ea9","modified":1574642653531},{"_id":"themes/next/languages/fa.yml","hash":"5096f3926d8ee8de774b2f4635cc6dfe15e5027b","modified":1574642653531},{"_id":"themes/next/languages/hu.yml","hash":"030788cbed906d686f84b874853278379564f8c3","modified":1574642653531},{"_id":"themes/next/languages/id.yml","hash":"76c16e3333c0cfb67f7a6edb35b3cca0ae691c47","modified":1574642653531},{"_id":"themes/next/languages/it.yml","hash":"b9916c4726a9e866fa6cc8c3b30e57e9f453be4b","modified":1574642653531},{"_id":"themes/next/languages/ko.yml","hash":"432ef2f303734504ec35d2fb06094c2df6edae9c","modified":1574642653531},{"_id":"themes/next/languages/ja.yml","hash":"9dfc048c0b9b890ee566ce1f8e815f159bf08a48","modified":1574642653531},{"_id":"themes/next/languages/nl.yml","hash":"e3ab0efc2af598e235e3a9e7c34ef270e191253f","modified":1574642653531},{"_id":"themes/next/languages/pt-BR.yml","hash":"ccbc616e498334ae70fbd5f874b8b956acfcf288","modified":1574642653531},{"_id":"themes/next/languages/pt.yml","hash":"6d13eb616547006cd151b78256b878b2832b7130","modified":1574642653531},{"_id":"themes/next/languages/ru.yml","hash":"45bfcee9ab4dc7c0ae64218f806d8f65399e2c24","modified":1574642653531},{"_id":"themes/next/languages/tr.yml","hash":"d7af0671d965e49dd6de1e4c3afd50e89843ca4a","modified":1574642653531},{"_id":"themes/next/languages/vi.yml","hash":"ff3c6d906bc22e65b6862c5ed017038f99f64112","modified":1574642653531},{"_id":"themes/next/languages/uk.yml","hash":"398467fd2904e03b0f4c256888fb480ee3f88f13","modified":1574642653531},{"_id":"themes/next/languages/zh-CN.yml","hash":"f7b5981e911ec37b6ed5b16910a680f0e49de062","modified":1574642653531},{"_id":"themes/next/languages/zh-HK.yml","hash":"10451f308b62cfffed09329feedc78651bd2a16f","modified":1574642653531},{"_id":"themes/next/languages/zh-TW.yml","hash":"4420d2457b1153f37799dc20f1ee72cf1bade70e","modified":1574642653531},{"_id":"themes/next/layout/_layout.swig","hash":"512bdf6787b5d9fb1d40b126b0fa8e6f1018d1cd","modified":1574642653531},{"_id":"themes/next/layout/archive.swig","hash":"59155648f6306888077d1f1d635f63177b36148d","modified":1574642653534},{"_id":"themes/next/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1574642653534},{"_id":"themes/next/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1574642653534},{"_id":"themes/next/layout/page.swig","hash":"e61d64c055b6497a04affc143f47fdd0a6dc495b","modified":1574642653534},{"_id":"themes/next/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1574642653534},{"_id":"themes/next/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1574642653534},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1574642653537},{"_id":"source/_posts/C-Book/c-Book.png","hash":"087c1f14d7d19a929961c98be3a94db669d63369","modified":1560433581154},{"_id":"source/_posts/C-Book/c-Book1.png","hash":"9533241ea8cf7808b485527843d92fdf14fbbbdb","modified":1560594975714},{"_id":"source/_posts/C-Book/c-Book3.png","hash":"68c38dd892d6626178492147bda59c770a36ec93","modified":1560595155777},{"_id":"source/_posts/Class/Lpur2.png","hash":"efc22e1a1e37e75baa7b788d1fea94611eacf02b","modified":1560239395970},{"_id":"source/_posts/C-Book/c-Book4.png","hash":"c2d9847f52f04acbf7be2841091c2d4bca74959a","modified":1570620828947},{"_id":"source/_posts/C-Book/c-Book5.png","hash":"e0345487c68d55dc8dc78f77dc39a865426e26c4","modified":1570969343590},{"_id":"source/_posts/Java/java1.png","hash":"ffad55f4be251da9ee6542ba5dac36a329476b56","modified":1572436487599},{"_id":"source/_posts/Code/Code1.png","hash":"54287ffb565af64e9a6bc36941563327f2a43902","modified":1560239395970},{"_id":"source/_posts/Java/java2.png","hash":"2e9e385de23b112b61b2c9e7dd46109c0e94a6e1","modified":1572437095159},{"_id":"source/_posts/Java/java4.png","hash":"ccfca7470cc0882b4122af8bffcb2d8770e7ae79","modified":1573119057998},{"_id":"source/_posts/Java/java3.png","hash":"152bd8aa4b5884c4075e64af3d23ab6f0beed3e5","modified":1573116496882},{"_id":"source/_posts/Lei/Ljicheng3.png","hash":"ce03fcf4cbb87d3e944fa3b93307515b435e45c0","modified":1560239395974},{"_id":"source/_posts/Lei/Ljicheng4.png","hash":"df1989a4bcf84daeb4d701d150cda8bff4d781cb","modified":1560239395974},{"_id":"source/_posts/Lei/Loperator1.png","hash":"2cc3b8b0c1cff8297cdf91b3ecc038086282869b","modified":1560239395974},{"_id":"source/_posts/Lei/Loperator2.png","hash":"3117f8718ce82ed7731451cdb1cfea918f9ee6aa","modified":1560239395974},{"_id":"source/_posts/Lei/Lpur1.png","hash":"897fb5af66fbc49e7766454f38c8746e9a4960b2","modified":1560239395974},{"_id":"source/_posts/Lei/Ljicheng2.png","hash":"f4d3d0939a7407f3df7143a35b2d2cc7a54919ed","modified":1560239395974},{"_id":"source/_posts/c-Notes/WC.png","hash":"53e4ea434ec5d17e0be7c89c3632c49ac0fb53c1","modified":1560239395974},{"_id":"source/_posts/c-Notes/YC1.png","hash":"1ef204c5da4c7ca802c8a4ee447b3818e866ff08","modified":1560239395974},{"_id":"source/_posts/c-Notes/YC2.png","hash":"dd7989c0644da90ef8c8e369b7025169fdffc280","modified":1560239395974},{"_id":"source/_posts/c-Notes/YC.png","hash":"2c7b67083d726c4f343c3149a168e9a39f137ce1","modified":1560239395974},{"_id":"source/_posts/c-Notes/YC3.png","hash":"8a32fd85ed5096a64b9cb5ddb75c0677320317d0","modified":1560239395974},{"_id":"source/_posts/file/file1.png","hash":"14fbb290eabbb2b088fd610a943876b2d2b36c05","modified":1560239395974},{"_id":"source/_posts/c-Notes/YC5.png","hash":"809b91cc0157e727c5ca4147765cc1a3b8b73e28","modified":1560239395974},{"_id":"source/_posts/c-Notes/YC4.png","hash":"503622c67c5eaf427b4b08541daa447bffc62d88","modified":1560239395974},{"_id":"source/_posts/i3/crayon_shin_chan-002.jpg","hash":"a10f80a07286a1ca4b029c2f105366eb9a2d41f7","modified":1569230650894},{"_id":"source/_posts/i3/test3.jpeg","hash":"009c5f2283ad3999fdb6336e9461331bc790faf9","modified":1569230650894},{"_id":"source/_posts/i3/test2.jpg","hash":"2066cd369e49dba4240797eb0693c74c29ef51e4","modified":1569230650894},{"_id":"source/_posts/i3/头像.jpeg","hash":"348f83e3863f4d36159fdcfde3da05b23c40bc67","modified":1569230650894},{"_id":"source/_posts/i3/test5.jpeg","hash":"2366bddaf27ba51a74bf3b48b4c94f553897696b","modified":1569230650894},{"_id":"source/_posts/i3/test7.jpg","hash":"7fc88d04627f532bb8c4507ba8ec4a00953e3d62","modified":1569230650894},{"_id":"source/_posts/mysql/mysql0.png","hash":"84b39d35d7672b9f503159517892c9b4deb1a695","modified":1572355570826},{"_id":"source/_posts/mysql/mysql3.png","hash":"2e51e7aa390db4cd7b68c3f654c67658019eb5d7","modified":1572355860277},{"_id":"source/_posts/qt/qt1.png","hash":"8ccfbcce3b05793c8cc909950cdd003b78c8a8ad","modified":1563418067554},{"_id":"source/_posts/qt/qt2_hello.png","hash":"45de44b825c02b0ed70b2192cbcc0d07b63a7fd7","modified":1565770731185},{"_id":"source/_posts/qt/qt10_ui.png","hash":"e0c36a98266fe765d04c2d64ec024f9353ecd521","modified":1565770768470},{"_id":"source/_posts/qt/qt3_caidan.png","hash":"cf1cc655315c30cf5496c45dcd4396d3a0b97de9","modified":1565770735437},{"_id":"source/_posts/qt/qt4_duihua.png","hash":"87123682d26bc7d76a7dc82326ed6221f4be6e32","modified":1565770738425},{"_id":"source/_posts/qt/qt6_ui.png","hash":"9b8e1e3d146d5d77ac3db18a17f4ff00e684d806","modified":1565770749309},{"_id":"source/_posts/qt/qt7_ui.png","hash":"a5c1d2062b823914f0eb02717704f9652c428d6f","modified":1565770752346},{"_id":"source/_posts/qt/qt8_ui.png","hash":"d0ea982a54b735651988c76ad271cd96e677eaaf","modified":1565770755121},{"_id":"source/_posts/qt/qtEvent.png","hash":"9dcac426770c8cc36f8dcabcb5a72d481ea4c693","modified":1565770793786},{"_id":"source/_posts/qt/qt5_duihua.png","hash":"5193e5b313dc5e24e348474fd828db606018c1dc","modified":1565770744443},{"_id":"source/_posts/qt/qtEvent1.png","hash":"f2ee3a301150ff39b7554a2adad8ca1b33ab18c7","modified":1565770797438},{"_id":"source/_posts/qt/qtEvent3.png","hash":"7f875b2546ff43509851b2b6133fafdffe27ccb6","modified":1565770803397},{"_id":"source/_posts/qt/qtEvent2.png","hash":"d5b310f025675faaf46d19f2d589a7a6f493d06f","modified":1565770800201},{"_id":"source/_posts/qt/qtEvent4.png","hash":"cafe6234676b31dfeebbf6c16a04f911504e3b39","modified":1565770806424},{"_id":"source/_posts/qt/qtFILE.png","hash":"316d1b5ed005c30b341dffcd7ba9eb7538e99288","modified":1565770818048},{"_id":"source/_posts/qt/qt_image.png","hash":"e49b6c045f89fbcdb134811284e3dd170aa8829a","modified":1565770639537},{"_id":"source/_posts/qt/qt_paint1.png","hash":"1ce3283b3034dc5361ee646520c401d5704357f8","modified":1565770653917},{"_id":"source/_posts/qt/qt_picture2.png","hash":"6318fcb3e651be37edb34de2c2e791982cad51d1","modified":1565770669005},{"_id":"source/_posts/qt/qt_pixmap.png","hash":"1049ab02c50c73358d02e111890429255be429d0","modified":1565770673919},{"_id":"source/_posts/qt/qt_picture1.png","hash":"afa79f2b9ac9d80e6858959f6ef28076939a127f","modified":1565770664742},{"_id":"source/_posts/qt/qt_pixmap2.png","hash":"f8eb40068fb7d517ecb75f72f5232e71b895cb6d","modified":1565770678091},{"_id":"source/_posts/qt/qt_udp.png","hash":"951fe18fdee09ea07f636cb04254c43f97deafd3","modified":1565770708576},{"_id":"source/_posts/qt/qt_tcpserven2.png","hash":"4e732580a9526bb19c6cf7d3010beac43e3b0f79","modified":1565770704820},{"_id":"source/_posts/qt/qt_udp2.png","hash":"a504b47275948331aecc07ee6c06dcfb952b6872","modified":1565770717366},{"_id":"source/_posts/qt/qtwritefile.png","hash":"082a34a98e1448ad7e9191c5ce5dbfad762a4fa9","modified":1565770827344},{"_id":"source/_posts/tar/tar.png","hash":"46549e929e679709e4073ccd86fa47c05f92f848","modified":1560239395974},{"_id":"source/_posts/tar/tar1.png","hash":"935f3390171658cc0fd30f86d0cfa83375d2ccee","modified":1560239395974},{"_id":"source/_posts/test/a.jpg","hash":"7d0458d48481078303d783a9574cab09e324f60c","modified":1560239395977},{"_id":"source/_posts/小萝莉/sda.jpg","hash":"b905c165bd7022bffd52a5bd8714afc038091a23","modified":1560239395987},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1574642441230},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1574642441230},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1574642441230},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1574642441230},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1574642441230},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1574642441230},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1574642441230},{"_id":"themes/next/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1574642441230},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1574642441230},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1574642441230},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1574642441230},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1574642441230},{"_id":"themes/next/.git/logs/HEAD","hash":"7fbb5ad8802851a44faab33a4425279542fc55d0","modified":1574642653521},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1574642441230},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"80c31b258f404a16ffc19706c5e5aa3ccb8c887e","modified":1574642653527},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"bf8b10715f5529cc6997501d821307895710ba58","modified":1574642653527},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6d79701dd0bb3757722650d9df30eeaacd83344e","modified":1574642653527},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"2f85f500781124b1848cc419f864797399fcdabc","modified":1574642653527},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"2665f6a9d72090f9452a8811544ff2596e8899be","modified":1574642653527},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1574642653527},{"_id":"themes/next/docs/ru/README.md","hash":"a8fa084606a00eb5139e7675d9cf49c5209e063d","modified":1574642653527},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1574642653527},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"4245fe9472647226692fcbdd5a52d6e6dcd251bc","modified":1574642653527},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"ebacdc94f6f9724a7c6ef7c3cdde41ff7c37931a","modified":1574642653531},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bc159df1260e0c912c509090d54dd20a08201100","modified":1574642653531},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"3b4dbf0d2ca12ab442b7e0e227769ce100b8a444","modified":1574642653531},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1574642653531},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"264d131b8865bae069f8e4d78a33a0f59d28e36b","modified":1574642653531},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"2d60a18340c9260cd4dc81fe8acc7983d6b2d011","modified":1574642653531},{"_id":"themes/next/docs/zh-CN/README.md","hash":"4754aa33010eba137deda39a81b8f1160c8e38bd","modified":1574642653531},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"8109a531d3a7f5a306e36d4304c11f0c7c180c87","modified":1574642653531},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1574642653531},{"_id":"themes/next/layout/_macro/post.swig","hash":"04c19d48a14cc10e5b21295a874647d3c5b584bf","modified":1574642653531},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"e2c9db54cc9e154e882008fde6588b065fadc9a7","modified":1574642653531},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1574642653534},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1574642653534},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"dd6bd817cb69b5ad5e9746498146314b54054ff8","modified":1574642653534},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1574642653534},{"_id":"themes/next/layout/_partials/comments.swig","hash":"3a72e3d72980fa0944008b36b284b044d0e84b2a","modified":1574642653531},{"_id":"themes/next/layout/_partials/footer.swig","hash":"434a4979c376c1ff27380c778d0261fea8d0a0a4","modified":1574642653531},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"b9d3f6534efb9e637ac46318fa07c2e5607bf830","modified":1574642653534},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1574642653534},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1574642653534},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1574642653534},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1574642653534},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1574642653534},{"_id":"themes/next/scripts/events/index.js","hash":"9047d8ae2670e43429b16a7919a08a0a0a81afe0","modified":1574642653537},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1574642653537},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"9675acc599ffa546f05a60375c1637b0327be4fd","modified":1574642653534},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1574642653537},{"_id":"themes/next/scripts/filters/locals.js","hash":"2601d05d44ad2b59370477cb8f61dd95898a1a9c","modified":1574642653537},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1574642653537},{"_id":"themes/next/scripts/filters/post.js","hash":"3c1e483c2c4a1c5a2f9a99b81ce0fda5fd21926b","modified":1574642653537},{"_id":"themes/next/scripts/helpers/engine.js","hash":"c8c8afde59df587f883dd9b47a3c629042bc4c6e","modified":1574642653537},{"_id":"themes/next/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1574642653537},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"e60e6c0aaa979d42b01685ba2a03a76fa6e059e2","modified":1574642653537},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1574642653544},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1574642653537},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1574642653537},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1574642653537},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"8f86694a57d30685c4ced381f1ed09e8114dbb6e","modified":1574642653537},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1574642653537},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1574642653537},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1574642653537},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1574642653537},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1574642653537},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1574642653537},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1574642653544},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1574642653544},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1574642653544},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1574642653544},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1574642653544},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1574642653544},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1574642653544},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1574642653544},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1574642653544},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1574642653544},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1574642653544},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1574642653544},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1574642653544},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1574642653544},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1574642653544},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1574642653544},{"_id":"themes/next/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1574642653544},{"_id":"themes/next/source/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1574642653544},{"_id":"themes/next/source/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1574642653544},{"_id":"themes/next/source/js/motion.js","hash":"9ac69597315b5b7b4c8900b7949d2a31387d6284","modified":1574642653544},{"_id":"themes/next/source/js/next-boot.js","hash":"f7045763e277e685c271bd4b4c37e531d699ac63","modified":1574642653544},{"_id":"themes/next/source/js/utils.js","hash":"ba4c1cb25071a9fe0b94dd001d2413307bbaeb80","modified":1574642653544},{"_id":"source/_posts/C-Book/c-Book2.png","hash":"4f26607566b1c847bd5fe240eba6a2a460c48e06","modified":1560595029404},{"_id":"source/_posts/Java/java0.png","hash":"eaadc69952a23318e4e0c92c7112cbfb63f3e43d","modified":1572249937073},{"_id":"source/_posts/Noteslinux1/chattr.png","hash":"4e0b0081244ac60cd915af6576cf699d81836e1f","modified":1562578486964},{"_id":"source/_posts/file/file.png","hash":"4493b22e0a3079dd30e8cd3693776936401fc46a","modified":1560239395974},{"_id":"source/_posts/i3/710742.jpg","hash":"8cf708f93f621fe55a5f55f0e5baab2be6b2f11d","modified":1569230650890},{"_id":"source/_posts/mysql/mysql2.png","hash":"0ac4f99602aaa11e918726111ea487ef4a2e6fbe","modified":1572355747442},{"_id":"source/_posts/mysql/mysql5.png","hash":"61901a7f1d7b9dd8a53ad144529a5f724a473630","modified":1572357144599},{"_id":"source/_posts/qt/qt11_ui.png","hash":"bf20b1b26362eff4d400b9b7e4aa236c26350631","modified":1565770776994},{"_id":"source/_posts/qt/qt12_ui.png","hash":"b52a4b1a6cf7d6fc71079f7e6f7b6412e0d06289","modified":1565770780164},{"_id":"source/_posts/qt/qt9_ui.png","hash":"7f243bb0fe25a1f0ff0248eaa7224331ea78a73c","modified":1565770757835},{"_id":"source/_posts/qt/qt_Stream.png","hash":"64a3969d48dd971cfa80bfe6d64a737f63711093","modified":1565770689709},{"_id":"source/_posts/qt/qt_paint.png","hash":"4f8e137dabfa3d9e1c1f87bff0b8c7b4bb143c51","modified":1565770647025},{"_id":"source/_posts/qt/qt_picture.png","hash":"1f3f631d4e6c68a619c7e1ac9af08406a899a197","modified":1565770658512},{"_id":"source/_posts/qt/qt_tcpfile.png","hash":"ad10452fdea2d1d92d0553a3723916e38e361517","modified":1565770694549},{"_id":"source/_posts/qt/qt_tcpserven1.png","hash":"69cfb3430235954c5b27cbe9040b40dc6f406fa3","modified":1565770701484},{"_id":"source/_posts/qt/qt_udp1.png","hash":"6f55124c81d8c4081404e22862f11a1a0751717f","modified":1565770713036},{"_id":"source/_posts/qt/qt_zhuan1.png","hash":"d9e90d9ab81c29de5372fb4ea000aa903ceac09e","modified":1565770721693},{"_id":"source/_posts/qt/qtzhuan.png","hash":"415f55e2c19bd5b82f69c4c14d782b8aa2441d68","modified":1565770830859},{"_id":"source/_posts/小萝莉/test.png","hash":"5dbdce767c229ce56fda00e932ac1fcdd6fabd17","modified":1560239395987},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1574642653541},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1574642653541},{"_id":"source/_posts/Lei/Ljicheng.png","hash":"c17a6661fc57c34e80850d7781cdd6048777c986","modified":1560239395970},{"_id":"source/_posts/i3/169068.jpg","hash":"b6ce51c86562895e6636aa200b6626c9b682949b","modified":1569230650880},{"_id":"source/_posts/qt/qtEventpainter2.png","hash":"31cb6a8d0b83d2e9f5803e6c89ab72a943170976","modified":1565770813734},{"_id":"source/_posts/qt/qt_Read.png","hash":"9fff6623d58ca11be5cee7a8715331d1ae34d2b0","modified":1565770681427},{"_id":"source/_posts/qt/qt_tcpserven.png","hash":"55a74a8a6c4ab88209820b7a6fb107f114e83dff","modified":1565770697986},{"_id":"source/_posts/qt/qtreadfile.png","hash":"868d517138628a1c6cc8a8bbaf24ad6978aa8dab","modified":1565770823595},{"_id":"themes/next/.git/refs/heads/master","hash":"7a3e246fad3e4f0e234c1fc229f5c9cff09f0ae4","modified":1574642653521},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1574642653534},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1574642653534},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1574642653534},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1574642653534},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1574642653534},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1574642653534},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1574642653534},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"fe3cdd70224bd0c8171513a5dfed7b85deb7f23d","modified":1574642653534},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"9719cb5858896aef86c2e0bec0ace259936680c4","modified":1574642653534},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"8063f65cdaae80840fcf427b875ae606f678dfa5","modified":1574642653534},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1574642653534},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"a9c8e7987b63b9ef66e47b966aea05ac77ff920a","modified":1574642653534},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1574642653534},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1574642653534},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"fb27a38f9a4b8fcba4f637b03904f7a83cc73416","modified":1574642653534},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"e456d7a2aaabe55447f78cd952b30d70a6c1e742","modified":1574642653534},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1574642653534},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1574642653534},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1574642653534},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1574642653534},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"0ea0bac09b0747bc16fde852164c0eaab2efe02c","modified":1574642653534},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1574642653534},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"693819ef652b211167f35f26fb90750531826a64","modified":1574642653534},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"7fa72dc60c078842979861622839b109683e05a3","modified":1574642653534},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"4958fa997ff6df2b2ce05341f40cc3a81b0f91bb","modified":1574642653534},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"f5d2c5a3421ae52888be62e2c837459d1175cc93","modified":1574642653531},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"4b1d3582dcc6c9bad6b9b2ec25cca7bc9a3aee5e","modified":1574642653531},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"7487ca8f0e4b16351ea0d6b35dc52b0d32176d57","modified":1574642653531},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1574642653531},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"ff33b5797f5e4b5cbcb3c222c17bc636c6b88df6","modified":1574642653531},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d488664bc16608b5f829f959c2058b4381be244a","modified":1574642653531},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"fbec9f77139e1f300509c38446416b4b26350cfa","modified":1574642653534},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1574642653534},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1574642653534},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"becfa683c3e5409e20cdb7b1dc8a6db331bddefe","modified":1574642653534},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1574642653534},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1574642653534},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"78cb2077f50bc3b81130a516ffc04bc1fcea5834","modified":1574642653534},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1574642653534},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1574642653534},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"d4f94b643ac87d4d858cd8a6f70e030613f98b48","modified":1574642653534},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"246ff123cbaa507f23514c0c51c6cc006685898e","modified":1574642653534},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1574642653534},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1574642653534},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1574642653534},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1574642653534},{"_id":"themes/next/scripts/events/lib/config.js","hash":"246e55d48f2f3ef510c11594c7c08ddb93ac0928","modified":1574642653537},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1574642653537},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1574642653537},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1fc2a94b94108175848ba9541d05898c071386d0","modified":1574642653537},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1574642653537},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1574642653537},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"d2ce60980fc148bfb877981aabd07bf45d2cdcda","modified":1574642653537},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1574642653537},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"c081166868e6428a07c51c5674b86b7a4cc9c2a8","modified":1574642653537},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"3c4bdc2a682f9889a532e1cb856bc5caeb4208e1","modified":1574642653537},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"52550138127ae9ebbe049bcdacd94d767c003855","modified":1574642653541},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"b9d7058db61df7bbd2b58779efe45621a06ffc18","modified":1574642653541},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c261d685c5ed0df34718d94bb2ba977c0ed443e6","modified":1574642653541},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"50bc57e66331c0f15a4527010b4ca3316ac92403","modified":1574642653541},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1574642653541},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1574642653541},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0a25f3df1b5c39794365efde387647da81da884a","modified":1574642653541},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1574642653547},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1574642653547},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1574642653544},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1574642653544},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1574642653544},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1574642653544},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1574642653544},{"_id":"themes/next/source/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1574642653544},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1574642653544},{"_id":"source/_posts/i3/228568.jpg","hash":"32ca6f63b9817cc872e9c6f278d1c3b4685c1cc9","modified":1569230650884},{"_id":"source/_posts/i3/608422.jpg","hash":"053a7ed987f6e3b65b917aac6a69e57966643269","modified":1569230650887},{"_id":"source/_posts/mysql/mysql1.png","hash":"700d308f60ba9f7feda8541893a4a11df4d427ce","modified":1572355494094},{"_id":"source/_posts/mysql/mysql4.png","hash":"9c849400454a422cd95a1ea4b88bd8c649393b71","modified":1572356971623},{"_id":"source/_posts/qt/qtEventpainter1.png","hash":"aced6e65da772a7fd8cff022c92e929dba1d9e0e","modified":1565770809736},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1574642653534},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"5201cd09a5e263282ccbf205f07d46f4c6d3f700","modified":1574642653537},{"_id":"source/_posts/i3/927682.jpg","hash":"2e6da726afaf01db329886d783aa55fc7b2d313b","modified":1569230650890},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"7fbb5ad8802851a44faab33a4425279542fc55d0","modified":1574642653521},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1574642653521},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4fb385d8533877678440c8faa08b68fa793cb1a2","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"1693ec6b53758ac15d2c7798c789d6ae8af913ea","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"24a086a6904bbf5355a354403c9b0e6069f7eb01","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"48743ac61af37a4de2026667e15a65de5e8cf542","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e321bd62f5e04d1fdc101a470ec13604e99816a5","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"316ee13fc26d327c8862c2455211144c180cf9c1","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"eeab294e14abbae231107e1a327e907b25323136","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"f1f81bca31e82ccbd375f0cb9fb8dbb3beac810d","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f5abb2ea7746586738fb4e82107fceed041708ee","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"c0ed534696ed86560c95ab2a3541b2b42a41ed39","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c59226767164285d6708d8762f937f93bab264ca","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0424a1fcffa1ae82fe70935972a894aca885bf9a","modified":1574642653541},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1574642653541},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"80d359661d08b80ad561b97f8508766b3e1f6d01","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"47ee915d7b0a97e74140a25fbfc01c04d6781534","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"112f5e8f1fe5cec4419e87acfbdef0e615ed23f3","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"41c7cd1b63d49476ed5fbdd26ab9411d8f44bd05","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1574642653537},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"29d865f18f904b23a182d2f3c1e077e663d5874b","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"d8ba44b8e1a0332c5c1079ff65fc83d2918a5865","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"2b52b0eb4c66e06762cf115450da0ca1dd435e75","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1574642653541},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1574642653544},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1574642653544},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1574642653547},{"_id":"source/_posts/i3/41912.jpg","hash":"c12b76d2f50d2ee2319fba346a07fab1029a65aa","modified":1569230650877},{"_id":"source/_posts/i3/556990.jpg","hash":"4357c40fcbf8db07a4d9eab78b9357e448468edb","modified":1569230650887},{"_id":"source/_posts/qt/qt_server.png","hash":"b0cecc91b365bd58cd340331a1b41903d8c6f6c4","modified":1565770685606},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e76e0e411c9892004e73e1bb7b3c1cca2191eedc","modified":1574642653544},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1574642653547},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1574642653547},{"_id":"source/_posts/Lei/test.txt.gz","hash":"c72d5254b82c6daa59d14a19b35df319c7ca3479","modified":1560239395974},{"_id":"source/_posts/i3/231046.jpg","hash":"6c4ce84231a667f1034edce15baba9c238b1393f","modified":1569230650884},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"7fbb5ad8802851a44faab33a4425279542fc55d0","modified":1574642653521},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6336c2b129db802221b1fd75e5fbe8aab85c0a1f","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"98227b4de364b48b11e21efcf4f1beb2ed3ab329","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"4b84f35e7040f9adb5cc540c366d7f9eb4c48bcc","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"602a3c3d2785965b23412b5c219dfe74b5fb0844","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"d557a0de91a428330b43cdae9f1ec7167d24e2e4","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"bcba503e956e4b737b062faa66341bd880f16c10","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9df5ba77e6cf36129bddc270407215c23c60ff38","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"284249dcfa3b49c5d76210bbb0f74f65fc2f12ea","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1574642653537},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2d9d68a431a334626d463bb1bdfbcd2ea8242e94","modified":1574642653537},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"5528a755b180312d008054653633d857aeeb6780","modified":1574642653537},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1574642653537},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"0672ea2acf28dcc2cfc5244da36d3387d71a17cb","modified":1574642653537},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1574642653537},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"4b237e2344f35e9d1f6dbc3842d5e432d478ebfd","modified":1574642653537},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"d5d85d3646d184e0340924addcfd2523fb289d00","modified":1574642653537},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a7ed54e2f52185a7b6bb9a8201f6c3aa74b0cb00","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b5ba1b3d5535ccf1e5df6f4cd8ee0147d7278be9","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"cc4beedb56c37246d9e0f74e4b2cc34231dabc65","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"1db4ce981fe9fcb9ee4279395c29553efbb43947","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"e2ad7ccf1865a45548e3f31c70fac2c65d6ef534","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"eaa62b5de4ddb18378c1a4049a172d4fa4b655d8","modified":1574642653541},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"9a18b186b08ec220d1b17cf83812bcdd06077814","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"b492a45422773ab2af06ee345d527ba4c6bbc608","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"ae13712e313aacfce989d97ed6cba0606c776fb3","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"42a12c718b5832cd535a4631759376910c549d94","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"5bf28a03ef021c27cfd713971caca5a0b9466fd1","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"068b304be305fbfd0220276d56b93cefd968f0b6","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"0746320211c11e48e43c3446ac9767e5ffb60fd3","modified":1574642653541},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1574642653541},{"_id":"source/_posts/i3/247971.jpg","hash":"2fa15c4c85d07b08f8c329c72a067f3641e0ba70","modified":1569230650884},{"_id":"source/_posts/i3/931367.jpg","hash":"05db9492cb5947386a9bb75a10b228bd124b0f39","modified":1569230650894},{"_id":"source/_posts/test/.jpg","hash":"ad4912fc95a86faf2fb89924f6d9464e1922b07b","modified":1560239395977},{"_id":"themes/next/.git/objects/pack/pack-03ffaec0e5f95a3c7df82b4579bd1180ba8286f8.idx","hash":"e70bccfb9b8cdcf28fcb138acf9a6a8c4fb063e1","modified":1574642653501},{"_id":"source/_posts/i3/246420.jpg","hash":"1959dd083bd3535f6c9359385eefad0f02d96abd","modified":1569230650884},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1574642653547},{"_id":"source/_posts/i3/test1.jpg","hash":"87e60aa95b4f5f9aec50db9fb3b807e06f5ede17","modified":1569230650894},{"_id":"source/_posts/i3/228532.jpg","hash":"ea6e0ea16bf9602214d7820e75bbd882318ccf81","modified":1569230650884},{"_id":"source/_posts/i3/246755.jpg","hash":"01d9b863ae0e33e2bade82b8c5a90ff5bdbee42e","modified":1569230650884},{"_id":"source/_posts/i3/251996.jpg","hash":"6d4a84aa35b40aebe30b764871e60e68f4e03cbb","modified":1569230650884},{"_id":"source/_posts/i3/166859.jpg","hash":"547c2fe5e86bc967e77f635982fea6ede71f3528","modified":1569230650880},{"_id":"source/_posts/i3/674994.jpg","hash":"549d9b95ab514f4e8a9a9e033bda5fde6c2fb9c8","modified":1569230650890},{"_id":"source/_posts/Lei/file.zp","hash":"6b80e3d9dde35eeabfd2b013e47f74d013397b1b","modified":1560239395974},{"_id":"source/_posts/i3/228533.jpg","hash":"47b28b843a0cb942c792947b0fabeb3d5370fc4d","modified":1569230650884},{"_id":"source/_posts/i3/113997.jpg","hash":"eac646c08acf9774aba7b2bf5c4dbd7c0b788f0b","modified":1569230650880},{"_id":"source/_posts/i3/252202.jpg","hash":"e4ec84f17a4b95c546617050154c0c62398163b2","modified":1569230650887},{"_id":"source/_posts/i3/81939.jpg","hash":"7e71805cdb0db4fd51690cb8747885087d3d898d","modified":1569230650877},{"_id":"source/_posts/i3/424059.jpg","hash":"10fcaea700010b79ac3d21bb9706d7ff78cdc194","modified":1569230650887},{"_id":"source/_posts/i3/228129.jpg","hash":"9a99987aedb4f940a22285ff00d0e99bd2fdee9c","modified":1569230650884},{"_id":"source/_posts/i3/213983.jpg","hash":"e168a00636debf0433c880f27bf223ab272e6be5","modified":1569230650880},{"_id":"source/_posts/i3/654159.png","hash":"60cea6b92e7733747833ff55a1688bb6d3adaa8c","modified":1569230650890},{"_id":"themes/next/.git/objects/pack/pack-03ffaec0e5f95a3c7df82b4579bd1180ba8286f8.pack","hash":"423a56c3a4e4086f64a746d038aafc3c70638d62","modified":1574642653491},{"_id":"public/2019/11/25/test-2/index.html","hash":"a6eb3ad4e41c6c118431d575ee525d1d1e963fb5","modified":1574645050359},{"_id":"public/2019/09/10/hello-world/index.html","hash":"71f28063cc26c728c49276d60b7f85c6e194606b","modified":1574645671311},{"_id":"public/2019/06/19/constellation/index.html","hash":"fd8e49324654fb20b871fc8e529dc15c630a3c85","modified":1574645050360},{"_id":"public/2019/06/11/JustATest/index.html","hash":"af305bdf26e1287dce32e4a36fe324ca6d5050bd","modified":1574645050360},{"_id":"public/2019/06/05/Code/index.html","hash":"f79d889379dbdfb7a4e2afbe1c581e5ac780d630","modified":1574645050360},{"_id":"public/2019/06/03/tar/index.html","hash":"574949e9dd59959e04c8abde4b99a32f1e98c161","modified":1574645050360},{"_id":"public/2019/05/31/Class/index.html","hash":"777d526b1a92cba4e80a9e668bdf4a79eb568961","modified":1574645050360},{"_id":"public/2019/05/31/test2/index.html","hash":"68cbad8aabe8e209d59654eaa396f6b2c4de8d18","modified":1574645050360},{"_id":"public/2019/05/31/test-1/index.html","hash":"628d37f03f7c4eddc26dc63623bcfe24e5cb02dd","modified":1574645050360},{"_id":"public/2019/05/19/test/index.html","hash":"4a6f180715dd3c50b9563ede37de60df266afc56","modified":1574645050360},{"_id":"public/2019/05/06/小萝莉/index.html","hash":"b375ce9b279865b7bde52056bae08be94fca1919","modified":1574645050360},{"_id":"public/archives/index.html","hash":"fe6c49d220b98e5a3a5ca5ae28aeb67787c2414b","modified":1574645671311},{"_id":"public/archives/page/2/index.html","hash":"550f665386b47ab9cec6bc1734ecbdf248dc3883","modified":1574645050360},{"_id":"public/archives/2019/index.html","hash":"b94dd5d4e89651aac647b2284c6504876bbcb332","modified":1574645671312},{"_id":"public/archives/2019/page/2/index.html","hash":"c6ae7f8d4af2bd16f986bf5f001d6425e396e2b2","modified":1574645050360},{"_id":"public/archives/2019/05/index.html","hash":"56d2ac9a8228004ca8ce407c72b5dca161f6f325","modified":1574645050360},{"_id":"public/archives/2019/06/index.html","hash":"53e94969dee40acbae7b403f2afb982a2d3479b0","modified":1574645050361},{"_id":"public/archives/2019/08/index.html","hash":"c5b1653ab2279609f13ec738fa060ef428ce6c6c","modified":1574645050361},{"_id":"public/archives/2019/09/index.html","hash":"a50afef18886f2b61e9c809a5a1165c2748fcd5c","modified":1574645671312},{"_id":"public/archives/2019/11/index.html","hash":"a503151cc54417c56aab5340822225d63785b719","modified":1574645050361},{"_id":"public/tags/Test/index.html","hash":"104c8d13eccb356e72a420f91d7c12bddbe200a9","modified":1574645050361},{"_id":"public/tags/test/index.html","hash":"448d3c0e0a33a61a07c2a2a29fc1702d133d33e5","modified":1574645050361},{"_id":"public/2019/09/22/i3/index.html","hash":"0bd3475a2ebc356d96b3e6fa8401882146e24aa1","modified":1574645671312},{"_id":"public/2019/09/19/java/index.html","hash":"09c9e56c0fcc1e80f8d414e5b8844d5cec935321","modified":1574645050361},{"_id":"public/2019/09/10/mysql/index.html","hash":"6530e1ec0e768325b89afcf10cfe0b45245850a3","modified":1574645050361},{"_id":"public/2019/08/05/qt/index.html","hash":"21c5c4a5bf546df38bf4d11817bbbfa0cec4cb23","modified":1574645050361},{"_id":"public/2019/06/12/C-Book/index.html","hash":"148dc874a671de7683979b2e9780ea9f239574e6","modified":1574645050361},{"_id":"public/2019/06/04/Noteslinux1/index.html","hash":"bc334f2afc7e32b577a1ff130d2610a84958ce05","modified":1574645050361},{"_id":"public/2019/05/31/file/index.html","hash":"9d27d6d165675b36615222627cfbc1c474de38e4","modified":1574645050361},{"_id":"public/2019/05/21/c-Notes/index.html","hash":"751083548fd80766478eea2919acf1dffcf927fc","modified":1574645050361},{"_id":"public/index.html","hash":"0411a48cf1bf58e79c679c8ef39891c18497a363","modified":1574645671312},{"_id":"public/page/2/index.html","hash":"4b2e340e61b32c289b189cd2849821d9973c6b79","modified":1574645050362},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1574645004222},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1574645004222},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1574645004222},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1574645004222},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1574645004222},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1574645004222},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1574645004222},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1574645004222},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1574645004222},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1574645004222},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1574645004222},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1574645004222},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1574645004222},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1574645004222},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1574645004222},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1574645004223},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1574645004223},{"_id":"public/2019/05/31/Class/Lpur2.png","hash":"efc22e1a1e37e75baa7b788d1fea94611eacf02b","modified":1574645004223},{"_id":"public/2019/06/05/Code/Code1.png","hash":"54287ffb565af64e9a6bc36941563327f2a43902","modified":1574645004223},{"_id":"public/2019/05/19/test/a.jpg","hash":"7d0458d48481078303d783a9574cab09e324f60c","modified":1574645004223},{"_id":"public/2019/05/31/file/file1.png","hash":"14fbb290eabbb2b088fd610a943876b2d2b36c05","modified":1574645004223},{"_id":"public/2019/06/03/tar/tar.png","hash":"46549e929e679709e4073ccd86fa47c05f92f848","modified":1574645004223},{"_id":"public/2019/06/03/tar/tar1.png","hash":"935f3390171658cc0fd30f86d0cfa83375d2ccee","modified":1574645004223},{"_id":"public/2019/05/06/小萝莉/sda.jpg","hash":"b905c165bd7022bffd52a5bd8714afc038091a23","modified":1574645004223},{"_id":"public/2019/06/12/C-Book/c-Book.png","hash":"087c1f14d7d19a929961c98be3a94db669d63369","modified":1574645004223},{"_id":"public/2019/06/12/C-Book/c-Book1.png","hash":"9533241ea8cf7808b485527843d92fdf14fbbbdb","modified":1574645004223},{"_id":"public/2019/06/12/C-Book/c-Book3.png","hash":"68c38dd892d6626178492147bda59c770a36ec93","modified":1574645004223},{"_id":"public/2019/06/12/C-Book/c-Book4.png","hash":"c2d9847f52f04acbf7be2841091c2d4bca74959a","modified":1574645004223},{"_id":"public/2019/06/12/C-Book/c-Book5.png","hash":"e0345487c68d55dc8dc78f77dc39a865426e26c4","modified":1574645004223},{"_id":"public/2019/09/10/mysql/mysql0.png","hash":"84b39d35d7672b9f503159517892c9b4deb1a695","modified":1574645004223},{"_id":"public/2019/09/10/mysql/mysql3.png","hash":"2e51e7aa390db4cd7b68c3f654c67658019eb5d7","modified":1574645004223},{"_id":"public/2019/05/21/c-Notes/WC.png","hash":"53e4ea434ec5d17e0be7c89c3632c49ac0fb53c1","modified":1574645004224},{"_id":"public/2019/05/21/c-Notes/YC.png","hash":"2c7b67083d726c4f343c3149a168e9a39f137ce1","modified":1574645004224},{"_id":"public/2019/05/21/c-Notes/YC1.png","hash":"1ef204c5da4c7ca802c8a4ee447b3818e866ff08","modified":1574645004224},{"_id":"public/2019/05/21/c-Notes/YC2.png","hash":"dd7989c0644da90ef8c8e369b7025169fdffc280","modified":1574645004224},{"_id":"public/2019/05/21/c-Notes/YC3.png","hash":"8a32fd85ed5096a64b9cb5ddb75c0677320317d0","modified":1574645004224},{"_id":"public/2019/05/21/c-Notes/YC4.png","hash":"503622c67c5eaf427b4b08541daa447bffc62d88","modified":1574645004224},{"_id":"public/2019/05/21/c-Notes/YC5.png","hash":"809b91cc0157e727c5ca4147765cc1a3b8b73e28","modified":1574645004224},{"_id":"public/2019/09/22/i3/crayon_shin_chan-002.jpg","hash":"a10f80a07286a1ca4b029c2f105366eb9a2d41f7","modified":1574645004224},{"_id":"public/2019/09/22/i3/test2.jpg","hash":"2066cd369e49dba4240797eb0693c74c29ef51e4","modified":1574645004224},{"_id":"public/2019/09/22/i3/test3.jpeg","hash":"009c5f2283ad3999fdb6336e9461331bc790faf9","modified":1574645004224},{"_id":"public/2019/09/22/i3/头像.jpeg","hash":"348f83e3863f4d36159fdcfde3da05b23c40bc67","modified":1574645004224},{"_id":"public/2019/09/22/i3/test5.jpeg","hash":"2366bddaf27ba51a74bf3b48b4c94f553897696b","modified":1574645004224},{"_id":"public/2019/09/22/i3/test7.jpg","hash":"7fc88d04627f532bb8c4507ba8ec4a00953e3d62","modified":1574645004224},{"_id":"public/2019/08/05/qt/qt1.png","hash":"8ccfbcce3b05793c8cc909950cdd003b78c8a8ad","modified":1574645004224},{"_id":"public/2019/08/05/qt/qt10_ui.png","hash":"e0c36a98266fe765d04c2d64ec024f9353ecd521","modified":1574645004224},{"_id":"public/2019/08/05/qt/qt2_hello.png","hash":"45de44b825c02b0ed70b2192cbcc0d07b63a7fd7","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt3_caidan.png","hash":"cf1cc655315c30cf5496c45dcd4396d3a0b97de9","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt4_duihua.png","hash":"87123682d26bc7d76a7dc82326ed6221f4be6e32","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt5_duihua.png","hash":"5193e5b313dc5e24e348474fd828db606018c1dc","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt6_ui.png","hash":"9b8e1e3d146d5d77ac3db18a17f4ff00e684d806","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt7_ui.png","hash":"a5c1d2062b823914f0eb02717704f9652c428d6f","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt8_ui.png","hash":"d0ea982a54b735651988c76ad271cd96e677eaaf","modified":1574645004225},{"_id":"public/2019/08/05/qt/qtEvent.png","hash":"9dcac426770c8cc36f8dcabcb5a72d481ea4c693","modified":1574645004225},{"_id":"public/2019/08/05/qt/qtEvent1.png","hash":"f2ee3a301150ff39b7554a2adad8ca1b33ab18c7","modified":1574645004225},{"_id":"public/2019/08/05/qt/qtEvent2.png","hash":"d5b310f025675faaf46d19f2d589a7a6f493d06f","modified":1574645004225},{"_id":"public/2019/08/05/qt/qtEvent3.png","hash":"7f875b2546ff43509851b2b6133fafdffe27ccb6","modified":1574645004225},{"_id":"public/2019/08/05/qt/qtEvent4.png","hash":"cafe6234676b31dfeebbf6c16a04f911504e3b39","modified":1574645004225},{"_id":"public/2019/08/05/qt/qtFILE.png","hash":"316d1b5ed005c30b341dffcd7ba9eb7538e99288","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt_image.png","hash":"e49b6c045f89fbcdb134811284e3dd170aa8829a","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt_paint1.png","hash":"1ce3283b3034dc5361ee646520c401d5704357f8","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt_picture1.png","hash":"afa79f2b9ac9d80e6858959f6ef28076939a127f","modified":1574645004225},{"_id":"public/2019/08/05/qt/qt_picture2.png","hash":"6318fcb3e651be37edb34de2c2e791982cad51d1","modified":1574645004226},{"_id":"public/2019/08/05/qt/qt_pixmap.png","hash":"1049ab02c50c73358d02e111890429255be429d0","modified":1574645004226},{"_id":"public/2019/08/05/qt/qt_pixmap2.png","hash":"f8eb40068fb7d517ecb75f72f5232e71b895cb6d","modified":1574645004226},{"_id":"public/2019/08/05/qt/qt_tcpserven2.png","hash":"4e732580a9526bb19c6cf7d3010beac43e3b0f79","modified":1574645004226},{"_id":"public/2019/08/05/qt/qt_udp.png","hash":"951fe18fdee09ea07f636cb04254c43f97deafd3","modified":1574645004226},{"_id":"public/2019/08/05/qt/qt_udp2.png","hash":"a504b47275948331aecc07ee6c06dcfb952b6872","modified":1574645004226},{"_id":"public/2019/08/05/qt/qtwritefile.png","hash":"082a34a98e1448ad7e9191c5ce5dbfad762a4fa9","modified":1574645004226},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1574645004648},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1574645004649},{"_id":"public/2019/06/04/Noteslinux1/chattr.png","hash":"4e0b0081244ac60cd915af6576cf699d81836e1f","modified":1574645004649},{"_id":"public/2019/05/31/file/file.png","hash":"4493b22e0a3079dd30e8cd3693776936401fc46a","modified":1574645004649},{"_id":"public/2019/05/06/小萝莉/test.png","hash":"5dbdce767c229ce56fda00e932ac1fcdd6fabd17","modified":1574645004649},{"_id":"public/2019/06/12/C-Book/c-Book2.png","hash":"4f26607566b1c847bd5fe240eba6a2a460c48e06","modified":1574645004650},{"_id":"public/2019/09/10/mysql/mysql2.png","hash":"0ac4f99602aaa11e918726111ea487ef4a2e6fbe","modified":1574645004650},{"_id":"public/2019/09/10/mysql/mysql5.png","hash":"61901a7f1d7b9dd8a53ad144529a5f724a473630","modified":1574645004650},{"_id":"public/2019/09/22/i3/710742.jpg","hash":"8cf708f93f621fe55a5f55f0e5baab2be6b2f11d","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt12_ui.png","hash":"b52a4b1a6cf7d6fc71079f7e6f7b6412e0d06289","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt11_ui.png","hash":"bf20b1b26362eff4d400b9b7e4aa236c26350631","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt9_ui.png","hash":"7f243bb0fe25a1f0ff0248eaa7224331ea78a73c","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt_Stream.png","hash":"64a3969d48dd971cfa80bfe6d64a737f63711093","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt_paint.png","hash":"4f8e137dabfa3d9e1c1f87bff0b8c7b4bb143c51","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt_picture.png","hash":"1f3f631d4e6c68a619c7e1ac9af08406a899a197","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt_tcpfile.png","hash":"ad10452fdea2d1d92d0553a3723916e38e361517","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt_tcpserven1.png","hash":"69cfb3430235954c5b27cbe9040b40dc6f406fa3","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt_udp1.png","hash":"6f55124c81d8c4081404e22862f11a1a0751717f","modified":1574645004650},{"_id":"public/2019/08/05/qt/qt_zhuan1.png","hash":"d9e90d9ab81c29de5372fb4ea000aa903ceac09e","modified":1574645004650},{"_id":"public/2019/08/05/qt/qtzhuan.png","hash":"415f55e2c19bd5b82f69c4c14d782b8aa2441d68","modified":1574645004651},{"_id":"public/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1574645004658},{"_id":"public/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1574645004658},{"_id":"public/js/motion.js","hash":"9ac69597315b5b7b4c8900b7949d2a31387d6284","modified":1574645004658},{"_id":"public/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1574645004658},{"_id":"public/js/utils.js","hash":"ba4c1cb25071a9fe0b94dd001d2413307bbaeb80","modified":1574645004658},{"_id":"public/js/next-boot.js","hash":"f7045763e277e685c271bd4b4c37e531d699ac63","modified":1574645004658},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1574645004658},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1574645004659},{"_id":"public/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1574645004659},{"_id":"public/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1574645004659},{"_id":"public/css/main.css","hash":"464552b5393b0c4f0f720fc6d369999a73193fb2","modified":1574645004659},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1574645004659},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1574645004659},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1574645004659},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1574645004659},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1574645004659},{"_id":"public/2019/09/22/i3/228568.jpg","hash":"32ca6f63b9817cc872e9c6f278d1c3b4685c1cc9","modified":1574645004659},{"_id":"public/2019/09/22/i3/608422.jpg","hash":"053a7ed987f6e3b65b917aac6a69e57966643269","modified":1574645004659},{"_id":"public/2019/09/10/mysql/mysql1.png","hash":"700d308f60ba9f7feda8541893a4a11df4d427ce","modified":1574645004659},{"_id":"public/2019/08/05/qt/qtEventpainter1.png","hash":"aced6e65da772a7fd8cff022c92e929dba1d9e0e","modified":1574645004659},{"_id":"public/2019/09/22/i3/169068.jpg","hash":"b6ce51c86562895e6636aa200b6626c9b682949b","modified":1574645004659},{"_id":"public/2019/08/05/qt/qtEventpainter2.png","hash":"31cb6a8d0b83d2e9f5803e6c89ab72a943170976","modified":1574645004660},{"_id":"public/2019/08/05/qt/qt_Read.png","hash":"9fff6623d58ca11be5cee7a8715331d1ae34d2b0","modified":1574645004660},{"_id":"public/2019/08/05/qt/qt_tcpserven.png","hash":"55a74a8a6c4ab88209820b7a6fb107f114e83dff","modified":1574645004660},{"_id":"public/2019/08/05/qt/qtreadfile.png","hash":"868d517138628a1c6cc8a8bbaf24ad6978aa8dab","modified":1574645004660},{"_id":"public/2019/09/10/mysql/mysql4.png","hash":"9c849400454a422cd95a1ea4b88bd8c649393b71","modified":1574645004667},{"_id":"public/2019/09/22/i3/927682.jpg","hash":"2e6da726afaf01db329886d783aa55fc7b2d313b","modified":1574645004674},{"_id":"public/2019/09/22/i3/556990.jpg","hash":"4357c40fcbf8db07a4d9eab78b9357e448468edb","modified":1574645004681},{"_id":"public/2019/09/22/i3/931367.jpg","hash":"05db9492cb5947386a9bb75a10b228bd124b0f39","modified":1574645004681},{"_id":"public/2019/08/05/qt/qt_server.png","hash":"b0cecc91b365bd58cd340331a1b41903d8c6f6c4","modified":1574645004682},{"_id":"public/2019/09/22/i3/41912.jpg","hash":"c12b76d2f50d2ee2319fba346a07fab1029a65aa","modified":1574645004690},{"_id":"public/2019/09/22/i3/231046.jpg","hash":"6c4ce84231a667f1034edce15baba9c238b1393f","modified":1574645004699},{"_id":"public/2019/09/22/i3/246420.jpg","hash":"1959dd083bd3535f6c9359385eefad0f02d96abd","modified":1574645004708},{"_id":"public/2019/09/22/i3/247971.jpg","hash":"2fa15c4c85d07b08f8c329c72a067f3641e0ba70","modified":1574645004722},{"_id":"public/2019/09/22/i3/test1.jpg","hash":"87e60aa95b4f5f9aec50db9fb3b807e06f5ede17","modified":1574645004722},{"_id":"public/2019/09/22/i3/251996.jpg","hash":"6d4a84aa35b40aebe30b764871e60e68f4e03cbb","modified":1574645004735},{"_id":"public/2019/09/22/i3/228533.jpg","hash":"47b28b843a0cb942c792947b0fabeb3d5370fc4d","modified":1574645004742},{"_id":"public/2019/09/22/i3/246755.jpg","hash":"01d9b863ae0e33e2bade82b8c5a90ff5bdbee42e","modified":1574645004742},{"_id":"public/2019/09/22/i3/228532.jpg","hash":"ea6e0ea16bf9602214d7820e75bbd882318ccf81","modified":1574645004758},{"_id":"public/2019/09/22/i3/674994.jpg","hash":"549d9b95ab514f4e8a9a9e033bda5fde6c2fb9c8","modified":1574645004758},{"_id":"public/2019/09/22/i3/166859.jpg","hash":"547c2fe5e86bc967e77f635982fea6ede71f3528","modified":1574645004766},{"_id":"public/2019/09/22/i3/113997.jpg","hash":"eac646c08acf9774aba7b2bf5c4dbd7c0b788f0b","modified":1574645004768},{"_id":"public/2019/09/22/i3/252202.jpg","hash":"e4ec84f17a4b95c546617050154c0c62398163b2","modified":1574645004775},{"_id":"public/2019/09/22/i3/81939.jpg","hash":"7e71805cdb0db4fd51690cb8747885087d3d898d","modified":1574645004781},{"_id":"public/2019/09/22/i3/424059.jpg","hash":"10fcaea700010b79ac3d21bb9706d7ff78cdc194","modified":1574645004786},{"_id":"public/2019/09/22/i3/228129.jpg","hash":"9a99987aedb4f940a22285ff00d0e99bd2fdee9c","modified":1574645004793},{"_id":"public/2019/09/22/i3/213983.jpg","hash":"e168a00636debf0433c880f27bf223ab272e6be5","modified":1574645004796},{"_id":"public/2019/09/22/i3/654159.png","hash":"60cea6b92e7733747833ff55a1688bb6d3adaa8c","modified":1574645004806},{"_id":"source/_posts/test-2/java4.png","hash":"ccfca7470cc0882b4122af8bffcb2d8770e7ae79","modified":1574645319948},{"_id":"public/2019/11/25/test-2/java4.png","hash":"ccfca7470cc0882b4122af8bffcb2d8770e7ae79","modified":1574645517622},{"_id":"source/_posts/Java.md","hash":"fceb5bb0c665a5e84b76478243512673867abadd","modified":1574645320055},{"_id":"public/2019/09/19/Java/index.html","hash":"d9931003899a9fcb6446387361a194c9cb361e4d","modified":1574645671315},{"_id":"public/2019/09/19/Java/java1.png","hash":"ffad55f4be251da9ee6542ba5dac36a329476b56","modified":1574645671318},{"_id":"public/2019/09/19/Java/java2.png","hash":"2e9e385de23b112b61b2c9e7dd46109c0e94a6e1","modified":1574645671318},{"_id":"public/2019/09/19/Java/java3.png","hash":"152bd8aa4b5884c4075e64af3d23ab6f0beed3e5","modified":1574645671319},{"_id":"public/2019/09/19/Java/java4.png","hash":"ccfca7470cc0882b4122af8bffcb2d8770e7ae79","modified":1574645671319},{"_id":"public/2019/09/19/Java/java0.png","hash":"eaadc69952a23318e4e0c92c7112cbfb63f3e43d","modified":1574645671321}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Class","date":"2019-05-31T13:51:02.000Z","_content":"\n![Lpur2](Class/Lpur2.png)\n","source":"_posts/Class.md","raw":"---\ntitle: Class\ndate: 2019-05-31 21:51:02\ntags:\n---\n\n![Lpur2](Class/Lpur2.png)\n","slug":"Class","published":1,"updated":"2019-06-11T07:49:55.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7qj00004ez72ofvjorl","content":"<p><img src=\"/2019/05/31/Class/Lpur2.png\" alt=\"Lpur2\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/05/31/Class/Lpur2.png\" alt=\"Lpur2\"></p>\n"},{"title":"Code","date":"2019-06-05T05:17:32.000Z","_content":"# Notes c++\n1. 二进制\n* 这里说的是调用一个c++函数来实现的。\n```\n#inciude <iostream>\nusing namespace std;\nint main(){\n     bitset<32>a(100)     //值得注意的是这里的32是数据类型转换bit来定义的。\n     cout<<a<<endl;  //输出是以二进制的形式来输出的，也就是说，把数字转换成了二进制\n     cout<<sizeof(int)<<endl;     //配上这个来使用比较明白\n}\n```\n![转换二进制](Code/Code1.png)\n* 其实你也可以在上面的基础下把数据类型给换了，这样你也可以看你想要转换的二进制。\n* IDE (集成开发坏境)\n* 数据类型字节（本人电脑）\n**int:4,float:4,long:4,double:8,char:1,bool:1,string:32,long double:16**\n**wchar_c:4,**\n----\n2. 操作符:一元操作符，二元操作符，三元操作符。\n* 一元操作符:操作在一个数的操作符。（++,--,&,*）\n* 二元操作符:操作在两个数上的操作符。（+,-，*,/,%,）\n* 三元操作符:操作在三个数上的操作符。(条件操作符，?:)等\n---\n3. 逻辑操作符(&&,||,!)\n* &&(逻辑与):只要一个为0就为0，相反的两个为1才为1。\n* ||(逻辑或):只要一个为1就为1，相反的两个为0才为0。\n* !(逻辑非):自己脑补。\n* **位操作符(&,|,^,~,<<,>>)**\n* **&:位与。|:位或。 ^:异或。 ~:取补。 <<:左移。 >>:右移。**","source":"_posts/Code.md","raw":"---\ntitle: Code\ndate: 2019-06-05 13:17:32\ntags:\n---\n# Notes c++\n1. 二进制\n* 这里说的是调用一个c++函数来实现的。\n```\n#inciude <iostream>\nusing namespace std;\nint main(){\n     bitset<32>a(100)     //值得注意的是这里的32是数据类型转换bit来定义的。\n     cout<<a<<endl;  //输出是以二进制的形式来输出的，也就是说，把数字转换成了二进制\n     cout<<sizeof(int)<<endl;     //配上这个来使用比较明白\n}\n```\n![转换二进制](Code/Code1.png)\n* 其实你也可以在上面的基础下把数据类型给换了，这样你也可以看你想要转换的二进制。\n* IDE (集成开发坏境)\n* 数据类型字节（本人电脑）\n**int:4,float:4,long:4,double:8,char:1,bool:1,string:32,long double:16**\n**wchar_c:4,**\n----\n2. 操作符:一元操作符，二元操作符，三元操作符。\n* 一元操作符:操作在一个数的操作符。（++,--,&,*）\n* 二元操作符:操作在两个数上的操作符。（+,-，*,/,%,）\n* 三元操作符:操作在三个数上的操作符。(条件操作符，?:)等\n---\n3. 逻辑操作符(&&,||,!)\n* &&(逻辑与):只要一个为0就为0，相反的两个为1才为1。\n* ||(逻辑或):只要一个为1就为1，相反的两个为0才为0。\n* !(逻辑非):自己脑补。\n* **位操作符(&,|,^,~,<<,>>)**\n* **&:位与。|:位或。 ^:异或。 ~:取补。 <<:左移。 >>:右移。**","slug":"Code","published":1,"updated":"2019-06-11T07:49:55.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7qo00014ez7cmeeu0gq","content":"<h1 id=\"Notes-c\"><a href=\"#Notes-c\" class=\"headerlink\" title=\"Notes c++\"></a>Notes c++</h1><ol>\n<li>二进制</li>\n</ol>\n<ul>\n<li>这里说的是调用一个c++函数来实现的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#inciude &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">     bitset&lt;32&gt;a(100)     //值得注意的是这里的32是数据类型转换bit来定义的。</span><br><span class=\"line\">     cout&lt;&lt;a&lt;&lt;endl;  //输出是以二进制的形式来输出的，也就是说，把数字转换成了二进制</span><br><span class=\"line\">     cout&lt;&lt;sizeof(int)&lt;&lt;endl;     //配上这个来使用比较明白</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/2019/06/05/Code/Code1.png\" alt=\"转换二进制\"></p>\n<ul>\n<li>其实你也可以在上面的基础下把数据类型给换了，这样你也可以看你想要转换的二进制。</li>\n<li>IDE (集成开发坏境)</li>\n<li>数据类型字节（本人电脑）<br><strong>int:4,float:4,long:4,double:8,char:1,bool:1,string:32,long double:16</strong><br><strong>wchar_c:4,</strong></li>\n</ul>\n<hr>\n<ol start=\"2\">\n<li>操作符:一元操作符，二元操作符，三元操作符。</li>\n</ol>\n<ul>\n<li>一元操作符:操作在一个数的操作符。（++,–,&amp;,*）</li>\n<li>二元操作符:操作在两个数上的操作符。（+,-，*,/,%,）</li>\n<li>三元操作符:操作在三个数上的操作符。(条件操作符，?:)等</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li>逻辑操作符(&amp;&amp;,||,!)</li>\n</ol>\n<ul>\n<li>&amp;&amp;(逻辑与):只要一个为0就为0，相反的两个为1才为1。</li>\n<li>||(逻辑或):只要一个为1就为1，相反的两个为0才为0。</li>\n<li>!(逻辑非):自己脑补。</li>\n<li><strong>位操作符(&amp;,|,^,~,&lt;&lt;,&gt;&gt;)</strong></li>\n<li><strong>&amp;:位与。|:位或。 ^:异或。 ~:取补。 &lt;&lt;:左移。 &gt;&gt;:右移。</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Notes-c\"><a href=\"#Notes-c\" class=\"headerlink\" title=\"Notes c++\"></a>Notes c++</h1><ol>\n<li>二进制</li>\n</ol>\n<ul>\n<li>这里说的是调用一个c++函数来实现的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#inciude &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">     bitset&lt;32&gt;a(100)     //值得注意的是这里的32是数据类型转换bit来定义的。</span><br><span class=\"line\">     cout&lt;&lt;a&lt;&lt;endl;  //输出是以二进制的形式来输出的，也就是说，把数字转换成了二进制</span><br><span class=\"line\">     cout&lt;&lt;sizeof(int)&lt;&lt;endl;     //配上这个来使用比较明白</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/2019/06/05/Code/Code1.png\" alt=\"转换二进制\"></p>\n<ul>\n<li>其实你也可以在上面的基础下把数据类型给换了，这样你也可以看你想要转换的二进制。</li>\n<li>IDE (集成开发坏境)</li>\n<li>数据类型字节（本人电脑）<br><strong>int:4,float:4,long:4,double:8,char:1,bool:1,string:32,long double:16</strong><br><strong>wchar_c:4,</strong></li>\n</ul>\n<hr>\n<ol start=\"2\">\n<li>操作符:一元操作符，二元操作符，三元操作符。</li>\n</ol>\n<ul>\n<li>一元操作符:操作在一个数的操作符。（++,–,&amp;,*）</li>\n<li>二元操作符:操作在两个数上的操作符。（+,-，*,/,%,）</li>\n<li>三元操作符:操作在三个数上的操作符。(条件操作符，?:)等</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li>逻辑操作符(&amp;&amp;,||,!)</li>\n</ol>\n<ul>\n<li>&amp;&amp;(逻辑与):只要一个为0就为0，相反的两个为1才为1。</li>\n<li>||(逻辑或):只要一个为1就为1，相反的两个为0才为0。</li>\n<li>!(逻辑非):自己脑补。</li>\n<li><strong>位操作符(&amp;,|,^,~,&lt;&lt;,&gt;&gt;)</strong></li>\n<li><strong>&amp;:位与。|:位或。 ^:异或。 ~:取补。 &lt;&lt;:左移。 &gt;&gt;:右移。</strong></li>\n</ul>\n"},{"title":"JustATest","date":"2019-06-11T07:50:56.000Z","_content":"\n# JustATest\n\n前言，xxxxxxxxxxxxxx\n\n<!--more-->\n\n~~~C++\n#include <iostream>\nint main(){\n  std::cout<<\"helloworld\"<<std::endl;\n  return 0;\n}\n~~~\n","source":"_posts/JustATest.md","raw":"---\ntitle: JustATest\ndate: 2019-06-11 15:50:56\ntags:\n  - Test\n---\n\n# JustATest\n\n前言，xxxxxxxxxxxxxx\n\n<!--more-->\n\n~~~C++\n#include <iostream>\nint main(){\n  std::cout<<\"helloworld\"<<std::endl;\n  return 0;\n}\n~~~\n","slug":"JustATest","published":1,"updated":"2019-09-10T09:08:34.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7qq00024ez73a76ia66","content":"<h1 id=\"JustATest\"><a href=\"#JustATest\" class=\"headerlink\" title=\"JustATest\"></a>JustATest</h1><p>前言，xxxxxxxxxxxxxx</p>\n<a id=\"more\"></a>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"helloworld\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"JustATest\"><a href=\"#JustATest\" class=\"headerlink\" title=\"JustATest\"></a>JustATest</h1><p>前言，xxxxxxxxxxxxxx</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"helloworld\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"C++Book","date":"2019-06-12T06:31:03.000Z","_content":"                      c++\n <!--more-->\n# C++Book\n# 库\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    cout<<hello would<<endl;\n    return 0;\n}\n```\n**在上面的代码我们应该都知道我什么都没有实现，这只是在简单的阐述一下c++库的重要性，也可以说是让我们更深刻的认识到有些代码的意思是什么。**\n\n* #include,using (预编译指令) \n* iostream (是c++标准库，方便使用cout,cin,) \n* using namespace std (是命名空间,std,因为在库里大多数都有std命名空间的部分，所以规定这些名称为std)\n# 结构函数\n* 关键字struct+结构名\n```\n#include <iostream>\nusing namespace std;\nstruct point{\n    int a=5;\n    int b=10;\n};\nint main(){\n    point *p=new point;    //在堆内存里new了内存\n    p->a=10;\n    p->b=5;\n    cout<<p1->a<<\"\\t\"<<p1-><<endl;\n    point p1,p2;              //在栈内存里实现,还把poit里的参数全部给p2使用\n    cout<<p1.a<<\"\\t\"<<p1.b<<endl;\n    cout<<p2.a<<\"\\t\"<<p2.b<<endl;\n}\n```\n运行结果：\n```\n5    10\n5    10\n5    10\n```\n**其实结构和类是相似的**\n\n----\n# 联合函数\n* 关键字union+名字\n```\n#include <iostream>\nusing namespace std;\nunion test{\n    int a;\n    char b;\n};\nint main(){\n    test *p=new test;         //在堆内存new了内存\n    p->a=97;\n    cout<<p->a<<\"的字符表示是：\"<<p->b<<endl;\n    test t1;                  //在栈内存里实现\n    t1.a=65;\n    cout<<t1.a<<\"的字符表示是：\"<<t.b<<endl;\n}\n```\n**一样的和类相似，在栈和堆内存一样使用,不相同的是：联合函数你可以给变量的其中一个赋值，而另外一个变量会自己把已经赋值的那个变量的值赋给自己。**\n\n----\n# 枚举函数\n* 关键字enum+名字\n```\n#include <iostream>\nusing namespace std;\nenum Arrow{\n    eroos,ok,warning,\n}\nint main(){\n    Arrow a1=eroos;\n    Arrow a2=ok;\n    Arrow a3=warning;\n    cout<<a1<<a2<<a3<<endl;\n}\n```\n运行结果：\n```\n0\n1\n2\n```\n**枚举的特点：它是以字符的形式声明的，但输出的确实整数型的数字**\n\n----\n# 排序\n**排序的方法有很多，但我们只要理解一种就可以了。我选择冒泡排序**\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    int arr[]={3,10,5,11,6}\n    for(int i=5-1;i>0;i--){\n        //把第一个数字设置为最大的数字来跟剩下的数字一起来比较，所以这的次数是总数来减一\n        for(int j=0;j<i;j++>){\n            //把每一次大的循环里的数组的大值都往后一个交换位置\n            if(arr[j]>arr[j+1]){//条件满足就交换位置\n                int temp;\n                temp=arr[j];\n                arr[j]=arr[j+1];\n                arr[j+1]=temp;\n            }\n        }\n    }\n    cout<<\"排序后\"<<endl;\n    for(int i=0;i<5;i++){\n        cout<<arr[i]<<endl;\n    }\n}\n```\n运行结果\n```\n排序后\n3\n5\n6\n10\n11\n```\n# 递归函数\n**递归函数:调用的时候是使用栈内存来实现的，函数一层一层的往下递归，递归的同时会把函数停住，而计算机会重复的把信息保存到栈内存里，遇到递归停止的条件时又会一层一层的往上走在信息停止的那一步，从而实现递归的真正意义。值得注意的是，递归是栈内存的实现，它把信息放在最底层上。每当计算机往上走的时候都是从最低下中读取信息的。栈是先出后入的内存结构。**\n* 通俗一点的意思就是在本函数里调用自身函数。\n```\n#include <iostream>\nusing namespace std;\nint add(int i){\n    cout<<\"函数开始:i=\"<<i<<endl;\n    if(i=5){\n        return i;\n    }else\n    {\n        add(++i);\n    }\n    cout<<\"函数结束,返回值为：\"<<i<<endl;\n    return i;\n}\nint main(){\n    cout<<add(1)<<endl;\n}\n```\n函数的结果：`\n```\n函数开始：i=1\n函数开始：i=2\n函数开始：i=3\n函数开始：i=4\n函数开始：i=5\n函数结束，返回值为：5\n函数结束，返回值为：4\n函数结束，返回值为：3\n函数结束，返回值为：2\n函数结束，返回值为：1\n```\n* 这里的先是返回的自身函数调用的结果，这里编译器里是有五个变量来暂时存储自身函数的值，每当执行到函数返回的时候编译器都会从暂时存储那里把值返回给我们，还有一种理解，就是这个函数里的变量在每次自身函数调用的时候都被隐藏起来了，也就是说每次的自身函数的调用它都有不同的存储位置来让变量重新赋值。其实，递归函数是在返回的时候才是这种函数真真的意义，因为自身函数的最后一次刚好是函数返回值的第一次。\n```\n//阶乘的实现\n#include <iostream>\nusing namespace std;\nint test(int test1){\n    int val;\n    if(test1==1){//递归的停止条件\n        val=1;\n        return val;\n    }else{\n        val=test1*test(test1-1);\n        return val;\n    }\n}\nint main(){\n    cout<<\"实现阶乘,请输入一个数字:\"<<endl;\n    int t1;\n    cin>>t1;\n    cout<<test(t1)<<endl;\n}\n```\n**强调一下，递归的停止条件的重要性，一旦递归没遇到停止的条件就会无穷的死循环，直到计算机的内存都跑完!!!**\n```\n#include <iostream>\nusing namespace std;\nint test(int t1,int t2){\n    if(t2==0){\n        return 1;//递归的停止条件,t2==0,就返回1\n    }else{\n        return test(t1,t2-1)*t1;//上面返回的值来当作第一次的值，然后一直往上计算\n    }\n}\nint main(){\n    cout<<test(3,2)<<endl;\n}\n```\n运行结果\n```\n9\n```\n**递归的三大条件**\n* (有返回值类型，无返回值类型)\n1. 没有无穷的递归\n2. 每一种停止的情况都执行(返回)那种情况下的正确操作\n3. 所有递归函数的调用都能正确的执行操作，那么最后的结果一定是正确的\n----\n# 函数与指针\n* 指向函数的指针\n```\n#include <iostream>\nusing namespace std;\nint add(int a){\n    return a;\n}\nint test(int a){\n    return a;\n}\nint main(){\n    int (*p)(int a)=&add;//指向函数的指针\n    cout<<P(5)<<endl;\n    int (*ip[])(int a)={&add,&test};//指向多个函数的指针数组\n    cout<<ip[0](1)<<ip[1](2)<<endl;\n}\n```\n函数的结果：\n```\n5\n1\n2\n```\n* 这里的指针都是储存在栈内存里的。\n----\n# 预处理\n* 格式化代码，去除多余的空格和注释\n* 进行一些宏替换\n* 包含另外一段代码\n* 通过一些条件的判断，动态决定是否编译某段代码\n1. 宏定义\n\n**在定义宏的时候记得不要在定义的后面加分号！！！**\n----\n```\n#include <iostream>\nusing namespace std;\n#define MAX 9               //宏定义\n#define MAN2 MAX*MAX        //宏定义\nint main(){\n    cout<<MAX<<endl;\n    cout<<MAX2<<endl;\n}\n```\n运行结果为：\n```\n9\n81\n```\n2. 带参数的宏定义\n```\n#include <iostream>\nusing namespace std;\n#define MAX 3                        //无参宏定义\n#define space(x) ((x)*(x))           //声明一个带参数的宏定义\nint main(){\n    for(int i=1;i<=MAX;i++){\n        cout<<i<<\"的平方是：\"<<space(i)<<endl;\n    }\n}\n```\n运行结果是：\n```\n1的平方是：1\n2的平方是：4\n3的平方是：9\n```\n```\n#include <iostream>\nusing namespace std;\n#define add(a,b)(a+b)           //带参的宏定义\n#define test(x) #x         //#是连接\n#define test1(a*,* b) a##b        //a和b是连接在一起的\nint main(){\n    string s1(\"hello,\");        //字符串\n    string s2(\"world!\");\n    cout<<add(100,100)<<endl;\n    cout<<add(s1,s2)<<endl;     //使用宏来实现字符串的相加\n    cout<<test(hello world)<<endl;\n    int ab=10;\n    cout<<test1(a,b)<<endl;//这里的ab是连接起来的，所以在前面定义了ab的值，也就是说这里输出的只是变量ab的值，并不是说把a和b当作实参过去的。\n}\n```\n运行结果是：\n```\n200\nhello,world\nhelloworld\n10\n```\n**说明了宏的优点有:避免了强类型的检测**\n----\n3. 宏与常量，函数\n宏与常量有点相似，但当他们遇上指针和引用之后又会变成什么呢？\n```\n#include <iostream>\nusing namespace std;\n#define x 10\nconst int y=5;\nint main(){\n    const int &a=x;          //ok\n    const int *p=&y;         //ok\n    cout<<a<<\"\\t\"<<*p<<endl;\n}\n```\n运行结果：\n```\n10    5\n```\n**这里给宏使用了引用，给常量使用了指针。还在定义的前面都加了const类型。**\n**但是在这里还是不希望使用引用和指针的方式来操作宏和常量,把宏看作是简单的文本替换，这也是宏的原本意义。**\n\n**宏不允许重新定义，也就是说一个相同的宏只能被定义一次，要想修改宏的值，你只能先消除它，使用#undef关键来消除，然后你就可以重新定义了。**\n4. 在c++中有还有内置的宏\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    cout<<__TIME__<<endl; //输出当前代码运行的时间\n    cout<<__DATE<<endl;   //输出当前代码运行的日期\n    cout<<__LINE<<endl;   //输出当前代码的所在行号\n    cout<<__FIME__<<endl; //输出当前代码的文件路径\n}\n```\n5. #if #elif #else  #ifdef #ifndef\n```\n#include <iostream>\nusing namespace std;\n#define a 10\nint main(){\n    #if a<20\n    cout<<\"欢迎使用测试版\"<<endl;\n    #else\n    cout<<\"欢迎使用正版\"<<endl;\n    #endif\n    return 0;\n}\n```\n运行的结果：\n```\n欢迎使用测试版\n```\n**#if类似与我们在以前代码里的if，#else类似与else,#elif类似elseif**\n**#endif,很重要。如果没有它你的程序是跑不起来的。**\n---\n**在c++中有很多预定义函数，这其中有一中是异常处理函数，关键字(try)** \n```\n#include <iostream>\nusing namespace std;\nint main(){\n     __try{\n      int i;\n      cout<<\"请输入一个数字\"<<end;\n      cin>>i;\n      if(i<=0){\n      throw \"error\"\n     }\n      }catch(const char *p){//指定抛出异常的类型\n         cout<<p<<endl;\n      }catch(...){\n      cout<<\"在main函数里有异常\"<<endl;//任何抛出异常的类型都能接受,这里虽然是可以接受任何类型的异常但在前面已经有指定的抛出类型，所以在这里输出的是指定的抛出类型\n      }\n}\n```\n---\n**e.what(是用来打印异常抛出的)** \n```\n运行结果\nerror\n```\n---\n![不同的类型抛出](C-Book/c-Book4.png)\n- [ ] bad_typeid:\n- [ ] bad_cast\n- [ ] bad_alloc:在new一个内存时，如果没有足够的空间时会抛出异常来，\n- [ ] ios_base::failure:上一个的异常抛出打印的类型\n- [ ] logic_error---out_of_range:这是数组下标越界会抛出(out_of_range)类型的异常来\n\n```\n#include <iostream>\nusing namespace std;\n#define a 10\nint main(){\n    #ifdef a\n    cout<<\"欢迎使用正版\"<<endl;\n    #endif\n    return 0;\n    #ifndef\n    cout<<\"欢迎使用测试版\"<<endl;\n    #endif\n    return 0;\n}\n```\n**值得注意的是，#ifdef和#ifndef都要有#endif使用，#endif的意思应该是结束if**\n\n----\n# 预定义字符函数\n**预定义字符函数就是把字符转换成大，小写的字符，在计算机中，我们虽然是以字符的形式输入到计算机中，但计算机本身的运作却是以数字的形式来使用的。值得注意的是，书上写的需要头文件但我这里是不需要头文件的，可能是版本的问题吧，如果有报错的话就加个头文件(cctype)**\n1. toupper()(把字符转换成大写的)\n2. tolower()(小写) \n3. isupper()(如果字符是大写的就为true，否则false)\n4. islower()(同上)\n5. isspace()(如果字符是空白字符就为true,否则false)，一般这个识别的都跟着cin.get()这个函数，因为它识别空格，你可以在它识别空格的时候输出一些东西，下面有个小列子。\n```\n#include <iostream>\nusing namespace std;\nvoid test(){\n    char a,b;\n    cout<<\"请输入字符\"<<endl;\n    cin>>b;\n    a=toupper(b)\n    cout<<c<<endl;\n    if(isupper(b)){//条件一开始为false\n        cout<<\"转换成功\\t\"<<a<<endl;\n    }else{\n        cout<<\"转换失败\"<<endl;\n    }\n}\nint main(){\n    test();\n    char c;\n    cout<<\"请输入字符\"<<endl;\n    do{\n        cin.get(c);//逐步输入字符\n        if(isspace(c)){//判断是否符合条件     空格\n            cout<<'--';\n        }else{\n            cout<<c<<endl;\n        }\n    }while(c!='.');\n    cin.get();//识别空格，是空格就打印下面的那句话\n    cout<<\"空格\"<<endl;\n}\n```\n运行结果\n```\n请输入字符\na\n转换成功   A\n请输入字符\nadd test\nadd--test--.\n```\n----\n# 类\n   **类的特征**\n   -----\n1. 类同时具有成员变量和成员函数。\n2. 成员可变成私有和共有\n3. 正常下类的成员变量是私有的\n4. 类的私有成员只能在本类的函数里面定义和调用\n5. 类的成员函数可以像普通的函数一样重载\n6. 一个类可将另外一个类作为自己的成员变量的类性使用\n7. 函数的i形参可以是类的类型\n8. 类可以是函数的返回值类型\n----\n**类的基本**\n* 所有的成员变量设为私有的\n* 用户程序员通过函数作为成员变量的接口来访问变量和完善的规定如何使用每一个公共成员函数\n* 任何辅助函数都设为私有的\n----\n* 以前的数据和操作的过程都不是独立的，而c++允许我们将一些数据和操作数据的过程放在同一个地方，并封装成一个独立的个体。\n* 万物皆对象，这句话对c++程序员来说并不陌生。这并不代表我们缺少对象，对于我们这种高质男来说从来没担心过搞不到对象，因为我们随时随地都可以new一个对象出来，这不是一般人可以做到的，只有真的走进来了才可以的，虽然这个操作在c++中也不算是什么高难度的操作，但我们又不是学到这里就完事的。类和结构是完全可以交换的，唯一不一样的是结构的默认特性是public,而类的默认特性是private。\n----\n1. 数据类型:由值的集合以及为那些值定义的一组基本运算构成 \n2. 抽像数据类型(ADT):使用数据类型的程序员访问不了值和运算的细节 \n* 封装，是用简单明了的公有函数的方式为外部程序提供对象操作接口。\n# 成员对象\n* 分为三种：public,private，protected\n1. 公有对象：不管是在类里还是在外部都能被访问到。\n2. 私有对象：只能在本类中访问到。\n3. 保护对象：只能在本类中访问到，在外部是访问不到的。\n# 运算符重载\n1. 重载运算符，至少要有一个参数的类型是类\n2. 重载的函数可以是类的友元函数也可以是成员函数\n3. 不能新建运算符\n4. 不能改变获取的形参操作符的意义\n5. 不能改变操作符的优先级\n6. 不能重载一下操作符(.(圆点)::(作用域)...)    \n```\nclass Son;//先声明Son类\nclass Bos{\nfriend int operator+(Bos bos,Son son);//友元函数，用来访问类的私有成员\nfriend ostream &operator<<(ostream &os,Bos bos);//友元函数，用来访问类的私有成员\nprivate:\n    int a=10;\n    int b=5;\n}\nclass Son{\nfriend int operator+(Bos bos,Son son);//友元函数，用来访问类的私有成员\nfriend ostream &operator<<(ostream &os,Bos bos);//友元函数，用来访问类的私有成员\nprivate:\n    int a=5;\n    int b=10;\n}\nint operator+(Bos bos,Son son){//运算符重载加号\n    int a=bos.a+bos.b;\n    int b=son.a+son.b;\n    return a,b;\n}\nostream &operator<<(ostream &os,Bos bos){//运算符重载<<号\n    os<<\"a=\"<<bos.a<<\"b=\"<<bos.b<<endl;//把成员变量连接在cout流中\n    return os;//返回cout，这样就能在main函数中直接打印\n}\nint main(){\n    Bos bos;\n    Son son\n    cout<<bos+son<<endl;//这要是没有重载加号，是运行不过的\n    cout<<bos<<endl;//没有重载<<也是运行不过来的\n}\n```\n**谨慎参考，纯属本人理解。ostream,是因为要用到cout流，因为输出流是属于ostream里面的，&,是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。**\n----\n# const mutable\n* 众所周知，const是常量类型。而mutable是可变的，就像是普通变量。\n# vector\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n    vector <int >a{10,20,3,5,1};\n    a.insert(a.begin(),8);//在向量最前面插入数字8\n    sort(a.begin(),a.end());//升序\n    vector <int >::iterator it;//打印\n    for(it=a.begin();it!=a.end();it++){\n        cout<<*it<<\"      \";\n    }\n    reverse(a.begin(),a.end());//逆序\n    for(it=a.begin();it!=a.end();it++){\n        cout<<*it<<\"      \";\n    }\n    a.clear();//清除向量\n    vector <int > b;\n    a.swap(b);\n    for(it=b.begin();it!=b.end();it++){\n        cout<<*it<<\"      \";\n    }\n```\n---\n```\n运行结果\n1    3    5   8   10   20\n20   10   8   5   3   1\n20   10   8   5   3   1\n```\n```\n# include <iostream>\nusing namespace std;\nint main (){\n      int numb[]={10,20,23,11,}\n      int numb1[4]={0};\n      memcpy(numb1,numb,sizeof(numb));\n      for(int i=0;i<4;i++){\n      cout<<numb1[i]<<'   ';\n      }\n}\n```\n---\n\n```\n运行结果\n10   20   23   11\n```\n---\n\n- [ ] **静态成员函数和静态成员变量**\n\n```\n#include <iostream>\nusing namespace std;\n\".h\"\n# include <iostream>\nclass Test{\n      private:\n      static int a;\n      int b;\n      public:\n      Test(int _a){\n      a=_a;\n      ++b;\n      }\n      static void show(Test tt){//静态成员函数中通过对象来引用非静态成员\n      cout<<\"tt.a=\"<tt.a<<endl;\n      cout<<\"Test::b=\"<<Test::b<<endl;\n      cout<<\"tt.b=\"<<tt.b<<endl;\n      }\n}\nint Test::b=0;//这是放在main函数上面的\nint main(){\n        Test t1(100);\n        Test t2(200);\n        Test::show(t1);\n        Test::show(t2);//静态成员函数调用时不用对象名 \n\n}\n```\n```\n运行结果为：\ntt.a=100\nTest::b=2\ntt.b=2\ntt.a=200\nTest::b=2\ntt.b=2\n```\n\n# 继承\n```\nclass Teacher{\n    string _name;\n    int _year;\n    Teacher(string name,int year){\n        this->_name=name;\n        this->_year=year;\n    }\n    void show(){\n        cout<<this->_name<<\"老师的年龄是：\"<<this->_year<<endl;\n    }\n}\nclass Student::puble Teacher{\npublic:\n       Student(string name,int year):Teacher(name,year){\n       }\n}\n```\n**上面的基类用的是构造函数来给自己赋初始化的，所以在派生类也要写上自己的构造函数才算继承基类。**\n\n```\nint main(){\n    Student s1(\"小明\",18);\n    s1.show();\n}\n```\n运行结果是：\n```\n小明的年龄是：18 \n```\n**这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。**\n----\n* 继承的方式有三种：public private protected\n公有继承, 私有继承, 保护继承\n1. 公有继承：是以公有的形式来继承的基类，这也就意味着在基类是什么类型的在派生类也是一样的关系。\n2. 私有继承：是以私有的形式来继承的基类,就是说继承下来的基类都是以私有的形式来继承的。\n3. 保护继承：是以保护的形式来继承的基类，它是基于公有继承和私有继承的中间，如果你不想在外界被访问到，又想在派生类中被访问，这就可以用保护的形式来继承下来了，但基类的私有成员对象在保护的派生类中依然是私有成员对象。\n![继承的方式](C-Book/c-Book.png)\n**派生类不会自动的继承基类的构造函数**\n# 隐藏\n* 我们以后难免会在派生类里定义属于它自己的成员变量和成员函数，但当我们在声明和定义的时候有时也会不小心的把成员变量和成员函数与基类的成员变量和成员函数名字相同，这是我们的程序就会出现名字隐藏的现象，对于隐藏就是说当我们的派生类与基类中有名字相同的，就可能会出现隐藏。如果不知道什么时候被隐藏了什么，我们可以加上作用域去看看，在这里，我的建议是，尽量不要在继承类里面用同样的名字，不然你会很自闭的。\n* 基类的析构函数最好加上关键字（virtual）写成虚函数，这样在派生类的时候的就能自动调用，而对于，纯虚函数，在派生类中是要重写的性质，因为在基类的纯虚函数是空函数一个，它的本质就是一定要在派生类里面实现它的意义。一个良好的习惯：最好把基类的析构函数写成虚的，这样在派生类中是会自动调用的。\n\n**纯虚函数是不能对它进行实例化的，也就是说不能给它创建对象，这是要注意的重点，不能说你定义的是一个纯虚函数，然后你又在main函数里给它创建一个对象来进行一些操作。** \n\n\n**在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现(谁派生谁实现)。这部分的功能往往是基类不需要的，或者是在基类中实现不了的，虽然基类完成不了，但强制交给了派生类去实现，否则一样不能被实例化。** \n\n**抽象基类除了限制了派生类，也实现了多态(也就是说在main函数里，你可以使用基类来调用派生类里面重写的纯虚函数)。** \n\n# 抽象类\n* 其实就是在类里面把函数写成是纯虚函数，这样在派生类里就剩下重写这些虚函数。一般把抽象类用来设计一套统一的接口。\n![例子](C-Book/c-Book2.png)\n![例子](C-Book/c-Book1.png)\n![运行结果](C-Book/c-Book3.png)\n**重新认识了类的继承，这里我没有用到构造函数来给成员变量赋值，因为用了构造函数会变的很自闭，发正我是完全不能理解的那种，所以我用来另外一种方法，虽然算不上什么，但我觉得自己理解写出来的东西是可以的。孙悟空吃唐僧，这是多么厉害的，我想这个结果连孙悟空自己也不敢想的，我帮他实现了，嘻嘻。**\n* 这里的基类是不能被实例化的，因为基类里面的show方法，我用的是纯虚函数来写的，不能被实例化，但在派生类要实现，你不实现的话，你写这个虚函数就没意义了，基类的纯虚函数在派生类你一定要写进去，不要编译器会报错的，\n# 拷贝构造函数\n**在类中有指针又要多个类的对象的时候最好写一下类的拷贝构造函数**\n1. 在程序中的拷贝是浅拷贝，也就是说在类中只是简单的把普通类型的成员变量复制给另外一个类的对象。但在有引用或者有指针的类里面，如果我们没有声明另外的拷贝构造函数的话，我们的程序就会报错。\n2. 拷贝构造函数的形参必须是类的类型,该参数必须传引用,而且还要在前面使用const修饰符\n3. 使用拷贝构造函数在本类中要有指针变量或者多对象\n# 模板\n* 关键字 template \n```\n#include <iostream>\nusing namespace std;\ntemplate <typename T>\nT add (T a, T b){\n    return a+b;\n}\nint main(){\n    cout<<add(1,2)<<endl;;\n    cout<<add(10.1,10.2)<<endl;;\n}\n```\n运行结果:\n```\n3\n20.3\n```\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    double numb(55.55);\n    coutw<<numb<<endl;\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint)\n    cout.precision(1);\n    cout<<numb<<endl;\n}\n```\n运行结果：\n```\n55.55\n55.5\n```\n# 拷贝构造函数\n* test.h\n```\nclass Test{\n    string _name;\n    int _*age;\n    Test(string name,int age){\n        _name=name;\n        _age=new int (age);\n        cout<<\"有参构造函数\"<<endl;\n    }\n    void(){\n        cout<<_name<<\"的年龄\"<<_age<<endl;\n    }\n    //深拷贝构造函数\n    Test(const Test &t){//把类作为函数的参数\n        _name=t._name;\n        _age=new int (*t._age);//这里用的是指针来new,因为在本类中它就是以指针的方式来存放的，所以你也只能以指针的形式来启用它。\n        cout<<\"拷贝构造函数\"<<endl;\n    }\n    ~Test(){\n        delete age;\n        cout<<\"析构函数\"<<endl;\n    }\n}\n```\n* main\n```\n#include <iostream>\nusing space std;\nint main(){\n    Test t1(\"小明\",10);\n    t1.show();\n    //类的使用在这以上是没有问题的，这就是浅拷贝额构造函数\n    //当我们要在有指针(*)或者引用(&)的类中使用二次构造函数，那么我们就要写一个深的拷贝构造函数\n    Test t2(t1);//这个类的复制是要有深的拷贝构造函数来配合的。因为它符合条件\n    t2.show();\n}\n```\n* 程序运行结果\n```\n有参构造函数\n小明的年龄10\n拷贝构造函数\n小明的年龄10\n析构函数\n析构函数\n```\n**其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题,这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。**\n----\n# 类模板\n\n```\ntemplate <class T>//因为要使用模板，所以在定义模板\nclass Apple{\n  friend ostream &operator<<(ostream &out,Apple &a){//这里定义的是友元函数，用输出流来输出两个对象的相加\n      out<<a.c<<\"+\"<<a.n<<endl;\n      return out;\n  }\nprivate:\n    T c;//泛性的成员变量\n    T n;\n    Apple(T _a,T_b){//构造函数\n    this->c=_a;\n    this->n=_b;\n    }\n    Apple <int> operator+(Apple &a){//这里调用的是类的构造函数来实现两个对象的相加并把相应的数值存放在本类的成员变量中。\n    Apple addsum(this->c+a.c,this->n+a.n);\n    return addsum;\n    }\n\n}\n#include <iostream>\n#include \"Apple.h\"\nusing namespace std;\nint main(){\n     Apple <int>a(10,20); \n     Apple <int>a1(20,30);\n     Apple <int>c=a+a1;\n     cout<<c<<endl;\n}\n```\n```\n\n运行结果\n30+50\n```\n**注意事项** \n\n![模板类](C-Book/c-Book5.png) \n","source":"_posts/C-Book.md","raw":"---\ntitle: C++Book\ndate: 2019-06-12 14:31:03\ntags:\n---\n                      c++\n <!--more-->\n# C++Book\n# 库\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    cout<<hello would<<endl;\n    return 0;\n}\n```\n**在上面的代码我们应该都知道我什么都没有实现，这只是在简单的阐述一下c++库的重要性，也可以说是让我们更深刻的认识到有些代码的意思是什么。**\n\n* #include,using (预编译指令) \n* iostream (是c++标准库，方便使用cout,cin,) \n* using namespace std (是命名空间,std,因为在库里大多数都有std命名空间的部分，所以规定这些名称为std)\n# 结构函数\n* 关键字struct+结构名\n```\n#include <iostream>\nusing namespace std;\nstruct point{\n    int a=5;\n    int b=10;\n};\nint main(){\n    point *p=new point;    //在堆内存里new了内存\n    p->a=10;\n    p->b=5;\n    cout<<p1->a<<\"\\t\"<<p1-><<endl;\n    point p1,p2;              //在栈内存里实现,还把poit里的参数全部给p2使用\n    cout<<p1.a<<\"\\t\"<<p1.b<<endl;\n    cout<<p2.a<<\"\\t\"<<p2.b<<endl;\n}\n```\n运行结果：\n```\n5    10\n5    10\n5    10\n```\n**其实结构和类是相似的**\n\n----\n# 联合函数\n* 关键字union+名字\n```\n#include <iostream>\nusing namespace std;\nunion test{\n    int a;\n    char b;\n};\nint main(){\n    test *p=new test;         //在堆内存new了内存\n    p->a=97;\n    cout<<p->a<<\"的字符表示是：\"<<p->b<<endl;\n    test t1;                  //在栈内存里实现\n    t1.a=65;\n    cout<<t1.a<<\"的字符表示是：\"<<t.b<<endl;\n}\n```\n**一样的和类相似，在栈和堆内存一样使用,不相同的是：联合函数你可以给变量的其中一个赋值，而另外一个变量会自己把已经赋值的那个变量的值赋给自己。**\n\n----\n# 枚举函数\n* 关键字enum+名字\n```\n#include <iostream>\nusing namespace std;\nenum Arrow{\n    eroos,ok,warning,\n}\nint main(){\n    Arrow a1=eroos;\n    Arrow a2=ok;\n    Arrow a3=warning;\n    cout<<a1<<a2<<a3<<endl;\n}\n```\n运行结果：\n```\n0\n1\n2\n```\n**枚举的特点：它是以字符的形式声明的，但输出的确实整数型的数字**\n\n----\n# 排序\n**排序的方法有很多，但我们只要理解一种就可以了。我选择冒泡排序**\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    int arr[]={3,10,5,11,6}\n    for(int i=5-1;i>0;i--){\n        //把第一个数字设置为最大的数字来跟剩下的数字一起来比较，所以这的次数是总数来减一\n        for(int j=0;j<i;j++>){\n            //把每一次大的循环里的数组的大值都往后一个交换位置\n            if(arr[j]>arr[j+1]){//条件满足就交换位置\n                int temp;\n                temp=arr[j];\n                arr[j]=arr[j+1];\n                arr[j+1]=temp;\n            }\n        }\n    }\n    cout<<\"排序后\"<<endl;\n    for(int i=0;i<5;i++){\n        cout<<arr[i]<<endl;\n    }\n}\n```\n运行结果\n```\n排序后\n3\n5\n6\n10\n11\n```\n# 递归函数\n**递归函数:调用的时候是使用栈内存来实现的，函数一层一层的往下递归，递归的同时会把函数停住，而计算机会重复的把信息保存到栈内存里，遇到递归停止的条件时又会一层一层的往上走在信息停止的那一步，从而实现递归的真正意义。值得注意的是，递归是栈内存的实现，它把信息放在最底层上。每当计算机往上走的时候都是从最低下中读取信息的。栈是先出后入的内存结构。**\n* 通俗一点的意思就是在本函数里调用自身函数。\n```\n#include <iostream>\nusing namespace std;\nint add(int i){\n    cout<<\"函数开始:i=\"<<i<<endl;\n    if(i=5){\n        return i;\n    }else\n    {\n        add(++i);\n    }\n    cout<<\"函数结束,返回值为：\"<<i<<endl;\n    return i;\n}\nint main(){\n    cout<<add(1)<<endl;\n}\n```\n函数的结果：`\n```\n函数开始：i=1\n函数开始：i=2\n函数开始：i=3\n函数开始：i=4\n函数开始：i=5\n函数结束，返回值为：5\n函数结束，返回值为：4\n函数结束，返回值为：3\n函数结束，返回值为：2\n函数结束，返回值为：1\n```\n* 这里的先是返回的自身函数调用的结果，这里编译器里是有五个变量来暂时存储自身函数的值，每当执行到函数返回的时候编译器都会从暂时存储那里把值返回给我们，还有一种理解，就是这个函数里的变量在每次自身函数调用的时候都被隐藏起来了，也就是说每次的自身函数的调用它都有不同的存储位置来让变量重新赋值。其实，递归函数是在返回的时候才是这种函数真真的意义，因为自身函数的最后一次刚好是函数返回值的第一次。\n```\n//阶乘的实现\n#include <iostream>\nusing namespace std;\nint test(int test1){\n    int val;\n    if(test1==1){//递归的停止条件\n        val=1;\n        return val;\n    }else{\n        val=test1*test(test1-1);\n        return val;\n    }\n}\nint main(){\n    cout<<\"实现阶乘,请输入一个数字:\"<<endl;\n    int t1;\n    cin>>t1;\n    cout<<test(t1)<<endl;\n}\n```\n**强调一下，递归的停止条件的重要性，一旦递归没遇到停止的条件就会无穷的死循环，直到计算机的内存都跑完!!!**\n```\n#include <iostream>\nusing namespace std;\nint test(int t1,int t2){\n    if(t2==0){\n        return 1;//递归的停止条件,t2==0,就返回1\n    }else{\n        return test(t1,t2-1)*t1;//上面返回的值来当作第一次的值，然后一直往上计算\n    }\n}\nint main(){\n    cout<<test(3,2)<<endl;\n}\n```\n运行结果\n```\n9\n```\n**递归的三大条件**\n* (有返回值类型，无返回值类型)\n1. 没有无穷的递归\n2. 每一种停止的情况都执行(返回)那种情况下的正确操作\n3. 所有递归函数的调用都能正确的执行操作，那么最后的结果一定是正确的\n----\n# 函数与指针\n* 指向函数的指针\n```\n#include <iostream>\nusing namespace std;\nint add(int a){\n    return a;\n}\nint test(int a){\n    return a;\n}\nint main(){\n    int (*p)(int a)=&add;//指向函数的指针\n    cout<<P(5)<<endl;\n    int (*ip[])(int a)={&add,&test};//指向多个函数的指针数组\n    cout<<ip[0](1)<<ip[1](2)<<endl;\n}\n```\n函数的结果：\n```\n5\n1\n2\n```\n* 这里的指针都是储存在栈内存里的。\n----\n# 预处理\n* 格式化代码，去除多余的空格和注释\n* 进行一些宏替换\n* 包含另外一段代码\n* 通过一些条件的判断，动态决定是否编译某段代码\n1. 宏定义\n\n**在定义宏的时候记得不要在定义的后面加分号！！！**\n----\n```\n#include <iostream>\nusing namespace std;\n#define MAX 9               //宏定义\n#define MAN2 MAX*MAX        //宏定义\nint main(){\n    cout<<MAX<<endl;\n    cout<<MAX2<<endl;\n}\n```\n运行结果为：\n```\n9\n81\n```\n2. 带参数的宏定义\n```\n#include <iostream>\nusing namespace std;\n#define MAX 3                        //无参宏定义\n#define space(x) ((x)*(x))           //声明一个带参数的宏定义\nint main(){\n    for(int i=1;i<=MAX;i++){\n        cout<<i<<\"的平方是：\"<<space(i)<<endl;\n    }\n}\n```\n运行结果是：\n```\n1的平方是：1\n2的平方是：4\n3的平方是：9\n```\n```\n#include <iostream>\nusing namespace std;\n#define add(a,b)(a+b)           //带参的宏定义\n#define test(x) #x         //#是连接\n#define test1(a*,* b) a##b        //a和b是连接在一起的\nint main(){\n    string s1(\"hello,\");        //字符串\n    string s2(\"world!\");\n    cout<<add(100,100)<<endl;\n    cout<<add(s1,s2)<<endl;     //使用宏来实现字符串的相加\n    cout<<test(hello world)<<endl;\n    int ab=10;\n    cout<<test1(a,b)<<endl;//这里的ab是连接起来的，所以在前面定义了ab的值，也就是说这里输出的只是变量ab的值，并不是说把a和b当作实参过去的。\n}\n```\n运行结果是：\n```\n200\nhello,world\nhelloworld\n10\n```\n**说明了宏的优点有:避免了强类型的检测**\n----\n3. 宏与常量，函数\n宏与常量有点相似，但当他们遇上指针和引用之后又会变成什么呢？\n```\n#include <iostream>\nusing namespace std;\n#define x 10\nconst int y=5;\nint main(){\n    const int &a=x;          //ok\n    const int *p=&y;         //ok\n    cout<<a<<\"\\t\"<<*p<<endl;\n}\n```\n运行结果：\n```\n10    5\n```\n**这里给宏使用了引用，给常量使用了指针。还在定义的前面都加了const类型。**\n**但是在这里还是不希望使用引用和指针的方式来操作宏和常量,把宏看作是简单的文本替换，这也是宏的原本意义。**\n\n**宏不允许重新定义，也就是说一个相同的宏只能被定义一次，要想修改宏的值，你只能先消除它，使用#undef关键来消除，然后你就可以重新定义了。**\n4. 在c++中有还有内置的宏\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    cout<<__TIME__<<endl; //输出当前代码运行的时间\n    cout<<__DATE<<endl;   //输出当前代码运行的日期\n    cout<<__LINE<<endl;   //输出当前代码的所在行号\n    cout<<__FIME__<<endl; //输出当前代码的文件路径\n}\n```\n5. #if #elif #else  #ifdef #ifndef\n```\n#include <iostream>\nusing namespace std;\n#define a 10\nint main(){\n    #if a<20\n    cout<<\"欢迎使用测试版\"<<endl;\n    #else\n    cout<<\"欢迎使用正版\"<<endl;\n    #endif\n    return 0;\n}\n```\n运行的结果：\n```\n欢迎使用测试版\n```\n**#if类似与我们在以前代码里的if，#else类似与else,#elif类似elseif**\n**#endif,很重要。如果没有它你的程序是跑不起来的。**\n---\n**在c++中有很多预定义函数，这其中有一中是异常处理函数，关键字(try)** \n```\n#include <iostream>\nusing namespace std;\nint main(){\n     __try{\n      int i;\n      cout<<\"请输入一个数字\"<<end;\n      cin>>i;\n      if(i<=0){\n      throw \"error\"\n     }\n      }catch(const char *p){//指定抛出异常的类型\n         cout<<p<<endl;\n      }catch(...){\n      cout<<\"在main函数里有异常\"<<endl;//任何抛出异常的类型都能接受,这里虽然是可以接受任何类型的异常但在前面已经有指定的抛出类型，所以在这里输出的是指定的抛出类型\n      }\n}\n```\n---\n**e.what(是用来打印异常抛出的)** \n```\n运行结果\nerror\n```\n---\n![不同的类型抛出](C-Book/c-Book4.png)\n- [ ] bad_typeid:\n- [ ] bad_cast\n- [ ] bad_alloc:在new一个内存时，如果没有足够的空间时会抛出异常来，\n- [ ] ios_base::failure:上一个的异常抛出打印的类型\n- [ ] logic_error---out_of_range:这是数组下标越界会抛出(out_of_range)类型的异常来\n\n```\n#include <iostream>\nusing namespace std;\n#define a 10\nint main(){\n    #ifdef a\n    cout<<\"欢迎使用正版\"<<endl;\n    #endif\n    return 0;\n    #ifndef\n    cout<<\"欢迎使用测试版\"<<endl;\n    #endif\n    return 0;\n}\n```\n**值得注意的是，#ifdef和#ifndef都要有#endif使用，#endif的意思应该是结束if**\n\n----\n# 预定义字符函数\n**预定义字符函数就是把字符转换成大，小写的字符，在计算机中，我们虽然是以字符的形式输入到计算机中，但计算机本身的运作却是以数字的形式来使用的。值得注意的是，书上写的需要头文件但我这里是不需要头文件的，可能是版本的问题吧，如果有报错的话就加个头文件(cctype)**\n1. toupper()(把字符转换成大写的)\n2. tolower()(小写) \n3. isupper()(如果字符是大写的就为true，否则false)\n4. islower()(同上)\n5. isspace()(如果字符是空白字符就为true,否则false)，一般这个识别的都跟着cin.get()这个函数，因为它识别空格，你可以在它识别空格的时候输出一些东西，下面有个小列子。\n```\n#include <iostream>\nusing namespace std;\nvoid test(){\n    char a,b;\n    cout<<\"请输入字符\"<<endl;\n    cin>>b;\n    a=toupper(b)\n    cout<<c<<endl;\n    if(isupper(b)){//条件一开始为false\n        cout<<\"转换成功\\t\"<<a<<endl;\n    }else{\n        cout<<\"转换失败\"<<endl;\n    }\n}\nint main(){\n    test();\n    char c;\n    cout<<\"请输入字符\"<<endl;\n    do{\n        cin.get(c);//逐步输入字符\n        if(isspace(c)){//判断是否符合条件     空格\n            cout<<'--';\n        }else{\n            cout<<c<<endl;\n        }\n    }while(c!='.');\n    cin.get();//识别空格，是空格就打印下面的那句话\n    cout<<\"空格\"<<endl;\n}\n```\n运行结果\n```\n请输入字符\na\n转换成功   A\n请输入字符\nadd test\nadd--test--.\n```\n----\n# 类\n   **类的特征**\n   -----\n1. 类同时具有成员变量和成员函数。\n2. 成员可变成私有和共有\n3. 正常下类的成员变量是私有的\n4. 类的私有成员只能在本类的函数里面定义和调用\n5. 类的成员函数可以像普通的函数一样重载\n6. 一个类可将另外一个类作为自己的成员变量的类性使用\n7. 函数的i形参可以是类的类型\n8. 类可以是函数的返回值类型\n----\n**类的基本**\n* 所有的成员变量设为私有的\n* 用户程序员通过函数作为成员变量的接口来访问变量和完善的规定如何使用每一个公共成员函数\n* 任何辅助函数都设为私有的\n----\n* 以前的数据和操作的过程都不是独立的，而c++允许我们将一些数据和操作数据的过程放在同一个地方，并封装成一个独立的个体。\n* 万物皆对象，这句话对c++程序员来说并不陌生。这并不代表我们缺少对象，对于我们这种高质男来说从来没担心过搞不到对象，因为我们随时随地都可以new一个对象出来，这不是一般人可以做到的，只有真的走进来了才可以的，虽然这个操作在c++中也不算是什么高难度的操作，但我们又不是学到这里就完事的。类和结构是完全可以交换的，唯一不一样的是结构的默认特性是public,而类的默认特性是private。\n----\n1. 数据类型:由值的集合以及为那些值定义的一组基本运算构成 \n2. 抽像数据类型(ADT):使用数据类型的程序员访问不了值和运算的细节 \n* 封装，是用简单明了的公有函数的方式为外部程序提供对象操作接口。\n# 成员对象\n* 分为三种：public,private，protected\n1. 公有对象：不管是在类里还是在外部都能被访问到。\n2. 私有对象：只能在本类中访问到。\n3. 保护对象：只能在本类中访问到，在外部是访问不到的。\n# 运算符重载\n1. 重载运算符，至少要有一个参数的类型是类\n2. 重载的函数可以是类的友元函数也可以是成员函数\n3. 不能新建运算符\n4. 不能改变获取的形参操作符的意义\n5. 不能改变操作符的优先级\n6. 不能重载一下操作符(.(圆点)::(作用域)...)    \n```\nclass Son;//先声明Son类\nclass Bos{\nfriend int operator+(Bos bos,Son son);//友元函数，用来访问类的私有成员\nfriend ostream &operator<<(ostream &os,Bos bos);//友元函数，用来访问类的私有成员\nprivate:\n    int a=10;\n    int b=5;\n}\nclass Son{\nfriend int operator+(Bos bos,Son son);//友元函数，用来访问类的私有成员\nfriend ostream &operator<<(ostream &os,Bos bos);//友元函数，用来访问类的私有成员\nprivate:\n    int a=5;\n    int b=10;\n}\nint operator+(Bos bos,Son son){//运算符重载加号\n    int a=bos.a+bos.b;\n    int b=son.a+son.b;\n    return a,b;\n}\nostream &operator<<(ostream &os,Bos bos){//运算符重载<<号\n    os<<\"a=\"<<bos.a<<\"b=\"<<bos.b<<endl;//把成员变量连接在cout流中\n    return os;//返回cout，这样就能在main函数中直接打印\n}\nint main(){\n    Bos bos;\n    Son son\n    cout<<bos+son<<endl;//这要是没有重载加号，是运行不过的\n    cout<<bos<<endl;//没有重载<<也是运行不过来的\n}\n```\n**谨慎参考，纯属本人理解。ostream,是因为要用到cout流，因为输出流是属于ostream里面的，&,是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。**\n----\n# const mutable\n* 众所周知，const是常量类型。而mutable是可变的，就像是普通变量。\n# vector\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n    vector <int >a{10,20,3,5,1};\n    a.insert(a.begin(),8);//在向量最前面插入数字8\n    sort(a.begin(),a.end());//升序\n    vector <int >::iterator it;//打印\n    for(it=a.begin();it!=a.end();it++){\n        cout<<*it<<\"      \";\n    }\n    reverse(a.begin(),a.end());//逆序\n    for(it=a.begin();it!=a.end();it++){\n        cout<<*it<<\"      \";\n    }\n    a.clear();//清除向量\n    vector <int > b;\n    a.swap(b);\n    for(it=b.begin();it!=b.end();it++){\n        cout<<*it<<\"      \";\n    }\n```\n---\n```\n运行结果\n1    3    5   8   10   20\n20   10   8   5   3   1\n20   10   8   5   3   1\n```\n```\n# include <iostream>\nusing namespace std;\nint main (){\n      int numb[]={10,20,23,11,}\n      int numb1[4]={0};\n      memcpy(numb1,numb,sizeof(numb));\n      for(int i=0;i<4;i++){\n      cout<<numb1[i]<<'   ';\n      }\n}\n```\n---\n\n```\n运行结果\n10   20   23   11\n```\n---\n\n- [ ] **静态成员函数和静态成员变量**\n\n```\n#include <iostream>\nusing namespace std;\n\".h\"\n# include <iostream>\nclass Test{\n      private:\n      static int a;\n      int b;\n      public:\n      Test(int _a){\n      a=_a;\n      ++b;\n      }\n      static void show(Test tt){//静态成员函数中通过对象来引用非静态成员\n      cout<<\"tt.a=\"<tt.a<<endl;\n      cout<<\"Test::b=\"<<Test::b<<endl;\n      cout<<\"tt.b=\"<<tt.b<<endl;\n      }\n}\nint Test::b=0;//这是放在main函数上面的\nint main(){\n        Test t1(100);\n        Test t2(200);\n        Test::show(t1);\n        Test::show(t2);//静态成员函数调用时不用对象名 \n\n}\n```\n```\n运行结果为：\ntt.a=100\nTest::b=2\ntt.b=2\ntt.a=200\nTest::b=2\ntt.b=2\n```\n\n# 继承\n```\nclass Teacher{\n    string _name;\n    int _year;\n    Teacher(string name,int year){\n        this->_name=name;\n        this->_year=year;\n    }\n    void show(){\n        cout<<this->_name<<\"老师的年龄是：\"<<this->_year<<endl;\n    }\n}\nclass Student::puble Teacher{\npublic:\n       Student(string name,int year):Teacher(name,year){\n       }\n}\n```\n**上面的基类用的是构造函数来给自己赋初始化的，所以在派生类也要写上自己的构造函数才算继承基类。**\n\n```\nint main(){\n    Student s1(\"小明\",18);\n    s1.show();\n}\n```\n运行结果是：\n```\n小明的年龄是：18 \n```\n**这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。**\n----\n* 继承的方式有三种：public private protected\n公有继承, 私有继承, 保护继承\n1. 公有继承：是以公有的形式来继承的基类，这也就意味着在基类是什么类型的在派生类也是一样的关系。\n2. 私有继承：是以私有的形式来继承的基类,就是说继承下来的基类都是以私有的形式来继承的。\n3. 保护继承：是以保护的形式来继承的基类，它是基于公有继承和私有继承的中间，如果你不想在外界被访问到，又想在派生类中被访问，这就可以用保护的形式来继承下来了，但基类的私有成员对象在保护的派生类中依然是私有成员对象。\n![继承的方式](C-Book/c-Book.png)\n**派生类不会自动的继承基类的构造函数**\n# 隐藏\n* 我们以后难免会在派生类里定义属于它自己的成员变量和成员函数，但当我们在声明和定义的时候有时也会不小心的把成员变量和成员函数与基类的成员变量和成员函数名字相同，这是我们的程序就会出现名字隐藏的现象，对于隐藏就是说当我们的派生类与基类中有名字相同的，就可能会出现隐藏。如果不知道什么时候被隐藏了什么，我们可以加上作用域去看看，在这里，我的建议是，尽量不要在继承类里面用同样的名字，不然你会很自闭的。\n* 基类的析构函数最好加上关键字（virtual）写成虚函数，这样在派生类的时候的就能自动调用，而对于，纯虚函数，在派生类中是要重写的性质，因为在基类的纯虚函数是空函数一个，它的本质就是一定要在派生类里面实现它的意义。一个良好的习惯：最好把基类的析构函数写成虚的，这样在派生类中是会自动调用的。\n\n**纯虚函数是不能对它进行实例化的，也就是说不能给它创建对象，这是要注意的重点，不能说你定义的是一个纯虚函数，然后你又在main函数里给它创建一个对象来进行一些操作。** \n\n\n**在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现(谁派生谁实现)。这部分的功能往往是基类不需要的，或者是在基类中实现不了的，虽然基类完成不了，但强制交给了派生类去实现，否则一样不能被实例化。** \n\n**抽象基类除了限制了派生类，也实现了多态(也就是说在main函数里，你可以使用基类来调用派生类里面重写的纯虚函数)。** \n\n# 抽象类\n* 其实就是在类里面把函数写成是纯虚函数，这样在派生类里就剩下重写这些虚函数。一般把抽象类用来设计一套统一的接口。\n![例子](C-Book/c-Book2.png)\n![例子](C-Book/c-Book1.png)\n![运行结果](C-Book/c-Book3.png)\n**重新认识了类的继承，这里我没有用到构造函数来给成员变量赋值，因为用了构造函数会变的很自闭，发正我是完全不能理解的那种，所以我用来另外一种方法，虽然算不上什么，但我觉得自己理解写出来的东西是可以的。孙悟空吃唐僧，这是多么厉害的，我想这个结果连孙悟空自己也不敢想的，我帮他实现了，嘻嘻。**\n* 这里的基类是不能被实例化的，因为基类里面的show方法，我用的是纯虚函数来写的，不能被实例化，但在派生类要实现，你不实现的话，你写这个虚函数就没意义了，基类的纯虚函数在派生类你一定要写进去，不要编译器会报错的，\n# 拷贝构造函数\n**在类中有指针又要多个类的对象的时候最好写一下类的拷贝构造函数**\n1. 在程序中的拷贝是浅拷贝，也就是说在类中只是简单的把普通类型的成员变量复制给另外一个类的对象。但在有引用或者有指针的类里面，如果我们没有声明另外的拷贝构造函数的话，我们的程序就会报错。\n2. 拷贝构造函数的形参必须是类的类型,该参数必须传引用,而且还要在前面使用const修饰符\n3. 使用拷贝构造函数在本类中要有指针变量或者多对象\n# 模板\n* 关键字 template \n```\n#include <iostream>\nusing namespace std;\ntemplate <typename T>\nT add (T a, T b){\n    return a+b;\n}\nint main(){\n    cout<<add(1,2)<<endl;;\n    cout<<add(10.1,10.2)<<endl;;\n}\n```\n运行结果:\n```\n3\n20.3\n```\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    double numb(55.55);\n    coutw<<numb<<endl;\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint)\n    cout.precision(1);\n    cout<<numb<<endl;\n}\n```\n运行结果：\n```\n55.55\n55.5\n```\n# 拷贝构造函数\n* test.h\n```\nclass Test{\n    string _name;\n    int _*age;\n    Test(string name,int age){\n        _name=name;\n        _age=new int (age);\n        cout<<\"有参构造函数\"<<endl;\n    }\n    void(){\n        cout<<_name<<\"的年龄\"<<_age<<endl;\n    }\n    //深拷贝构造函数\n    Test(const Test &t){//把类作为函数的参数\n        _name=t._name;\n        _age=new int (*t._age);//这里用的是指针来new,因为在本类中它就是以指针的方式来存放的，所以你也只能以指针的形式来启用它。\n        cout<<\"拷贝构造函数\"<<endl;\n    }\n    ~Test(){\n        delete age;\n        cout<<\"析构函数\"<<endl;\n    }\n}\n```\n* main\n```\n#include <iostream>\nusing space std;\nint main(){\n    Test t1(\"小明\",10);\n    t1.show();\n    //类的使用在这以上是没有问题的，这就是浅拷贝额构造函数\n    //当我们要在有指针(*)或者引用(&)的类中使用二次构造函数，那么我们就要写一个深的拷贝构造函数\n    Test t2(t1);//这个类的复制是要有深的拷贝构造函数来配合的。因为它符合条件\n    t2.show();\n}\n```\n* 程序运行结果\n```\n有参构造函数\n小明的年龄10\n拷贝构造函数\n小明的年龄10\n析构函数\n析构函数\n```\n**其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题,这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。**\n----\n# 类模板\n\n```\ntemplate <class T>//因为要使用模板，所以在定义模板\nclass Apple{\n  friend ostream &operator<<(ostream &out,Apple &a){//这里定义的是友元函数，用输出流来输出两个对象的相加\n      out<<a.c<<\"+\"<<a.n<<endl;\n      return out;\n  }\nprivate:\n    T c;//泛性的成员变量\n    T n;\n    Apple(T _a,T_b){//构造函数\n    this->c=_a;\n    this->n=_b;\n    }\n    Apple <int> operator+(Apple &a){//这里调用的是类的构造函数来实现两个对象的相加并把相应的数值存放在本类的成员变量中。\n    Apple addsum(this->c+a.c,this->n+a.n);\n    return addsum;\n    }\n\n}\n#include <iostream>\n#include \"Apple.h\"\nusing namespace std;\nint main(){\n     Apple <int>a(10,20); \n     Apple <int>a1(20,30);\n     Apple <int>c=a+a1;\n     cout<<c<<endl;\n}\n```\n```\n\n运行结果\n30+50\n```\n**注意事项** \n\n![模板类](C-Book/c-Book5.png) \n","slug":"C-Book","published":1,"updated":"2019-08-20T12:46:37.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7qr00034ez7f20u8yej","content":"<pre><code>c++\n</code></pre> <a id=\"more\"></a>\n<h1 id=\"C-Book\"><a href=\"#C-Book\" class=\"headerlink\" title=\"C++Book\"></a>C++Book</h1><h1 id=\"库\"><a href=\"#库\" class=\"headerlink\" title=\"库\"></a>库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;hello would&lt;&lt;endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在上面的代码我们应该都知道我什么都没有实现，这只是在简单的阐述一下c++库的重要性，也可以说是让我们更深刻的认识到有些代码的意思是什么。</strong></p>\n<ul>\n<li>#include,using (预编译指令) </li>\n<li>iostream (是c++标准库，方便使用cout,cin,) </li>\n<li>using namespace std (是命名空间,std,因为在库里大多数都有std命名空间的部分，所以规定这些名称为std)<h1 id=\"结构函数\"><a href=\"#结构函数\" class=\"headerlink\" title=\"结构函数\"></a>结构函数</h1></li>\n<li>关键字struct+结构名<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">struct point&#123;</span><br><span class=\"line\">    int a=5;</span><br><span class=\"line\">    int b=10;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    point *p=new point;    //在堆内存里new了内存</span><br><span class=\"line\">    p-&gt;a=10;</span><br><span class=\"line\">    p-&gt;b=5;</span><br><span class=\"line\">    cout&lt;&lt;p1-&gt;a&lt;&lt;&quot;\\t&quot;&lt;&lt;p1-&gt;&lt;&lt;endl;</span><br><span class=\"line\">    point p1,p2;              //在栈内存里实现,还把poit里的参数全部给p2使用</span><br><span class=\"line\">    cout&lt;&lt;p1.a&lt;&lt;&quot;\\t&quot;&lt;&lt;p1.b&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;p2.a&lt;&lt;&quot;\\t&quot;&lt;&lt;p2.b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5    10</span><br><span class=\"line\">5    10</span><br><span class=\"line\">5    10</span><br></pre></td></tr></table></figure></p>\n<p><strong>其实结构和类是相似的</strong></p>\n<hr>\n<h1 id=\"联合函数\"><a href=\"#联合函数\" class=\"headerlink\" title=\"联合函数\"></a>联合函数</h1><ul>\n<li>关键字union+名字<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">union test&#123;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    char b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test *p=new test;         //在堆内存new了内存</span><br><span class=\"line\">    p-&gt;a=97;</span><br><span class=\"line\">    cout&lt;&lt;p-&gt;a&lt;&lt;&quot;的字符表示是：&quot;&lt;&lt;p-&gt;b&lt;&lt;endl;</span><br><span class=\"line\">    test t1;                  //在栈内存里实现</span><br><span class=\"line\">    t1.a=65;</span><br><span class=\"line\">    cout&lt;&lt;t1.a&lt;&lt;&quot;的字符表示是：&quot;&lt;&lt;t.b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>一样的和类相似，在栈和堆内存一样使用,不相同的是：联合函数你可以给变量的其中一个赋值，而另外一个变量会自己把已经赋值的那个变量的值赋给自己。</strong></p>\n<hr>\n<h1 id=\"枚举函数\"><a href=\"#枚举函数\" class=\"headerlink\" title=\"枚举函数\"></a>枚举函数</h1><ul>\n<li>关键字enum+名字<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">enum Arrow&#123;</span><br><span class=\"line\">    eroos,ok,warning,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Arrow a1=eroos;</span><br><span class=\"line\">    Arrow a2=ok;</span><br><span class=\"line\">    Arrow a3=warning;</span><br><span class=\"line\">    cout&lt;&lt;a1&lt;&lt;a2&lt;&lt;a3&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<p><strong>枚举的特点：它是以字符的形式声明的，但输出的确实整数型的数字</strong></p>\n<hr>\n<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><p><strong>排序的方法有很多，但我们只要理解一种就可以了。我选择冒泡排序</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int arr[]=&#123;3,10,5,11,6&#125;</span><br><span class=\"line\">    for(int i=5-1;i&gt;0;i--)&#123;</span><br><span class=\"line\">        //把第一个数字设置为最大的数字来跟剩下的数字一起来比较，所以这的次数是总数来减一</span><br><span class=\"line\">        for(int j=0;j&lt;i;j++&gt;)&#123;</span><br><span class=\"line\">            //把每一次大的循环里的数组的大值都往后一个交换位置</span><br><span class=\"line\">            if(arr[j]&gt;arr[j+1])&#123;//条件满足就交换位置</span><br><span class=\"line\">                int temp;</span><br><span class=\"line\">                temp=arr[j];</span><br><span class=\"line\">                arr[j]=arr[j+1];</span><br><span class=\"line\">                arr[j+1]=temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;&quot;排序后&quot;&lt;&lt;endl;</span><br><span class=\"line\">    for(int i=0;i&lt;5;i++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">排序后</span><br><span class=\"line\">3</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h1><p><strong>递归函数:调用的时候是使用栈内存来实现的，函数一层一层的往下递归，递归的同时会把函数停住，而计算机会重复的把信息保存到栈内存里，遇到递归停止的条件时又会一层一层的往上走在信息停止的那一步，从而实现递归的真正意义。值得注意的是，递归是栈内存的实现，它把信息放在最底层上。每当计算机往上走的时候都是从最低下中读取信息的。栈是先出后入的内存结构。</strong></p>\n<ul>\n<li>通俗一点的意思就是在本函数里调用自身函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int add(int i)&#123;</span><br><span class=\"line\">    cout&lt;&lt;&quot;函数开始:i=&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    if(i=5)&#123;</span><br><span class=\"line\">        return i;</span><br><span class=\"line\">    &#125;else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        add(++i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;&quot;函数结束,返回值为：&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    return i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;add(1)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>函数的结果：`<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数开始：i=1</span><br><span class=\"line\">函数开始：i=2</span><br><span class=\"line\">函数开始：i=3</span><br><span class=\"line\">函数开始：i=4</span><br><span class=\"line\">函数开始：i=5</span><br><span class=\"line\">函数结束，返回值为：5</span><br><span class=\"line\">函数结束，返回值为：4</span><br><span class=\"line\">函数结束，返回值为：3</span><br><span class=\"line\">函数结束，返回值为：2</span><br><span class=\"line\">函数结束，返回值为：1</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>这里的先是返回的自身函数调用的结果，这里编译器里是有五个变量来暂时存储自身函数的值，每当执行到函数返回的时候编译器都会从暂时存储那里把值返回给我们，还有一种理解，就是这个函数里的变量在每次自身函数调用的时候都被隐藏起来了，也就是说每次的自身函数的调用它都有不同的存储位置来让变量重新赋值。其实，递归函数是在返回的时候才是这种函数真真的意义，因为自身函数的最后一次刚好是函数返回值的第一次。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//阶乘的实现</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int test(int test1)&#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    if(test1==1)&#123;//递归的停止条件</span><br><span class=\"line\">        val=1;</span><br><span class=\"line\">        return val;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        val=test1*test(test1-1);</span><br><span class=\"line\">        return val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;&quot;实现阶乘,请输入一个数字:&quot;&lt;&lt;endl;</span><br><span class=\"line\">    int t1;</span><br><span class=\"line\">    cin&gt;&gt;t1;</span><br><span class=\"line\">    cout&lt;&lt;test(t1)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>强调一下，递归的停止条件的重要性，一旦递归没遇到停止的条件就会无穷的死循环，直到计算机的内存都跑完!!!</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int test(int t1,int t2)&#123;</span><br><span class=\"line\">    if(t2==0)&#123;</span><br><span class=\"line\">        return 1;//递归的停止条件,t2==0,就返回1</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return test(t1,t2-1)*t1;//上面返回的值来当作第一次的值，然后一直往上计算</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;test(3,2)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br></pre></td></tr></table></figure></p>\n<p><strong>递归的三大条件</strong></p>\n<ul>\n<li>(有返回值类型，无返回值类型)</li>\n</ul>\n<ol>\n<li>没有无穷的递归</li>\n<li>每一种停止的情况都执行(返回)那种情况下的正确操作</li>\n<li>所有递归函数的调用都能正确的执行操作，那么最后的结果一定是正确的</li>\n</ol>\n<hr>\n<h1 id=\"函数与指针\"><a href=\"#函数与指针\" class=\"headerlink\" title=\"函数与指针\"></a>函数与指针</h1><ul>\n<li>指向函数的指针<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int test(int a)&#123;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int (*p)(int a)=&amp;add;//指向函数的指针</span><br><span class=\"line\">    cout&lt;&lt;P(5)&lt;&lt;endl;</span><br><span class=\"line\">    int (*ip[])(int a)=&#123;&amp;add,&amp;test&#125;;//指向多个函数的指针数组</span><br><span class=\"line\">    cout&lt;&lt;ip[0](1)&lt;&lt;ip[1](2)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>函数的结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>这里的指针都是储存在栈内存里的。</li>\n</ul>\n<hr>\n<h1 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h1><ul>\n<li>格式化代码，去除多余的空格和注释</li>\n<li>进行一些宏替换</li>\n<li>包含另外一段代码</li>\n<li>通过一些条件的判断，动态决定是否编译某段代码</li>\n</ul>\n<ol>\n<li>宏定义</li>\n</ol>\n<h2 id=\"在定义宏的时候记得不要在定义的后面加分号！！！\"><a href=\"#在定义宏的时候记得不要在定义的后面加分号！！！\" class=\"headerlink\" title=\"在定义宏的时候记得不要在定义的后面加分号！！！\"></a><strong>在定义宏的时候记得不要在定义的后面加分号！！！</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define MAX 9               //宏定义</span><br><span class=\"line\">#define MAN2 MAX*MAX        //宏定义</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;MAX&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;MAX2&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br><span class=\"line\">81</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>带参数的宏定义<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define MAX 3                        //无参宏定义</span><br><span class=\"line\">#define space(x) ((x)*(x))           //声明一个带参数的宏定义</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    for(int i=1;i&lt;=MAX;i++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;i&lt;&lt;&quot;的平方是：&quot;&lt;&lt;space(i)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行结果是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1的平方是：1</span><br><span class=\"line\">2的平方是：4</span><br><span class=\"line\">3的平方是：9</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define add(a,b)(a+b)           //带参的宏定义</span><br><span class=\"line\">#define test(x) #x         //#是连接</span><br><span class=\"line\">#define test1(a*,* b) a##b        //a和b是连接在一起的</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    string s1(&quot;hello,&quot;);        //字符串</span><br><span class=\"line\">    string s2(&quot;world!&quot;);</span><br><span class=\"line\">    cout&lt;&lt;add(100,100)&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;add(s1,s2)&lt;&lt;endl;     //使用宏来实现字符串的相加</span><br><span class=\"line\">    cout&lt;&lt;test(hello world)&lt;&lt;endl;</span><br><span class=\"line\">    int ab=10;</span><br><span class=\"line\">    cout&lt;&lt;test1(a,b)&lt;&lt;endl;//这里的ab是连接起来的，所以在前面定义了ab的值，也就是说这里输出的只是变量ab的值，并不是说把a和b当作实参过去的。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200</span><br><span class=\"line\">hello,world</span><br><span class=\"line\">helloworld</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"说明了宏的优点有-避免了强类型的检测\"><a href=\"#说明了宏的优点有-避免了强类型的检测\" class=\"headerlink\" title=\"说明了宏的优点有:避免了强类型的检测\"></a><strong>说明了宏的优点有:避免了强类型的检测</strong></h2><ol start=\"3\">\n<li>宏与常量，函数<br>宏与常量有点相似，但当他们遇上指针和引用之后又会变成什么呢？<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define x 10</span><br><span class=\"line\">const int y=5;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    const int &amp;a=x;          //ok</span><br><span class=\"line\">    const int *p=&amp;y;         //ok</span><br><span class=\"line\">    cout&lt;&lt;a&lt;&lt;&quot;\\t&quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10    5</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里给宏使用了引用，给常量使用了指针。还在定义的前面都加了const类型。</strong><br><strong>但是在这里还是不希望使用引用和指针的方式来操作宏和常量,把宏看作是简单的文本替换，这也是宏的原本意义。</strong></p>\n<p><strong>宏不允许重新定义，也就是说一个相同的宏只能被定义一次，要想修改宏的值，你只能先消除它，使用#undef关键来消除，然后你就可以重新定义了。</strong></p>\n<ol start=\"4\">\n<li><p>在c++中有还有内置的宏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;__TIME__&lt;&lt;endl; //输出当前代码运行的时间</span><br><span class=\"line\">    cout&lt;&lt;__DATE&lt;&lt;endl;   //输出当前代码运行的日期</span><br><span class=\"line\">    cout&lt;&lt;__LINE&lt;&lt;endl;   //输出当前代码的所在行号</span><br><span class=\"line\">    cout&lt;&lt;__FIME__&lt;&lt;endl; //输出当前代码的文件路径</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>#if #elif #else  #ifdef #ifndef</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define a 10</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    #if a&lt;20</span><br><span class=\"line\">    cout&lt;&lt;&quot;欢迎使用测试版&quot;&lt;&lt;endl;</span><br><span class=\"line\">    #else</span><br><span class=\"line\">    cout&lt;&lt;&quot;欢迎使用正版&quot;&lt;&lt;endl;</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行的结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">欢迎使用测试版</span><br></pre></td></tr></table></figure></p>\n<p><strong>#if类似与我们在以前代码里的if，#else类似与else,#elif类似elseif</strong></p>\n<h2 id=\"endif-很重要。如果没有它你的程序是跑不起来的。\"><a href=\"#endif-很重要。如果没有它你的程序是跑不起来的。\" class=\"headerlink\" title=\"#endif,很重要。如果没有它你的程序是跑不起来的。\"></a><strong>#endif,很重要。如果没有它你的程序是跑不起来的。</strong></h2><p><strong>在c++中有很多预定义函数，这其中有一中是异常处理函数，关键字(try)</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">     __try&#123;</span><br><span class=\"line\">      int i;</span><br><span class=\"line\">      cout&lt;&lt;&quot;请输入一个数字&quot;&lt;&lt;end;</span><br><span class=\"line\">      cin&gt;&gt;i;</span><br><span class=\"line\">      if(i&lt;=0)&#123;</span><br><span class=\"line\">      throw &quot;error&quot;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">      &#125;catch(const char *p)&#123;//指定抛出异常的类型</span><br><span class=\"line\">         cout&lt;&lt;p&lt;&lt;endl;</span><br><span class=\"line\">      &#125;catch(...)&#123;</span><br><span class=\"line\">      cout&lt;&lt;&quot;在main函数里有异常&quot;&lt;&lt;endl;//任何抛出异常的类型都能接受,这里虽然是可以接受任何类型的异常但在前面已经有指定的抛出类型，所以在这里输出的是指定的抛出类型</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>e.what(是用来打印异常抛出的)</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">error</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><img src=\"/2019/06/12/C-Book/c-Book4.png\" alt=\"不同的类型抛出\"></p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> bad_typeid:</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> bad_cast</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> bad_alloc:在new一个内存时，如果没有足够的空间时会抛出异常来，</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> ios_base::failure:上一个的异常抛出打印的类型</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> logic_error—out_of_range:这是数组下标越界会抛出(out_of_range)类型的异常来</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define a 10</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    #ifdef a</span><br><span class=\"line\">    cout&lt;&lt;&quot;欢迎使用正版&quot;&lt;&lt;endl;</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">    #ifndef</span><br><span class=\"line\">    cout&lt;&lt;&quot;欢迎使用测试版&quot;&lt;&lt;endl;</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>值得注意的是，#ifdef和#ifndef都要有#endif使用，#endif的意思应该是结束if</strong></p>\n<hr>\n<h1 id=\"预定义字符函数\"><a href=\"#预定义字符函数\" class=\"headerlink\" title=\"预定义字符函数\"></a>预定义字符函数</h1><p><strong>预定义字符函数就是把字符转换成大，小写的字符，在计算机中，我们虽然是以字符的形式输入到计算机中，但计算机本身的运作却是以数字的形式来使用的。值得注意的是，书上写的需要头文件但我这里是不需要头文件的，可能是版本的问题吧，如果有报错的话就加个头文件(cctype)</strong></p>\n<ol>\n<li>toupper()(把字符转换成大写的)</li>\n<li>tolower()(小写) </li>\n<li>isupper()(如果字符是大写的就为true，否则false)</li>\n<li>islower()(同上)</li>\n<li>isspace()(如果字符是空白字符就为true,否则false)，一般这个识别的都跟着cin.get()这个函数，因为它识别空格，你可以在它识别空格的时候输出一些东西，下面有个小列子。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">void test()&#123;</span><br><span class=\"line\">    char a,b;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入字符&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;b;</span><br><span class=\"line\">    a=toupper(b)</span><br><span class=\"line\">    cout&lt;&lt;c&lt;&lt;endl;</span><br><span class=\"line\">    if(isupper(b))&#123;//条件一开始为false</span><br><span class=\"line\">        cout&lt;&lt;&quot;转换成功\\t&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;转换失败&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test();</span><br><span class=\"line\">    char c;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入字符&quot;&lt;&lt;endl;</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">        cin.get(c);//逐步输入字符</span><br><span class=\"line\">        if(isspace(c))&#123;//判断是否符合条件     空格</span><br><span class=\"line\">            cout&lt;&lt;&apos;--&apos;;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            cout&lt;&lt;c&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;while(c!=&apos;.&apos;);</span><br><span class=\"line\">    cin.get();//识别空格，是空格就打印下面的那句话</span><br><span class=\"line\">    cout&lt;&lt;&quot;空格&quot;&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入字符</span><br><span class=\"line\">a</span><br><span class=\"line\">转换成功   A</span><br><span class=\"line\">请输入字符</span><br><span class=\"line\">add test</span><br><span class=\"line\">add--test--.</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"类的特征\"><a href=\"#类的特征\" class=\"headerlink\" title=\"   类的特征\"></a>   <strong>类的特征</strong></h2><ol>\n<li>类同时具有成员变量和成员函数。</li>\n<li>成员可变成私有和共有</li>\n<li>正常下类的成员变量是私有的</li>\n<li>类的私有成员只能在本类的函数里面定义和调用</li>\n<li>类的成员函数可以像普通的函数一样重载</li>\n<li>一个类可将另外一个类作为自己的成员变量的类性使用</li>\n<li>函数的i形参可以是类的类型</li>\n<li>类可以是函数的返回值类型</li>\n</ol>\n<hr>\n<p><strong>类的基本</strong></p>\n<ul>\n<li>所有的成员变量设为私有的</li>\n<li>用户程序员通过函数作为成员变量的接口来访问变量和完善的规定如何使用每一个公共成员函数</li>\n<li>任何辅助函数都设为私有的</li>\n</ul>\n<hr>\n<ul>\n<li>以前的数据和操作的过程都不是独立的，而c++允许我们将一些数据和操作数据的过程放在同一个地方，并封装成一个独立的个体。</li>\n<li>万物皆对象，这句话对c++程序员来说并不陌生。这并不代表我们缺少对象，对于我们这种高质男来说从来没担心过搞不到对象，因为我们随时随地都可以new一个对象出来，这不是一般人可以做到的，只有真的走进来了才可以的，虽然这个操作在c++中也不算是什么高难度的操作，但我们又不是学到这里就完事的。类和结构是完全可以交换的，唯一不一样的是结构的默认特性是public,而类的默认特性是private。</li>\n</ul>\n<hr>\n<ol>\n<li>数据类型:由值的集合以及为那些值定义的一组基本运算构成 </li>\n<li>抽像数据类型(ADT):使用数据类型的程序员访问不了值和运算的细节 </li>\n</ol>\n<ul>\n<li>封装，是用简单明了的公有函数的方式为外部程序提供对象操作接口。<h1 id=\"成员对象\"><a href=\"#成员对象\" class=\"headerlink\" title=\"成员对象\"></a>成员对象</h1></li>\n<li>分为三种：public,private，protected</li>\n</ul>\n<ol>\n<li>公有对象：不管是在类里还是在外部都能被访问到。</li>\n<li>私有对象：只能在本类中访问到。</li>\n<li>保护对象：只能在本类中访问到，在外部是访问不到的。<h1 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h1></li>\n<li>重载运算符，至少要有一个参数的类型是类</li>\n<li>重载的函数可以是类的友元函数也可以是成员函数</li>\n<li>不能新建运算符</li>\n<li>不能改变获取的形参操作符的意义</li>\n<li>不能改变操作符的优先级</li>\n<li>不能重载一下操作符(.(圆点)::(作用域)…)    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Son;//先声明Son类</span><br><span class=\"line\">class Bos&#123;</span><br><span class=\"line\">friend int operator+(Bos bos,Son son);//友元函数，用来访问类的私有成员</span><br><span class=\"line\">friend ostream &amp;operator&lt;&lt;(ostream &amp;os,Bos bos);//友元函数，用来访问类的私有成员</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int a=10;</span><br><span class=\"line\">    int b=5;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Son&#123;</span><br><span class=\"line\">friend int operator+(Bos bos,Son son);//友元函数，用来访问类的私有成员</span><br><span class=\"line\">friend ostream &amp;operator&lt;&lt;(ostream &amp;os,Bos bos);//友元函数，用来访问类的私有成员</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int a=5;</span><br><span class=\"line\">    int b=10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int operator+(Bos bos,Son son)&#123;//运算符重载加号</span><br><span class=\"line\">    int a=bos.a+bos.b;</span><br><span class=\"line\">    int b=son.a+son.b;</span><br><span class=\"line\">    return a,b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ostream &amp;operator&lt;&lt;(ostream &amp;os,Bos bos)&#123;//运算符重载&lt;&lt;号</span><br><span class=\"line\">    os&lt;&lt;&quot;a=&quot;&lt;&lt;bos.a&lt;&lt;&quot;b=&quot;&lt;&lt;bos.b&lt;&lt;endl;//把成员变量连接在cout流中</span><br><span class=\"line\">    return os;//返回cout，这样就能在main函数中直接打印</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Bos bos;</span><br><span class=\"line\">    Son son</span><br><span class=\"line\">    cout&lt;&lt;bos+son&lt;&lt;endl;//这要是没有重载加号，是运行不过的</span><br><span class=\"line\">    cout&lt;&lt;bos&lt;&lt;endl;//没有重载&lt;&lt;也是运行不过来的</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"谨慎参考，纯属本人理解。ostream-是因为要用到cout流，因为输出流是属于ostream里面的，-amp-是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。\"><a href=\"#谨慎参考，纯属本人理解。ostream-是因为要用到cout流，因为输出流是属于ostream里面的，-amp-是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。\" class=\"headerlink\" title=\"谨慎参考，纯属本人理解。ostream,是因为要用到cout流，因为输出流是属于ostream里面的，&amp;,是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。\"></a><strong>谨慎参考，纯属本人理解。ostream,是因为要用到cout流，因为输出流是属于ostream里面的，&amp;,是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。</strong></h2><h1 id=\"const-mutable\"><a href=\"#const-mutable\" class=\"headerlink\" title=\"const mutable\"></a>const mutable</h1><ul>\n<li>众所周知，const是常量类型。而mutable是可变的，就像是普通变量。<h1 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    vector &lt;int &gt;a&#123;10,20,3,5,1&#125;;</span><br><span class=\"line\">    a.insert(a.begin(),8);//在向量最前面插入数字8</span><br><span class=\"line\">    sort(a.begin(),a.end());//升序</span><br><span class=\"line\">    vector &lt;int &gt;::iterator it;//打印</span><br><span class=\"line\">    for(it=a.begin();it!=a.end();it++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;*it&lt;&lt;&quot;      &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reverse(a.begin(),a.end());//逆序</span><br><span class=\"line\">    for(it=a.begin();it!=a.end();it++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;*it&lt;&lt;&quot;      &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a.clear();//清除向量</span><br><span class=\"line\">    vector &lt;int &gt; b;</span><br><span class=\"line\">    a.swap(b);</span><br><span class=\"line\">    for(it=b.begin();it!=b.end();it++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;*it&lt;&lt;&quot;      &quot;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">1    3    5   8   10   20</span><br><span class=\"line\">20   10   8   5   3   1</span><br><span class=\"line\">20   10   8   5   3   1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main ()&#123;</span><br><span class=\"line\">      int numb[]=&#123;10,20,23,11,&#125;</span><br><span class=\"line\">      int numb1[4]=&#123;0&#125;;</span><br><span class=\"line\">      memcpy(numb1,numb,sizeof(numb));</span><br><span class=\"line\">      for(int i=0;i&lt;4;i++)&#123;</span><br><span class=\"line\">      cout&lt;&lt;numb1[i]&lt;&lt;&apos;   &apos;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">10   20   23   11</span><br></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> <strong>静态成员函数和静态成员变量</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">&quot;.h&quot;</span><br><span class=\"line\"># include &lt;iostream&gt;</span><br><span class=\"line\">class Test&#123;</span><br><span class=\"line\">      private:</span><br><span class=\"line\">      static int a;</span><br><span class=\"line\">      int b;</span><br><span class=\"line\">      public:</span><br><span class=\"line\">      Test(int _a)&#123;</span><br><span class=\"line\">      a=_a;</span><br><span class=\"line\">      ++b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      static void show(Test tt)&#123;//静态成员函数中通过对象来引用非静态成员</span><br><span class=\"line\">      cout&lt;&lt;&quot;tt.a=&quot;&lt;tt.a&lt;&lt;endl;</span><br><span class=\"line\">      cout&lt;&lt;&quot;Test::b=&quot;&lt;&lt;Test::b&lt;&lt;endl;</span><br><span class=\"line\">      cout&lt;&lt;&quot;tt.b=&quot;&lt;&lt;tt.b&lt;&lt;endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int Test::b=0;//这是放在main函数上面的</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">        Test t1(100);</span><br><span class=\"line\">        Test t2(200);</span><br><span class=\"line\">        Test::show(t1);</span><br><span class=\"line\">        Test::show(t2);//静态成员函数调用时不用对象名 </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果为：</span><br><span class=\"line\">tt.a=100</span><br><span class=\"line\">Test::b=2</span><br><span class=\"line\">tt.b=2</span><br><span class=\"line\">tt.a=200</span><br><span class=\"line\">Test::b=2</span><br><span class=\"line\">tt.b=2</span><br></pre></td></tr></table></figure>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">    string _name;</span><br><span class=\"line\">    int _year;</span><br><span class=\"line\">    Teacher(string name,int year)&#123;</span><br><span class=\"line\">        this-&gt;_name=name;</span><br><span class=\"line\">        this-&gt;_year=year;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void show()&#123;</span><br><span class=\"line\">        cout&lt;&lt;this-&gt;_name&lt;&lt;&quot;老师的年龄是：&quot;&lt;&lt;this-&gt;_year&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Student::puble Teacher&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">       Student(string name,int year):Teacher(name,year)&#123;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>上面的基类用的是构造函数来给自己赋初始化的，所以在派生类也要写上自己的构造函数才算继承基类。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Student s1(&quot;小明&quot;,18);</span><br><span class=\"line\">    s1.show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">小明的年龄是：18</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。\"><a href=\"#这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。\" class=\"headerlink\" title=\"这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。\"></a><strong>这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。</strong></h2><ul>\n<li>继承的方式有三种：public private protected<br>公有继承, 私有继承, 保护继承</li>\n</ul>\n<ol>\n<li>公有继承：是以公有的形式来继承的基类，这也就意味着在基类是什么类型的在派生类也是一样的关系。</li>\n<li>私有继承：是以私有的形式来继承的基类,就是说继承下来的基类都是以私有的形式来继承的。</li>\n<li>保护继承：是以保护的形式来继承的基类，它是基于公有继承和私有继承的中间，如果你不想在外界被访问到，又想在派生类中被访问，这就可以用保护的形式来继承下来了，但基类的私有成员对象在保护的派生类中依然是私有成员对象。<br><img src=\"/2019/06/12/C-Book/c-Book.png\" alt=\"继承的方式\"><br><strong>派生类不会自动的继承基类的构造函数</strong><h1 id=\"隐藏\"><a href=\"#隐藏\" class=\"headerlink\" title=\"隐藏\"></a>隐藏</h1></li>\n</ol>\n<ul>\n<li>我们以后难免会在派生类里定义属于它自己的成员变量和成员函数，但当我们在声明和定义的时候有时也会不小心的把成员变量和成员函数与基类的成员变量和成员函数名字相同，这是我们的程序就会出现名字隐藏的现象，对于隐藏就是说当我们的派生类与基类中有名字相同的，就可能会出现隐藏。如果不知道什么时候被隐藏了什么，我们可以加上作用域去看看，在这里，我的建议是，尽量不要在继承类里面用同样的名字，不然你会很自闭的。</li>\n<li>基类的析构函数最好加上关键字（virtual）写成虚函数，这样在派生类的时候的就能自动调用，而对于，纯虚函数，在派生类中是要重写的性质，因为在基类的纯虚函数是空函数一个，它的本质就是一定要在派生类里面实现它的意义。一个良好的习惯：最好把基类的析构函数写成虚的，这样在派生类中是会自动调用的。</li>\n</ul>\n<p><strong>纯虚函数是不能对它进行实例化的，也就是说不能给它创建对象，这是要注意的重点，不能说你定义的是一个纯虚函数，然后你又在main函数里给它创建一个对象来进行一些操作。</strong> </p>\n<p><strong>在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现(谁派生谁实现)。这部分的功能往往是基类不需要的，或者是在基类中实现不了的，虽然基类完成不了，但强制交给了派生类去实现，否则一样不能被实例化。</strong> </p>\n<p><strong>抽象基类除了限制了派生类，也实现了多态(也就是说在main函数里，你可以使用基类来调用派生类里面重写的纯虚函数)。</strong> </p>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h1><ul>\n<li>其实就是在类里面把函数写成是纯虚函数，这样在派生类里就剩下重写这些虚函数。一般把抽象类用来设计一套统一的接口。<br><img src=\"/2019/06/12/C-Book/c-Book2.png\" alt=\"例子\"><br><img src=\"/2019/06/12/C-Book/c-Book1.png\" alt=\"例子\"><br><img src=\"/2019/06/12/C-Book/c-Book3.png\" alt=\"运行结果\"><br><strong>重新认识了类的继承，这里我没有用到构造函数来给成员变量赋值，因为用了构造函数会变的很自闭，发正我是完全不能理解的那种，所以我用来另外一种方法，虽然算不上什么，但我觉得自己理解写出来的东西是可以的。孙悟空吃唐僧，这是多么厉害的，我想这个结果连孙悟空自己也不敢想的，我帮他实现了，嘻嘻。</strong></li>\n<li>这里的基类是不能被实例化的，因为基类里面的show方法，我用的是纯虚函数来写的，不能被实例化，但在派生类要实现，你不实现的话，你写这个虚函数就没意义了，基类的纯虚函数在派生类你一定要写进去，不要编译器会报错的，<h1 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h1><strong>在类中有指针又要多个类的对象的时候最好写一下类的拷贝构造函数</strong></li>\n</ul>\n<ol>\n<li>在程序中的拷贝是浅拷贝，也就是说在类中只是简单的把普通类型的成员变量复制给另外一个类的对象。但在有引用或者有指针的类里面，如果我们没有声明另外的拷贝构造函数的话，我们的程序就会报错。</li>\n<li>拷贝构造函数的形参必须是类的类型,该参数必须传引用,而且还要在前面使用const修饰符</li>\n<li>使用拷贝构造函数在本类中要有指针变量或者多对象<h1 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h1></li>\n</ol>\n<ul>\n<li>关键字 template <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T add (T a, T b)&#123;</span><br><span class=\"line\">    return a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;add(1,2)&lt;&lt;endl;;</span><br><span class=\"line\">    cout&lt;&lt;add(10.1,10.2)&lt;&lt;endl;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">20.3</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double numb(55.55);</span><br><span class=\"line\">    coutw&lt;&lt;numb&lt;&lt;endl;</span><br><span class=\"line\">    cout.setf(ios::fixed);</span><br><span class=\"line\">    cout.setf(ios::showpoint)</span><br><span class=\"line\">    cout.precision(1);</span><br><span class=\"line\">    cout&lt;&lt;numb&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">55.55</span><br><span class=\"line\">55.5</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"拷贝构造函数-1\"><a href=\"#拷贝构造函数-1\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h1><ul>\n<li><p>test.h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test&#123;</span><br><span class=\"line\">    string _name;</span><br><span class=\"line\">    int _*age;</span><br><span class=\"line\">    Test(string name,int age)&#123;</span><br><span class=\"line\">        _name=name;</span><br><span class=\"line\">        _age=new int (age);</span><br><span class=\"line\">        cout&lt;&lt;&quot;有参构造函数&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void()&#123;</span><br><span class=\"line\">        cout&lt;&lt;_name&lt;&lt;&quot;的年龄&quot;&lt;&lt;_age&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //深拷贝构造函数</span><br><span class=\"line\">    Test(const Test &amp;t)&#123;//把类作为函数的参数</span><br><span class=\"line\">        _name=t._name;</span><br><span class=\"line\">        _age=new int (*t._age);//这里用的是指针来new,因为在本类中它就是以指针的方式来存放的，所以你也只能以指针的形式来启用它。</span><br><span class=\"line\">        cout&lt;&lt;&quot;拷贝构造函数&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Test()&#123;</span><br><span class=\"line\">        delete age;</span><br><span class=\"line\">        cout&lt;&lt;&quot;析构函数&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>main</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using space std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Test t1(&quot;小明&quot;,10);</span><br><span class=\"line\">    t1.show();</span><br><span class=\"line\">    //类的使用在这以上是没有问题的，这就是浅拷贝额构造函数</span><br><span class=\"line\">    //当我们要在有指针(*)或者引用(&amp;)的类中使用二次构造函数，那么我们就要写一个深的拷贝构造函数</span><br><span class=\"line\">    Test t2(t1);//这个类的复制是要有深的拷贝构造函数来配合的。因为它符合条件</span><br><span class=\"line\">    t2.show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>程序运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有参构造函数</span><br><span class=\"line\">小明的年龄10</span><br><span class=\"line\">拷贝构造函数</span><br><span class=\"line\">小明的年龄10</span><br><span class=\"line\">析构函数</span><br><span class=\"line\">析构函数</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题-这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。\"><a href=\"#其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题-这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。\" class=\"headerlink\" title=\"其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题,这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。\"></a><strong>其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题,这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。</strong></h2><h1 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;//因为要使用模板，所以在定义模板</span><br><span class=\"line\">class Apple&#123;</span><br><span class=\"line\">  friend ostream &amp;operator&lt;&lt;(ostream &amp;out,Apple &amp;a)&#123;//这里定义的是友元函数，用输出流来输出两个对象的相加</span><br><span class=\"line\">      out&lt;&lt;a.c&lt;&lt;&quot;+&quot;&lt;&lt;a.n&lt;&lt;endl;</span><br><span class=\"line\">      return out;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    T c;//泛性的成员变量</span><br><span class=\"line\">    T n;</span><br><span class=\"line\">    Apple(T _a,T_b)&#123;//构造函数</span><br><span class=\"line\">    this-&gt;c=_a;</span><br><span class=\"line\">    this-&gt;n=_b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Apple &lt;int&gt; operator+(Apple &amp;a)&#123;//这里调用的是类的构造函数来实现两个对象的相加并把相应的数值存放在本类的成员变量中。</span><br><span class=\"line\">    Apple addsum(this-&gt;c+a.c,this-&gt;n+a.n);</span><br><span class=\"line\">    return addsum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &quot;Apple.h&quot;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">     Apple &lt;int&gt;a(10,20); </span><br><span class=\"line\">     Apple &lt;int&gt;a1(20,30);</span><br><span class=\"line\">     Apple &lt;int&gt;c=a+a1;</span><br><span class=\"line\">     cout&lt;&lt;c&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行结果</span><br><span class=\"line\">30+50</span><br></pre></td></tr></table></figure>\n<p><strong>注意事项</strong> </p>\n<p><img src=\"/2019/06/12/C-Book/c-Book5.png\" alt=\"模板类\"> </p>\n","site":{"data":{}},"excerpt":"<pre><code>c++\n</code></pre>","more":"<h1 id=\"C-Book\"><a href=\"#C-Book\" class=\"headerlink\" title=\"C++Book\"></a>C++Book</h1><h1 id=\"库\"><a href=\"#库\" class=\"headerlink\" title=\"库\"></a>库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;hello would&lt;&lt;endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在上面的代码我们应该都知道我什么都没有实现，这只是在简单的阐述一下c++库的重要性，也可以说是让我们更深刻的认识到有些代码的意思是什么。</strong></p>\n<ul>\n<li>#include,using (预编译指令) </li>\n<li>iostream (是c++标准库，方便使用cout,cin,) </li>\n<li>using namespace std (是命名空间,std,因为在库里大多数都有std命名空间的部分，所以规定这些名称为std)<h1 id=\"结构函数\"><a href=\"#结构函数\" class=\"headerlink\" title=\"结构函数\"></a>结构函数</h1></li>\n<li>关键字struct+结构名<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">struct point&#123;</span><br><span class=\"line\">    int a=5;</span><br><span class=\"line\">    int b=10;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    point *p=new point;    //在堆内存里new了内存</span><br><span class=\"line\">    p-&gt;a=10;</span><br><span class=\"line\">    p-&gt;b=5;</span><br><span class=\"line\">    cout&lt;&lt;p1-&gt;a&lt;&lt;&quot;\\t&quot;&lt;&lt;p1-&gt;&lt;&lt;endl;</span><br><span class=\"line\">    point p1,p2;              //在栈内存里实现,还把poit里的参数全部给p2使用</span><br><span class=\"line\">    cout&lt;&lt;p1.a&lt;&lt;&quot;\\t&quot;&lt;&lt;p1.b&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;p2.a&lt;&lt;&quot;\\t&quot;&lt;&lt;p2.b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5    10</span><br><span class=\"line\">5    10</span><br><span class=\"line\">5    10</span><br></pre></td></tr></table></figure></p>\n<p><strong>其实结构和类是相似的</strong></p>\n<hr>\n<h1 id=\"联合函数\"><a href=\"#联合函数\" class=\"headerlink\" title=\"联合函数\"></a>联合函数</h1><ul>\n<li>关键字union+名字<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">union test&#123;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    char b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test *p=new test;         //在堆内存new了内存</span><br><span class=\"line\">    p-&gt;a=97;</span><br><span class=\"line\">    cout&lt;&lt;p-&gt;a&lt;&lt;&quot;的字符表示是：&quot;&lt;&lt;p-&gt;b&lt;&lt;endl;</span><br><span class=\"line\">    test t1;                  //在栈内存里实现</span><br><span class=\"line\">    t1.a=65;</span><br><span class=\"line\">    cout&lt;&lt;t1.a&lt;&lt;&quot;的字符表示是：&quot;&lt;&lt;t.b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>一样的和类相似，在栈和堆内存一样使用,不相同的是：联合函数你可以给变量的其中一个赋值，而另外一个变量会自己把已经赋值的那个变量的值赋给自己。</strong></p>\n<hr>\n<h1 id=\"枚举函数\"><a href=\"#枚举函数\" class=\"headerlink\" title=\"枚举函数\"></a>枚举函数</h1><ul>\n<li>关键字enum+名字<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">enum Arrow&#123;</span><br><span class=\"line\">    eroos,ok,warning,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Arrow a1=eroos;</span><br><span class=\"line\">    Arrow a2=ok;</span><br><span class=\"line\">    Arrow a3=warning;</span><br><span class=\"line\">    cout&lt;&lt;a1&lt;&lt;a2&lt;&lt;a3&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<p><strong>枚举的特点：它是以字符的形式声明的，但输出的确实整数型的数字</strong></p>\n<hr>\n<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><p><strong>排序的方法有很多，但我们只要理解一种就可以了。我选择冒泡排序</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int arr[]=&#123;3,10,5,11,6&#125;</span><br><span class=\"line\">    for(int i=5-1;i&gt;0;i--)&#123;</span><br><span class=\"line\">        //把第一个数字设置为最大的数字来跟剩下的数字一起来比较，所以这的次数是总数来减一</span><br><span class=\"line\">        for(int j=0;j&lt;i;j++&gt;)&#123;</span><br><span class=\"line\">            //把每一次大的循环里的数组的大值都往后一个交换位置</span><br><span class=\"line\">            if(arr[j]&gt;arr[j+1])&#123;//条件满足就交换位置</span><br><span class=\"line\">                int temp;</span><br><span class=\"line\">                temp=arr[j];</span><br><span class=\"line\">                arr[j]=arr[j+1];</span><br><span class=\"line\">                arr[j+1]=temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;&quot;排序后&quot;&lt;&lt;endl;</span><br><span class=\"line\">    for(int i=0;i&lt;5;i++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">排序后</span><br><span class=\"line\">3</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h1><p><strong>递归函数:调用的时候是使用栈内存来实现的，函数一层一层的往下递归，递归的同时会把函数停住，而计算机会重复的把信息保存到栈内存里，遇到递归停止的条件时又会一层一层的往上走在信息停止的那一步，从而实现递归的真正意义。值得注意的是，递归是栈内存的实现，它把信息放在最底层上。每当计算机往上走的时候都是从最低下中读取信息的。栈是先出后入的内存结构。</strong></p>\n<ul>\n<li>通俗一点的意思就是在本函数里调用自身函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int add(int i)&#123;</span><br><span class=\"line\">    cout&lt;&lt;&quot;函数开始:i=&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    if(i=5)&#123;</span><br><span class=\"line\">        return i;</span><br><span class=\"line\">    &#125;else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        add(++i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;&quot;函数结束,返回值为：&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    return i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;add(1)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>函数的结果：`<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数开始：i=1</span><br><span class=\"line\">函数开始：i=2</span><br><span class=\"line\">函数开始：i=3</span><br><span class=\"line\">函数开始：i=4</span><br><span class=\"line\">函数开始：i=5</span><br><span class=\"line\">函数结束，返回值为：5</span><br><span class=\"line\">函数结束，返回值为：4</span><br><span class=\"line\">函数结束，返回值为：3</span><br><span class=\"line\">函数结束，返回值为：2</span><br><span class=\"line\">函数结束，返回值为：1</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>这里的先是返回的自身函数调用的结果，这里编译器里是有五个变量来暂时存储自身函数的值，每当执行到函数返回的时候编译器都会从暂时存储那里把值返回给我们，还有一种理解，就是这个函数里的变量在每次自身函数调用的时候都被隐藏起来了，也就是说每次的自身函数的调用它都有不同的存储位置来让变量重新赋值。其实，递归函数是在返回的时候才是这种函数真真的意义，因为自身函数的最后一次刚好是函数返回值的第一次。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//阶乘的实现</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int test(int test1)&#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    if(test1==1)&#123;//递归的停止条件</span><br><span class=\"line\">        val=1;</span><br><span class=\"line\">        return val;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        val=test1*test(test1-1);</span><br><span class=\"line\">        return val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;&quot;实现阶乘,请输入一个数字:&quot;&lt;&lt;endl;</span><br><span class=\"line\">    int t1;</span><br><span class=\"line\">    cin&gt;&gt;t1;</span><br><span class=\"line\">    cout&lt;&lt;test(t1)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>强调一下，递归的停止条件的重要性，一旦递归没遇到停止的条件就会无穷的死循环，直到计算机的内存都跑完!!!</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int test(int t1,int t2)&#123;</span><br><span class=\"line\">    if(t2==0)&#123;</span><br><span class=\"line\">        return 1;//递归的停止条件,t2==0,就返回1</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return test(t1,t2-1)*t1;//上面返回的值来当作第一次的值，然后一直往上计算</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;test(3,2)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br></pre></td></tr></table></figure></p>\n<p><strong>递归的三大条件</strong></p>\n<ul>\n<li>(有返回值类型，无返回值类型)</li>\n</ul>\n<ol>\n<li>没有无穷的递归</li>\n<li>每一种停止的情况都执行(返回)那种情况下的正确操作</li>\n<li>所有递归函数的调用都能正确的执行操作，那么最后的结果一定是正确的</li>\n</ol>\n<hr>\n<h1 id=\"函数与指针\"><a href=\"#函数与指针\" class=\"headerlink\" title=\"函数与指针\"></a>函数与指针</h1><ul>\n<li>指向函数的指针<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int test(int a)&#123;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int (*p)(int a)=&amp;add;//指向函数的指针</span><br><span class=\"line\">    cout&lt;&lt;P(5)&lt;&lt;endl;</span><br><span class=\"line\">    int (*ip[])(int a)=&#123;&amp;add,&amp;test&#125;;//指向多个函数的指针数组</span><br><span class=\"line\">    cout&lt;&lt;ip[0](1)&lt;&lt;ip[1](2)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>函数的结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>这里的指针都是储存在栈内存里的。</li>\n</ul>\n<hr>\n<h1 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h1><ul>\n<li>格式化代码，去除多余的空格和注释</li>\n<li>进行一些宏替换</li>\n<li>包含另外一段代码</li>\n<li>通过一些条件的判断，动态决定是否编译某段代码</li>\n</ul>\n<ol>\n<li>宏定义</li>\n</ol>\n<h2 id=\"在定义宏的时候记得不要在定义的后面加分号！！！\"><a href=\"#在定义宏的时候记得不要在定义的后面加分号！！！\" class=\"headerlink\" title=\"在定义宏的时候记得不要在定义的后面加分号！！！\"></a><strong>在定义宏的时候记得不要在定义的后面加分号！！！</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define MAX 9               //宏定义</span><br><span class=\"line\">#define MAN2 MAX*MAX        //宏定义</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;MAX&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;MAX2&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br><span class=\"line\">81</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>带参数的宏定义<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define MAX 3                        //无参宏定义</span><br><span class=\"line\">#define space(x) ((x)*(x))           //声明一个带参数的宏定义</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    for(int i=1;i&lt;=MAX;i++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;i&lt;&lt;&quot;的平方是：&quot;&lt;&lt;space(i)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行结果是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1的平方是：1</span><br><span class=\"line\">2的平方是：4</span><br><span class=\"line\">3的平方是：9</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define add(a,b)(a+b)           //带参的宏定义</span><br><span class=\"line\">#define test(x) #x         //#是连接</span><br><span class=\"line\">#define test1(a*,* b) a##b        //a和b是连接在一起的</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    string s1(&quot;hello,&quot;);        //字符串</span><br><span class=\"line\">    string s2(&quot;world!&quot;);</span><br><span class=\"line\">    cout&lt;&lt;add(100,100)&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;add(s1,s2)&lt;&lt;endl;     //使用宏来实现字符串的相加</span><br><span class=\"line\">    cout&lt;&lt;test(hello world)&lt;&lt;endl;</span><br><span class=\"line\">    int ab=10;</span><br><span class=\"line\">    cout&lt;&lt;test1(a,b)&lt;&lt;endl;//这里的ab是连接起来的，所以在前面定义了ab的值，也就是说这里输出的只是变量ab的值，并不是说把a和b当作实参过去的。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200</span><br><span class=\"line\">hello,world</span><br><span class=\"line\">helloworld</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"说明了宏的优点有-避免了强类型的检测\"><a href=\"#说明了宏的优点有-避免了强类型的检测\" class=\"headerlink\" title=\"说明了宏的优点有:避免了强类型的检测\"></a><strong>说明了宏的优点有:避免了强类型的检测</strong></h2><ol start=\"3\">\n<li>宏与常量，函数<br>宏与常量有点相似，但当他们遇上指针和引用之后又会变成什么呢？<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define x 10</span><br><span class=\"line\">const int y=5;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    const int &amp;a=x;          //ok</span><br><span class=\"line\">    const int *p=&amp;y;         //ok</span><br><span class=\"line\">    cout&lt;&lt;a&lt;&lt;&quot;\\t&quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10    5</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里给宏使用了引用，给常量使用了指针。还在定义的前面都加了const类型。</strong><br><strong>但是在这里还是不希望使用引用和指针的方式来操作宏和常量,把宏看作是简单的文本替换，这也是宏的原本意义。</strong></p>\n<p><strong>宏不允许重新定义，也就是说一个相同的宏只能被定义一次，要想修改宏的值，你只能先消除它，使用#undef关键来消除，然后你就可以重新定义了。</strong></p>\n<ol start=\"4\">\n<li><p>在c++中有还有内置的宏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;__TIME__&lt;&lt;endl; //输出当前代码运行的时间</span><br><span class=\"line\">    cout&lt;&lt;__DATE&lt;&lt;endl;   //输出当前代码运行的日期</span><br><span class=\"line\">    cout&lt;&lt;__LINE&lt;&lt;endl;   //输出当前代码的所在行号</span><br><span class=\"line\">    cout&lt;&lt;__FIME__&lt;&lt;endl; //输出当前代码的文件路径</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>#if #elif #else  #ifdef #ifndef</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define a 10</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    #if a&lt;20</span><br><span class=\"line\">    cout&lt;&lt;&quot;欢迎使用测试版&quot;&lt;&lt;endl;</span><br><span class=\"line\">    #else</span><br><span class=\"line\">    cout&lt;&lt;&quot;欢迎使用正版&quot;&lt;&lt;endl;</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行的结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">欢迎使用测试版</span><br></pre></td></tr></table></figure></p>\n<p><strong>#if类似与我们在以前代码里的if，#else类似与else,#elif类似elseif</strong></p>\n<h2 id=\"endif-很重要。如果没有它你的程序是跑不起来的。\"><a href=\"#endif-很重要。如果没有它你的程序是跑不起来的。\" class=\"headerlink\" title=\"#endif,很重要。如果没有它你的程序是跑不起来的。\"></a><strong>#endif,很重要。如果没有它你的程序是跑不起来的。</strong></h2><p><strong>在c++中有很多预定义函数，这其中有一中是异常处理函数，关键字(try)</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">     __try&#123;</span><br><span class=\"line\">      int i;</span><br><span class=\"line\">      cout&lt;&lt;&quot;请输入一个数字&quot;&lt;&lt;end;</span><br><span class=\"line\">      cin&gt;&gt;i;</span><br><span class=\"line\">      if(i&lt;=0)&#123;</span><br><span class=\"line\">      throw &quot;error&quot;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">      &#125;catch(const char *p)&#123;//指定抛出异常的类型</span><br><span class=\"line\">         cout&lt;&lt;p&lt;&lt;endl;</span><br><span class=\"line\">      &#125;catch(...)&#123;</span><br><span class=\"line\">      cout&lt;&lt;&quot;在main函数里有异常&quot;&lt;&lt;endl;//任何抛出异常的类型都能接受,这里虽然是可以接受任何类型的异常但在前面已经有指定的抛出类型，所以在这里输出的是指定的抛出类型</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>e.what(是用来打印异常抛出的)</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">error</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><img src=\"/2019/06/12/C-Book/c-Book4.png\" alt=\"不同的类型抛出\"></p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> bad_typeid:</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> bad_cast</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> bad_alloc:在new一个内存时，如果没有足够的空间时会抛出异常来，</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> ios_base::failure:上一个的异常抛出打印的类型</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> logic_error—out_of_range:这是数组下标越界会抛出(out_of_range)类型的异常来</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define a 10</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    #ifdef a</span><br><span class=\"line\">    cout&lt;&lt;&quot;欢迎使用正版&quot;&lt;&lt;endl;</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">    #ifndef</span><br><span class=\"line\">    cout&lt;&lt;&quot;欢迎使用测试版&quot;&lt;&lt;endl;</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>值得注意的是，#ifdef和#ifndef都要有#endif使用，#endif的意思应该是结束if</strong></p>\n<hr>\n<h1 id=\"预定义字符函数\"><a href=\"#预定义字符函数\" class=\"headerlink\" title=\"预定义字符函数\"></a>预定义字符函数</h1><p><strong>预定义字符函数就是把字符转换成大，小写的字符，在计算机中，我们虽然是以字符的形式输入到计算机中，但计算机本身的运作却是以数字的形式来使用的。值得注意的是，书上写的需要头文件但我这里是不需要头文件的，可能是版本的问题吧，如果有报错的话就加个头文件(cctype)</strong></p>\n<ol>\n<li>toupper()(把字符转换成大写的)</li>\n<li>tolower()(小写) </li>\n<li>isupper()(如果字符是大写的就为true，否则false)</li>\n<li>islower()(同上)</li>\n<li>isspace()(如果字符是空白字符就为true,否则false)，一般这个识别的都跟着cin.get()这个函数，因为它识别空格，你可以在它识别空格的时候输出一些东西，下面有个小列子。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">void test()&#123;</span><br><span class=\"line\">    char a,b;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入字符&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;b;</span><br><span class=\"line\">    a=toupper(b)</span><br><span class=\"line\">    cout&lt;&lt;c&lt;&lt;endl;</span><br><span class=\"line\">    if(isupper(b))&#123;//条件一开始为false</span><br><span class=\"line\">        cout&lt;&lt;&quot;转换成功\\t&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;转换失败&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test();</span><br><span class=\"line\">    char c;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入字符&quot;&lt;&lt;endl;</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">        cin.get(c);//逐步输入字符</span><br><span class=\"line\">        if(isspace(c))&#123;//判断是否符合条件     空格</span><br><span class=\"line\">            cout&lt;&lt;&apos;--&apos;;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            cout&lt;&lt;c&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;while(c!=&apos;.&apos;);</span><br><span class=\"line\">    cin.get();//识别空格，是空格就打印下面的那句话</span><br><span class=\"line\">    cout&lt;&lt;&quot;空格&quot;&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入字符</span><br><span class=\"line\">a</span><br><span class=\"line\">转换成功   A</span><br><span class=\"line\">请输入字符</span><br><span class=\"line\">add test</span><br><span class=\"line\">add--test--.</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"类的特征\"><a href=\"#类的特征\" class=\"headerlink\" title=\"   类的特征\"></a>   <strong>类的特征</strong></h2><ol>\n<li>类同时具有成员变量和成员函数。</li>\n<li>成员可变成私有和共有</li>\n<li>正常下类的成员变量是私有的</li>\n<li>类的私有成员只能在本类的函数里面定义和调用</li>\n<li>类的成员函数可以像普通的函数一样重载</li>\n<li>一个类可将另外一个类作为自己的成员变量的类性使用</li>\n<li>函数的i形参可以是类的类型</li>\n<li>类可以是函数的返回值类型</li>\n</ol>\n<hr>\n<p><strong>类的基本</strong></p>\n<ul>\n<li>所有的成员变量设为私有的</li>\n<li>用户程序员通过函数作为成员变量的接口来访问变量和完善的规定如何使用每一个公共成员函数</li>\n<li>任何辅助函数都设为私有的</li>\n</ul>\n<hr>\n<ul>\n<li>以前的数据和操作的过程都不是独立的，而c++允许我们将一些数据和操作数据的过程放在同一个地方，并封装成一个独立的个体。</li>\n<li>万物皆对象，这句话对c++程序员来说并不陌生。这并不代表我们缺少对象，对于我们这种高质男来说从来没担心过搞不到对象，因为我们随时随地都可以new一个对象出来，这不是一般人可以做到的，只有真的走进来了才可以的，虽然这个操作在c++中也不算是什么高难度的操作，但我们又不是学到这里就完事的。类和结构是完全可以交换的，唯一不一样的是结构的默认特性是public,而类的默认特性是private。</li>\n</ul>\n<hr>\n<ol>\n<li>数据类型:由值的集合以及为那些值定义的一组基本运算构成 </li>\n<li>抽像数据类型(ADT):使用数据类型的程序员访问不了值和运算的细节 </li>\n</ol>\n<ul>\n<li>封装，是用简单明了的公有函数的方式为外部程序提供对象操作接口。<h1 id=\"成员对象\"><a href=\"#成员对象\" class=\"headerlink\" title=\"成员对象\"></a>成员对象</h1></li>\n<li>分为三种：public,private，protected</li>\n</ul>\n<ol>\n<li>公有对象：不管是在类里还是在外部都能被访问到。</li>\n<li>私有对象：只能在本类中访问到。</li>\n<li>保护对象：只能在本类中访问到，在外部是访问不到的。<h1 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h1></li>\n<li>重载运算符，至少要有一个参数的类型是类</li>\n<li>重载的函数可以是类的友元函数也可以是成员函数</li>\n<li>不能新建运算符</li>\n<li>不能改变获取的形参操作符的意义</li>\n<li>不能改变操作符的优先级</li>\n<li>不能重载一下操作符(.(圆点)::(作用域)…)    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Son;//先声明Son类</span><br><span class=\"line\">class Bos&#123;</span><br><span class=\"line\">friend int operator+(Bos bos,Son son);//友元函数，用来访问类的私有成员</span><br><span class=\"line\">friend ostream &amp;operator&lt;&lt;(ostream &amp;os,Bos bos);//友元函数，用来访问类的私有成员</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int a=10;</span><br><span class=\"line\">    int b=5;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Son&#123;</span><br><span class=\"line\">friend int operator+(Bos bos,Son son);//友元函数，用来访问类的私有成员</span><br><span class=\"line\">friend ostream &amp;operator&lt;&lt;(ostream &amp;os,Bos bos);//友元函数，用来访问类的私有成员</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int a=5;</span><br><span class=\"line\">    int b=10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int operator+(Bos bos,Son son)&#123;//运算符重载加号</span><br><span class=\"line\">    int a=bos.a+bos.b;</span><br><span class=\"line\">    int b=son.a+son.b;</span><br><span class=\"line\">    return a,b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ostream &amp;operator&lt;&lt;(ostream &amp;os,Bos bos)&#123;//运算符重载&lt;&lt;号</span><br><span class=\"line\">    os&lt;&lt;&quot;a=&quot;&lt;&lt;bos.a&lt;&lt;&quot;b=&quot;&lt;&lt;bos.b&lt;&lt;endl;//把成员变量连接在cout流中</span><br><span class=\"line\">    return os;//返回cout，这样就能在main函数中直接打印</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Bos bos;</span><br><span class=\"line\">    Son son</span><br><span class=\"line\">    cout&lt;&lt;bos+son&lt;&lt;endl;//这要是没有重载加号，是运行不过的</span><br><span class=\"line\">    cout&lt;&lt;bos&lt;&lt;endl;//没有重载&lt;&lt;也是运行不过来的</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"谨慎参考，纯属本人理解。ostream-是因为要用到cout流，因为输出流是属于ostream里面的，-amp-是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。\"><a href=\"#谨慎参考，纯属本人理解。ostream-是因为要用到cout流，因为输出流是属于ostream里面的，-amp-是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。\" class=\"headerlink\" title=\"谨慎参考，纯属本人理解。ostream,是因为要用到cout流，因为输出流是属于ostream里面的，&amp;,是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。\"></a><strong>谨慎参考，纯属本人理解。ostream,是因为要用到cout流，因为输出流是属于ostream里面的，&amp;,是因为返回的是一个输出流，所以要加个引用来指引。还有就是，重载函数的参数只能是两个，反正在我电脑是两个，超过了就给老子报错，我太难了。</strong></h2><h1 id=\"const-mutable\"><a href=\"#const-mutable\" class=\"headerlink\" title=\"const mutable\"></a>const mutable</h1><ul>\n<li>众所周知，const是常量类型。而mutable是可变的，就像是普通变量。<h1 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    vector &lt;int &gt;a&#123;10,20,3,5,1&#125;;</span><br><span class=\"line\">    a.insert(a.begin(),8);//在向量最前面插入数字8</span><br><span class=\"line\">    sort(a.begin(),a.end());//升序</span><br><span class=\"line\">    vector &lt;int &gt;::iterator it;//打印</span><br><span class=\"line\">    for(it=a.begin();it!=a.end();it++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;*it&lt;&lt;&quot;      &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reverse(a.begin(),a.end());//逆序</span><br><span class=\"line\">    for(it=a.begin();it!=a.end();it++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;*it&lt;&lt;&quot;      &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a.clear();//清除向量</span><br><span class=\"line\">    vector &lt;int &gt; b;</span><br><span class=\"line\">    a.swap(b);</span><br><span class=\"line\">    for(it=b.begin();it!=b.end();it++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;*it&lt;&lt;&quot;      &quot;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">1    3    5   8   10   20</span><br><span class=\"line\">20   10   8   5   3   1</span><br><span class=\"line\">20   10   8   5   3   1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main ()&#123;</span><br><span class=\"line\">      int numb[]=&#123;10,20,23,11,&#125;</span><br><span class=\"line\">      int numb1[4]=&#123;0&#125;;</span><br><span class=\"line\">      memcpy(numb1,numb,sizeof(numb));</span><br><span class=\"line\">      for(int i=0;i&lt;4;i++)&#123;</span><br><span class=\"line\">      cout&lt;&lt;numb1[i]&lt;&lt;&apos;   &apos;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">10   20   23   11</span><br></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> <strong>静态成员函数和静态成员变量</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">&quot;.h&quot;</span><br><span class=\"line\"># include &lt;iostream&gt;</span><br><span class=\"line\">class Test&#123;</span><br><span class=\"line\">      private:</span><br><span class=\"line\">      static int a;</span><br><span class=\"line\">      int b;</span><br><span class=\"line\">      public:</span><br><span class=\"line\">      Test(int _a)&#123;</span><br><span class=\"line\">      a=_a;</span><br><span class=\"line\">      ++b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      static void show(Test tt)&#123;//静态成员函数中通过对象来引用非静态成员</span><br><span class=\"line\">      cout&lt;&lt;&quot;tt.a=&quot;&lt;tt.a&lt;&lt;endl;</span><br><span class=\"line\">      cout&lt;&lt;&quot;Test::b=&quot;&lt;&lt;Test::b&lt;&lt;endl;</span><br><span class=\"line\">      cout&lt;&lt;&quot;tt.b=&quot;&lt;&lt;tt.b&lt;&lt;endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int Test::b=0;//这是放在main函数上面的</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">        Test t1(100);</span><br><span class=\"line\">        Test t2(200);</span><br><span class=\"line\">        Test::show(t1);</span><br><span class=\"line\">        Test::show(t2);//静态成员函数调用时不用对象名 </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果为：</span><br><span class=\"line\">tt.a=100</span><br><span class=\"line\">Test::b=2</span><br><span class=\"line\">tt.b=2</span><br><span class=\"line\">tt.a=200</span><br><span class=\"line\">Test::b=2</span><br><span class=\"line\">tt.b=2</span><br></pre></td></tr></table></figure>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">    string _name;</span><br><span class=\"line\">    int _year;</span><br><span class=\"line\">    Teacher(string name,int year)&#123;</span><br><span class=\"line\">        this-&gt;_name=name;</span><br><span class=\"line\">        this-&gt;_year=year;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void show()&#123;</span><br><span class=\"line\">        cout&lt;&lt;this-&gt;_name&lt;&lt;&quot;老师的年龄是：&quot;&lt;&lt;this-&gt;_year&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Student::puble Teacher&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">       Student(string name,int year):Teacher(name,year)&#123;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>上面的基类用的是构造函数来给自己赋初始化的，所以在派生类也要写上自己的构造函数才算继承基类。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Student s1(&quot;小明&quot;,18);</span><br><span class=\"line\">    s1.show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">小明的年龄是：18</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。\"><a href=\"#这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。\" class=\"headerlink\" title=\"这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。\"></a><strong>这里比较特殊的就是成员变量一般是构造函数给的初始化值，但我们在继承的时候往往会遇到问题，就是在声明子类的构造函数会报错，这时我们只能在子类的构造函数中给父类的成员变量赋值，这样才能算是真正的继承下来。</strong></h2><ul>\n<li>继承的方式有三种：public private protected<br>公有继承, 私有继承, 保护继承</li>\n</ul>\n<ol>\n<li>公有继承：是以公有的形式来继承的基类，这也就意味着在基类是什么类型的在派生类也是一样的关系。</li>\n<li>私有继承：是以私有的形式来继承的基类,就是说继承下来的基类都是以私有的形式来继承的。</li>\n<li>保护继承：是以保护的形式来继承的基类，它是基于公有继承和私有继承的中间，如果你不想在外界被访问到，又想在派生类中被访问，这就可以用保护的形式来继承下来了，但基类的私有成员对象在保护的派生类中依然是私有成员对象。<br><img src=\"/2019/06/12/C-Book/c-Book.png\" alt=\"继承的方式\"><br><strong>派生类不会自动的继承基类的构造函数</strong><h1 id=\"隐藏\"><a href=\"#隐藏\" class=\"headerlink\" title=\"隐藏\"></a>隐藏</h1></li>\n</ol>\n<ul>\n<li>我们以后难免会在派生类里定义属于它自己的成员变量和成员函数，但当我们在声明和定义的时候有时也会不小心的把成员变量和成员函数与基类的成员变量和成员函数名字相同，这是我们的程序就会出现名字隐藏的现象，对于隐藏就是说当我们的派生类与基类中有名字相同的，就可能会出现隐藏。如果不知道什么时候被隐藏了什么，我们可以加上作用域去看看，在这里，我的建议是，尽量不要在继承类里面用同样的名字，不然你会很自闭的。</li>\n<li>基类的析构函数最好加上关键字（virtual）写成虚函数，这样在派生类的时候的就能自动调用，而对于，纯虚函数，在派生类中是要重写的性质，因为在基类的纯虚函数是空函数一个，它的本质就是一定要在派生类里面实现它的意义。一个良好的习惯：最好把基类的析构函数写成虚的，这样在派生类中是会自动调用的。</li>\n</ul>\n<p><strong>纯虚函数是不能对它进行实例化的，也就是说不能给它创建对象，这是要注意的重点，不能说你定义的是一个纯虚函数，然后你又在main函数里给它创建一个对象来进行一些操作。</strong> </p>\n<p><strong>在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现(谁派生谁实现)。这部分的功能往往是基类不需要的，或者是在基类中实现不了的，虽然基类完成不了，但强制交给了派生类去实现，否则一样不能被实例化。</strong> </p>\n<p><strong>抽象基类除了限制了派生类，也实现了多态(也就是说在main函数里，你可以使用基类来调用派生类里面重写的纯虚函数)。</strong> </p>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h1><ul>\n<li>其实就是在类里面把函数写成是纯虚函数，这样在派生类里就剩下重写这些虚函数。一般把抽象类用来设计一套统一的接口。<br><img src=\"/2019/06/12/C-Book/c-Book2.png\" alt=\"例子\"><br><img src=\"/2019/06/12/C-Book/c-Book1.png\" alt=\"例子\"><br><img src=\"/2019/06/12/C-Book/c-Book3.png\" alt=\"运行结果\"><br><strong>重新认识了类的继承，这里我没有用到构造函数来给成员变量赋值，因为用了构造函数会变的很自闭，发正我是完全不能理解的那种，所以我用来另外一种方法，虽然算不上什么，但我觉得自己理解写出来的东西是可以的。孙悟空吃唐僧，这是多么厉害的，我想这个结果连孙悟空自己也不敢想的，我帮他实现了，嘻嘻。</strong></li>\n<li>这里的基类是不能被实例化的，因为基类里面的show方法，我用的是纯虚函数来写的，不能被实例化，但在派生类要实现，你不实现的话，你写这个虚函数就没意义了，基类的纯虚函数在派生类你一定要写进去，不要编译器会报错的，<h1 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h1><strong>在类中有指针又要多个类的对象的时候最好写一下类的拷贝构造函数</strong></li>\n</ul>\n<ol>\n<li>在程序中的拷贝是浅拷贝，也就是说在类中只是简单的把普通类型的成员变量复制给另外一个类的对象。但在有引用或者有指针的类里面，如果我们没有声明另外的拷贝构造函数的话，我们的程序就会报错。</li>\n<li>拷贝构造函数的形参必须是类的类型,该参数必须传引用,而且还要在前面使用const修饰符</li>\n<li>使用拷贝构造函数在本类中要有指针变量或者多对象<h1 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h1></li>\n</ol>\n<ul>\n<li>关键字 template <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T add (T a, T b)&#123;</span><br><span class=\"line\">    return a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout&lt;&lt;add(1,2)&lt;&lt;endl;;</span><br><span class=\"line\">    cout&lt;&lt;add(10.1,10.2)&lt;&lt;endl;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">20.3</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double numb(55.55);</span><br><span class=\"line\">    coutw&lt;&lt;numb&lt;&lt;endl;</span><br><span class=\"line\">    cout.setf(ios::fixed);</span><br><span class=\"line\">    cout.setf(ios::showpoint)</span><br><span class=\"line\">    cout.precision(1);</span><br><span class=\"line\">    cout&lt;&lt;numb&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">55.55</span><br><span class=\"line\">55.5</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"拷贝构造函数-1\"><a href=\"#拷贝构造函数-1\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h1><ul>\n<li><p>test.h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test&#123;</span><br><span class=\"line\">    string _name;</span><br><span class=\"line\">    int _*age;</span><br><span class=\"line\">    Test(string name,int age)&#123;</span><br><span class=\"line\">        _name=name;</span><br><span class=\"line\">        _age=new int (age);</span><br><span class=\"line\">        cout&lt;&lt;&quot;有参构造函数&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void()&#123;</span><br><span class=\"line\">        cout&lt;&lt;_name&lt;&lt;&quot;的年龄&quot;&lt;&lt;_age&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //深拷贝构造函数</span><br><span class=\"line\">    Test(const Test &amp;t)&#123;//把类作为函数的参数</span><br><span class=\"line\">        _name=t._name;</span><br><span class=\"line\">        _age=new int (*t._age);//这里用的是指针来new,因为在本类中它就是以指针的方式来存放的，所以你也只能以指针的形式来启用它。</span><br><span class=\"line\">        cout&lt;&lt;&quot;拷贝构造函数&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Test()&#123;</span><br><span class=\"line\">        delete age;</span><br><span class=\"line\">        cout&lt;&lt;&quot;析构函数&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>main</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using space std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Test t1(&quot;小明&quot;,10);</span><br><span class=\"line\">    t1.show();</span><br><span class=\"line\">    //类的使用在这以上是没有问题的，这就是浅拷贝额构造函数</span><br><span class=\"line\">    //当我们要在有指针(*)或者引用(&amp;)的类中使用二次构造函数，那么我们就要写一个深的拷贝构造函数</span><br><span class=\"line\">    Test t2(t1);//这个类的复制是要有深的拷贝构造函数来配合的。因为它符合条件</span><br><span class=\"line\">    t2.show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>程序运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有参构造函数</span><br><span class=\"line\">小明的年龄10</span><br><span class=\"line\">拷贝构造函数</span><br><span class=\"line\">小明的年龄10</span><br><span class=\"line\">析构函数</span><br><span class=\"line\">析构函数</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题-这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。\"><a href=\"#其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题-这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。\" class=\"headerlink\" title=\"其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题,这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。\"></a><strong>其实，拷不拷贝我们要认得类的成员变量有没有指针和引用，一般来说计算机会帮我们直接赋值的，深的拷贝构造函数的问题就是当我们第一次使用构造函数的时候，计算机会跟着自动调用析构函数，把我们之前定义的指针变量给销了，这也得不到我们程序想要的结果啊，不但没有走到我们想要的答案，反倒会给我们的程序报错，这就是个致命的问题,这是我们就只能去解救这个问题，所以我们要用到深的拷贝构造函数。其实在上面的的程序只是简单的想把t1的值赋给t2来间接的让t2有值。</strong></h2><h1 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;//因为要使用模板，所以在定义模板</span><br><span class=\"line\">class Apple&#123;</span><br><span class=\"line\">  friend ostream &amp;operator&lt;&lt;(ostream &amp;out,Apple &amp;a)&#123;//这里定义的是友元函数，用输出流来输出两个对象的相加</span><br><span class=\"line\">      out&lt;&lt;a.c&lt;&lt;&quot;+&quot;&lt;&lt;a.n&lt;&lt;endl;</span><br><span class=\"line\">      return out;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    T c;//泛性的成员变量</span><br><span class=\"line\">    T n;</span><br><span class=\"line\">    Apple(T _a,T_b)&#123;//构造函数</span><br><span class=\"line\">    this-&gt;c=_a;</span><br><span class=\"line\">    this-&gt;n=_b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Apple &lt;int&gt; operator+(Apple &amp;a)&#123;//这里调用的是类的构造函数来实现两个对象的相加并把相应的数值存放在本类的成员变量中。</span><br><span class=\"line\">    Apple addsum(this-&gt;c+a.c,this-&gt;n+a.n);</span><br><span class=\"line\">    return addsum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &quot;Apple.h&quot;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">     Apple &lt;int&gt;a(10,20); </span><br><span class=\"line\">     Apple &lt;int&gt;a1(20,30);</span><br><span class=\"line\">     Apple &lt;int&gt;c=a+a1;</span><br><span class=\"line\">     cout&lt;&lt;c&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">运行结果</span><br><span class=\"line\">30+50</span><br></pre></td></tr></table></figure>\n<p><strong>注意事项</strong> </p>\n<p><img src=\"/2019/06/12/C-Book/c-Book5.png\" alt=\"模板类\"> </p>"},{"title":"Noteslinux1","date":"2019-06-04T05:57:38.000Z","_content":"注释 <!--more--> # linux操作系统 > 操作系统:是一种软件，用来帮助其它的程序控制计算机硬件并和用户进行交互。 1. 应用程序也是一种软件，用来向计算机的用户提供某种服务，而不仅仅是控制计算机的硬件。 2. 操作系统的共同之处: * 引导计算机硬件，以便操作系统和其它软件程序可以正常工作。 * 为使用操作系统的程序分配系统资源，如内存处理时间。 * 跟踪同时运行的多个程序。 * 为所有使用系统设备的程序提供规范的访问借口。 3. 操作系统中主要的部分: * 内核:操作系统的核心，用来在多个应用程序之间分配计算机资源。 * 设备的驱动程序:是一个允许内核访问硬件设备(如键盘，鼠标，硬盘，扫描器或显卡)的软件 * shell:是一个可以通过用户输入的命令计算机进行处理的软件。 * 工具软件:管理软件和操作系统特性的软件。 * 图形用户界面:是一种软件，它是基于在鼠标这个接口之上的，用户可以通过这个接口在图形化应用程序可以使用菜单，* 按钮以及层叠窗口来进行操作。 * 完整的linux的系统: 1. 允许linux和外设一起工作的硬件驱动程序。 2. 图形化桌面坏境和管理操作系统的图形界面工具 3. 应用程序 4. 方便用户在计算机上安装所有linux文件的程序 5. 用于监视和配置系统功能的网络和系统管理工具。 ---- # 常用的linux命令 **因为我用的是manjaro-linux，不同的发行版所用到的命令是不一样的。这些在这里也没什么好说的，因为我也是一个小白。** **我觉得每个人的私密工作一定要做好，不然谁都可以顺起你的电脑造起来，这就不太好了。** \n* passwd (更换用户的密码)\n* su + 用户名 (切换用户)\n* passwd -l + 用户名  (锁定用户)\n* passwd -S + 用户名  (解锁)\n* sl--小骚(小火车)\n* cmatrix(代码)\n* ls--是查看当前目录的所有文件\n* df--查看硬盘的空间 参数(-k -m -g)\n* du -sh +目录 (查看目录的大小)\n* swapon (查看分区的大小)\n**在Linux里一却都是文件，我想这句话对我们来说都不陌生了。**\n* touch + 文件名 (创建文件)\n* rm + 文件名 (删除文件)\n* grep (在文件中查找你想查找的内容)-n +(文件名)\n* grep -vn + 文件名 (显示在文件里没要查找的内容) \n* -i(忽略大小写)\n* -n(输出匹配的行号)\n* -V(显示版本)\n* -v(显示没匹配的内容)\n* -o(只显示匹配的部分，不显示行号)\n* -c(显示匹配的行的个数)\n* -L(查询多文件时，只显示文件名)\n1. ^(一行开始的标志)^big{匹配以big开头的行}\n2. $(一行结束的标志)$big{匹配以big结束的行}\n3. ?(匹配任意一个字符)big?yet{在两个字符中间匹配任意一个字符}\n4. x\\{m\\}(重复x字符m次)x\\{5\\}匹配重复x字符5次的行\n5. x\\{m,\\}(至少m次x字符)x\\{5,\\}匹配5次以上x字符的行\n6. x\\{m,n\\}(m到n次的x字符)x\\{1,10\\}匹配1～10次x字符的行\n7. [a-g] (查找a~g的字符)\n* 格式   ---    grep \"^abc\" 文件名\n----\n# 管道符\n> echo\n1. echo \"你好帅啊“ > a   //把输出的文字写进a文件里\n2. man ls >>a          //把ls的手册以追加的形式写进a文件里\n3. 假如在主目录里没有b文件\n4. ls -l b 2> a         //把错误信息写进a文件里\n5. ls -l b 2>> a        //和上面的意思一样\n-----\n# 比较文件 \n> diff\n* -a (以文本的形式比较两个文件)\n* -q (只输出两个文件是否有差异，不输出其它)\n* -s (比较两个文件是否相同)\n* diff -u (可以把两个文件的比较内容)\n* test(123)        test1(123456)  \n//只是把test和test1文件的内容显示出来\n* diff -u test test1 > file        \n//把前面两个文件比较的内容写进file文件里\n* patch -b test file           \n//把以补丁的形式把原先缺少内容的test文件补回到我们想看的样子\n>> cmp\n**比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置**\n----\n* -l(显示两个比较文件每个不同点的字节号和字节数，前者十进制显示，后者八进制显示)\n* -s(不显示错误信息退出)\n* -v(显示版本信息)\n>>> comm\n* -1(显示文件1没有的内容)\n* -2(显示文件2没有的内容)\n* -3(文件1和文件2同时出现的内容不显示)\n* -12(显示两个文件有的内容)\n* -23(显示文件1有而文件2没有的内容)\n* -123(什么内容都不显示)\n**值得注意的是，comm比较的是排序的文件，显示出来的格式是以一行一行的形式输出的。**\n----\n# SHELL\n**脚本是用户成功登录系统后启动，并始终作为用户与系统内核的交互接口。**\n* 系统都有一个默认的脚本，我们也可以在终端用find /bin/sh*命令查看我们有那几种脚本。\n* 我们也可以自定义文件的权限，以便实现文件的内容，简单点说就是脚本编程，通过改变文件的权限来把文件的实现。\n# 基本目录的解析\n**基本上每台linux电脑都会有一个名为家的目录，在linux下的一切都是以文件的形式存放在目录下的，我们还可以通过更改文件的权限来把文件里的内容效果实现出来，这说的就有点远了，让我们回到刚刚的目录，我们都知道文件是存放在目录下面的，所以想想都知道目录的重要性了。**\n* / ---         根目录\n* bin/ ---   存放必要的命令\n* dev/ ---   存放设备文件\n* etc/ ---   存放配置文件\n* home/ ---   主目录(存放用户的数据)\n* lib/ ---    存放必要的库\n* mnt/ ---    存放挂载的目录(一般为空)\n* root/ ---   超级用户的主目录\n* proc/ ---   虚拟目录(内存的映射)\n* sbin/ ---   存放用户经常使用的命令\n* usr/ ---    存放应用程序和文件(内存最大的目录) \n----\n# 文件权限\n**权限分为数字权限和隐藏权限**\n1. 数字权限 ---- 关键字--- chmod\n* 权限分为可读，可写，可执行。数字表示分为4,2,1\n* chmod 777  +文件名   更改文件的权限\n2. 隐藏文件\n* 关键字 --- chattr\n![参数解析](Noteslinux1/chattr.png)\n* chattr +i 文件名\n* 查看的命令 ----   lsattr +文件名\n----\n# 查找文件的命令\n> find\n**最大范围的查找文件，你也可以用这个命令来查找任何你想找的文件**\n* 分为时间查找和文件大小查找和名字查找\n1. 比如自己建立一个测试目录并名为Test/\n2. 里面都是以t开头的文件名\n3. 我们就是在这个目录下查找这些子文件\n* find ./ -name t\\* -ls\n* -cmin -10(十分钟更改过的文件)\n* -ctime -10(十小时更改过的文件)\n* -amin -10(十分钟存取的文件)\n* -atime -10(十小时存取的文件)\n* -size +10k(查找大小为10k的文件)\n**这里的用到了转义字符，不然系统会给我们报错的信息**\n----\n>> whereis\n**用来看查找可执行程序和应用程序和手册**\n* -b(只查找二进制文件)\n* -B(在指定的目录下查找二进制文件)\n* -f(使用-B参数，用来终止最后的目录)\n* -u(查找不包含指定类型的文件)\n","source":"_posts/Noteslinux1.md","raw":"---\ntitle: Noteslinux1\ndate: 2019-06-04 13:57:38\ntags:\n     - Test\n---\n注释 <!--more--> # linux操作系统 > 操作系统:是一种软件，用来帮助其它的程序控制计算机硬件并和用户进行交互。 1. 应用程序也是一种软件，用来向计算机的用户提供某种服务，而不仅仅是控制计算机的硬件。 2. 操作系统的共同之处: * 引导计算机硬件，以便操作系统和其它软件程序可以正常工作。 * 为使用操作系统的程序分配系统资源，如内存处理时间。 * 跟踪同时运行的多个程序。 * 为所有使用系统设备的程序提供规范的访问借口。 3. 操作系统中主要的部分: * 内核:操作系统的核心，用来在多个应用程序之间分配计算机资源。 * 设备的驱动程序:是一个允许内核访问硬件设备(如键盘，鼠标，硬盘，扫描器或显卡)的软件 * shell:是一个可以通过用户输入的命令计算机进行处理的软件。 * 工具软件:管理软件和操作系统特性的软件。 * 图形用户界面:是一种软件，它是基于在鼠标这个接口之上的，用户可以通过这个接口在图形化应用程序可以使用菜单，* 按钮以及层叠窗口来进行操作。 * 完整的linux的系统: 1. 允许linux和外设一起工作的硬件驱动程序。 2. 图形化桌面坏境和管理操作系统的图形界面工具 3. 应用程序 4. 方便用户在计算机上安装所有linux文件的程序 5. 用于监视和配置系统功能的网络和系统管理工具。 ---- # 常用的linux命令 **因为我用的是manjaro-linux，不同的发行版所用到的命令是不一样的。这些在这里也没什么好说的，因为我也是一个小白。** **我觉得每个人的私密工作一定要做好，不然谁都可以顺起你的电脑造起来，这就不太好了。** \n* passwd (更换用户的密码)\n* su + 用户名 (切换用户)\n* passwd -l + 用户名  (锁定用户)\n* passwd -S + 用户名  (解锁)\n* sl--小骚(小火车)\n* cmatrix(代码)\n* ls--是查看当前目录的所有文件\n* df--查看硬盘的空间 参数(-k -m -g)\n* du -sh +目录 (查看目录的大小)\n* swapon (查看分区的大小)\n**在Linux里一却都是文件，我想这句话对我们来说都不陌生了。**\n* touch + 文件名 (创建文件)\n* rm + 文件名 (删除文件)\n* grep (在文件中查找你想查找的内容)-n +(文件名)\n* grep -vn + 文件名 (显示在文件里没要查找的内容) \n* -i(忽略大小写)\n* -n(输出匹配的行号)\n* -V(显示版本)\n* -v(显示没匹配的内容)\n* -o(只显示匹配的部分，不显示行号)\n* -c(显示匹配的行的个数)\n* -L(查询多文件时，只显示文件名)\n1. ^(一行开始的标志)^big{匹配以big开头的行}\n2. $(一行结束的标志)$big{匹配以big结束的行}\n3. ?(匹配任意一个字符)big?yet{在两个字符中间匹配任意一个字符}\n4. x\\{m\\}(重复x字符m次)x\\{5\\}匹配重复x字符5次的行\n5. x\\{m,\\}(至少m次x字符)x\\{5,\\}匹配5次以上x字符的行\n6. x\\{m,n\\}(m到n次的x字符)x\\{1,10\\}匹配1～10次x字符的行\n7. [a-g] (查找a~g的字符)\n* 格式   ---    grep \"^abc\" 文件名\n----\n# 管道符\n> echo\n1. echo \"你好帅啊“ > a   //把输出的文字写进a文件里\n2. man ls >>a          //把ls的手册以追加的形式写进a文件里\n3. 假如在主目录里没有b文件\n4. ls -l b 2> a         //把错误信息写进a文件里\n5. ls -l b 2>> a        //和上面的意思一样\n-----\n# 比较文件 \n> diff\n* -a (以文本的形式比较两个文件)\n* -q (只输出两个文件是否有差异，不输出其它)\n* -s (比较两个文件是否相同)\n* diff -u (可以把两个文件的比较内容)\n* test(123)        test1(123456)  \n//只是把test和test1文件的内容显示出来\n* diff -u test test1 > file        \n//把前面两个文件比较的内容写进file文件里\n* patch -b test file           \n//把以补丁的形式把原先缺少内容的test文件补回到我们想看的样子\n>> cmp\n**比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置**\n----\n* -l(显示两个比较文件每个不同点的字节号和字节数，前者十进制显示，后者八进制显示)\n* -s(不显示错误信息退出)\n* -v(显示版本信息)\n>>> comm\n* -1(显示文件1没有的内容)\n* -2(显示文件2没有的内容)\n* -3(文件1和文件2同时出现的内容不显示)\n* -12(显示两个文件有的内容)\n* -23(显示文件1有而文件2没有的内容)\n* -123(什么内容都不显示)\n**值得注意的是，comm比较的是排序的文件，显示出来的格式是以一行一行的形式输出的。**\n----\n# SHELL\n**脚本是用户成功登录系统后启动，并始终作为用户与系统内核的交互接口。**\n* 系统都有一个默认的脚本，我们也可以在终端用find /bin/sh*命令查看我们有那几种脚本。\n* 我们也可以自定义文件的权限，以便实现文件的内容，简单点说就是脚本编程，通过改变文件的权限来把文件的实现。\n# 基本目录的解析\n**基本上每台linux电脑都会有一个名为家的目录，在linux下的一切都是以文件的形式存放在目录下的，我们还可以通过更改文件的权限来把文件里的内容效果实现出来，这说的就有点远了，让我们回到刚刚的目录，我们都知道文件是存放在目录下面的，所以想想都知道目录的重要性了。**\n* / ---         根目录\n* bin/ ---   存放必要的命令\n* dev/ ---   存放设备文件\n* etc/ ---   存放配置文件\n* home/ ---   主目录(存放用户的数据)\n* lib/ ---    存放必要的库\n* mnt/ ---    存放挂载的目录(一般为空)\n* root/ ---   超级用户的主目录\n* proc/ ---   虚拟目录(内存的映射)\n* sbin/ ---   存放用户经常使用的命令\n* usr/ ---    存放应用程序和文件(内存最大的目录) \n----\n# 文件权限\n**权限分为数字权限和隐藏权限**\n1. 数字权限 ---- 关键字--- chmod\n* 权限分为可读，可写，可执行。数字表示分为4,2,1\n* chmod 777  +文件名   更改文件的权限\n2. 隐藏文件\n* 关键字 --- chattr\n![参数解析](Noteslinux1/chattr.png)\n* chattr +i 文件名\n* 查看的命令 ----   lsattr +文件名\n----\n# 查找文件的命令\n> find\n**最大范围的查找文件，你也可以用这个命令来查找任何你想找的文件**\n* 分为时间查找和文件大小查找和名字查找\n1. 比如自己建立一个测试目录并名为Test/\n2. 里面都是以t开头的文件名\n3. 我们就是在这个目录下查找这些子文件\n* find ./ -name t\\* -ls\n* -cmin -10(十分钟更改过的文件)\n* -ctime -10(十小时更改过的文件)\n* -amin -10(十分钟存取的文件)\n* -atime -10(十小时存取的文件)\n* -size +10k(查找大小为10k的文件)\n**这里的用到了转义字符，不然系统会给我们报错的信息**\n----\n>> whereis\n**用来看查找可执行程序和应用程序和手册**\n* -b(只查找二进制文件)\n* -B(在指定的目录下查找二进制文件)\n* -f(使用-B参数，用来终止最后的目录)\n* -u(查找不包含指定类型的文件)\n","slug":"Noteslinux1","published":1,"updated":"2019-09-18T11:16:35.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7qw00054ez7y28w5syg","content":"<p>注释 <a id=\"more\"></a> # linux操作系统 &gt; 操作系统:是一种软件，用来帮助其它的程序控制计算机硬件并和用户进行交互。 1. 应用程序也是一种软件，用来向计算机的用户提供某种服务，而不仅仅是控制计算机的硬件。 2. 操作系统的共同之处: <em> 引导计算机硬件，以便操作系统和其它软件程序可以正常工作。 </em> 为使用操作系统的程序分配系统资源，如内存处理时间。 <em> 跟踪同时运行的多个程序。 </em> 为所有使用系统设备的程序提供规范的访问借口。 3. 操作系统中主要的部分: <em> 内核:操作系统的核心，用来在多个应用程序之间分配计算机资源。 </em> 设备的驱动程序:是一个允许内核访问硬件设备(如键盘，鼠标，硬盘，扫描器或显卡)的软件 <em> shell:是一个可以通过用户输入的命令计算机进行处理的软件。 </em> 工具软件:管理软件和操作系统特性的软件。 <em> 图形用户界面:是一种软件，它是基于在鼠标这个接口之上的，用户可以通过这个接口在图形化应用程序可以使用菜单，</em> 按钮以及层叠窗口来进行操作。 * 完整的linux的系统: 1. 允许linux和外设一起工作的硬件驱动程序。 2. 图形化桌面坏境和管理操作系统的图形界面工具 3. 应用程序 4. 方便用户在计算机上安装所有linux文件的程序 5. 用于监视和配置系统功能的网络和系统管理工具。 —- # 常用的linux命令 <strong>因为我用的是manjaro-linux，不同的发行版所用到的命令是不一样的。这些在这里也没什么好说的，因为我也是一个小白。</strong> <strong>我觉得每个人的私密工作一定要做好，不然谁都可以顺起你的电脑造起来，这就不太好了。</strong> </p>\n<ul>\n<li>passwd (更换用户的密码)</li>\n<li>su + 用户名 (切换用户)</li>\n<li>passwd -l + 用户名  (锁定用户)</li>\n<li>passwd -S + 用户名  (解锁)</li>\n<li>sl–小骚(小火车)</li>\n<li>cmatrix(代码)</li>\n<li>ls–是查看当前目录的所有文件</li>\n<li>df–查看硬盘的空间 参数(-k -m -g)</li>\n<li>du -sh +目录 (查看目录的大小)</li>\n<li>swapon (查看分区的大小)<br><strong>在Linux里一却都是文件，我想这句话对我们来说都不陌生了。</strong></li>\n<li>touch + 文件名 (创建文件)</li>\n<li>rm + 文件名 (删除文件)</li>\n<li>grep (在文件中查找你想查找的内容)-n +(文件名)</li>\n<li>grep -vn + 文件名 (显示在文件里没要查找的内容) </li>\n<li>-i(忽略大小写)</li>\n<li>-n(输出匹配的行号)</li>\n<li>-V(显示版本)</li>\n<li>-v(显示没匹配的内容)</li>\n<li>-o(只显示匹配的部分，不显示行号)</li>\n<li>-c(显示匹配的行的个数)</li>\n<li>-L(查询多文件时，只显示文件名)</li>\n</ul>\n<ol>\n<li>^(一行开始的标志)^big{匹配以big开头的行}</li>\n<li>$(一行结束的标志)$big{匹配以big结束的行}</li>\n<li>?(匹配任意一个字符)big?yet{在两个字符中间匹配任意一个字符}</li>\n<li>x{m}(重复x字符m次)x{5}匹配重复x字符5次的行</li>\n<li>x{m,}(至少m次x字符)x{5,}匹配5次以上x字符的行</li>\n<li>x{m,n}(m到n次的x字符)x{1,10}匹配1～10次x字符的行</li>\n<li>[a-g] (查找a~g的字符)</li>\n</ol>\n<ul>\n<li>格式   —    grep “^abc” 文件名</li>\n</ul>\n<hr>\n<h1 id=\"管道符\"><a href=\"#管道符\" class=\"headerlink\" title=\"管道符\"></a>管道符</h1><blockquote>\n<p>echo</p>\n<ol>\n<li>echo “你好帅啊“ &gt; a   //把输出的文字写进a文件里</li>\n<li>man ls &gt;&gt;a          //把ls的手册以追加的形式写进a文件里</li>\n<li>假如在主目录里没有b文件</li>\n<li>ls -l b 2&gt; a         //把错误信息写进a文件里</li>\n</ol>\n</blockquote>\n<ol start=\"5\">\n<li>ls -l b 2&gt;&gt; a        //和上面的意思一样</li>\n</ol>\n<hr>\n<h1 id=\"比较文件\"><a href=\"#比较文件\" class=\"headerlink\" title=\"比较文件\"></a>比较文件</h1><blockquote>\n<p>diff</p>\n<ul>\n<li>-a (以文本的形式比较两个文件)</li>\n<li>-q (只输出两个文件是否有差异，不输出其它)</li>\n<li>-s (比较两个文件是否相同)</li>\n<li>diff -u (可以把两个文件的比较内容)</li>\n<li>test(123)        test1(123456)<br>//只是把test和test1文件的内容显示出来</li>\n<li>diff -u test test1 &gt; file<br>//把前面两个文件比较的内容写进file文件里</li>\n<li>patch -b test file<br>//把以补丁的形式把原先缺少内容的test文件补回到我们想看的样子<blockquote>\n<p>cmp</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置\"><a href=\"#比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置\" class=\"headerlink\" title=\"比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置\"></a><strong>比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置</strong></h2><ul>\n<li>-l(显示两个比较文件每个不同点的字节号和字节数，前者十进制显示，后者八进制显示)</li>\n<li>-s(不显示错误信息退出)</li>\n<li>-v(显示版本信息)<blockquote>\n<blockquote>\n<blockquote>\n<p>comm</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li>-1(显示文件1没有的内容)</li>\n<li>-2(显示文件2没有的内容)</li>\n<li>-3(文件1和文件2同时出现的内容不显示)</li>\n<li>-12(显示两个文件有的内容)</li>\n<li>-23(显示文件1有而文件2没有的内容)</li>\n<li>-123(什么内容都不显示)<br><strong>值得注意的是，comm比较的是排序的文件，显示出来的格式是以一行一行的形式输出的。</strong></li>\n</ul>\n<hr>\n<h1 id=\"SHELL\"><a href=\"#SHELL\" class=\"headerlink\" title=\"SHELL\"></a>SHELL</h1><p><strong>脚本是用户成功登录系统后启动，并始终作为用户与系统内核的交互接口。</strong></p>\n<ul>\n<li>系统都有一个默认的脚本，我们也可以在终端用find /bin/sh*命令查看我们有那几种脚本。</li>\n<li>我们也可以自定义文件的权限，以便实现文件的内容，简单点说就是脚本编程，通过改变文件的权限来把文件的实现。<h1 id=\"基本目录的解析\"><a href=\"#基本目录的解析\" class=\"headerlink\" title=\"基本目录的解析\"></a>基本目录的解析</h1><strong>基本上每台linux电脑都会有一个名为家的目录，在linux下的一切都是以文件的形式存放在目录下的，我们还可以通过更改文件的权限来把文件里的内容效果实现出来，这说的就有点远了，让我们回到刚刚的目录，我们都知道文件是存放在目录下面的，所以想想都知道目录的重要性了。</strong></li>\n<li>/ —         根目录</li>\n<li>bin/ —   存放必要的命令</li>\n<li>dev/ —   存放设备文件</li>\n<li>etc/ —   存放配置文件</li>\n<li>home/ —   主目录(存放用户的数据)</li>\n<li>lib/ —    存放必要的库</li>\n<li>mnt/ —    存放挂载的目录(一般为空)</li>\n<li>root/ —   超级用户的主目录</li>\n<li>proc/ —   虚拟目录(内存的映射)</li>\n<li>sbin/ —   存放用户经常使用的命令</li>\n<li>usr/ —    存放应用程序和文件(内存最大的目录) </li>\n</ul>\n<hr>\n<h1 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h1><p><strong>权限分为数字权限和隐藏权限</strong></p>\n<ol>\n<li>数字权限 —- 关键字— chmod</li>\n</ol>\n<ul>\n<li>权限分为可读，可写，可执行。数字表示分为4,2,1</li>\n<li>chmod 777  +文件名   更改文件的权限</li>\n</ul>\n<ol start=\"2\">\n<li>隐藏文件</li>\n</ol>\n<ul>\n<li>关键字 — chattr<br><img src=\"/2019/06/04/Noteslinux1/chattr.png\" alt=\"参数解析\"></li>\n<li>chattr +i 文件名</li>\n<li>查看的命令 —-   lsattr +文件名</li>\n</ul>\n<hr>\n<h1 id=\"查找文件的命令\"><a href=\"#查找文件的命令\" class=\"headerlink\" title=\"查找文件的命令\"></a>查找文件的命令</h1><blockquote>\n<p>find<br><strong>最大范围的查找文件，你也可以用这个命令来查找任何你想找的文件</strong></p>\n<ul>\n<li>分为时间查找和文件大小查找和名字查找</li>\n</ul>\n<ol>\n<li>比如自己建立一个测试目录并名为Test/</li>\n<li>里面都是以t开头的文件名</li>\n<li>我们就是在这个目录下查找这些子文件</li>\n</ol>\n<ul>\n<li>find ./ -name t* -ls</li>\n<li>-cmin -10(十分钟更改过的文件)</li>\n<li>-ctime -10(十小时更改过的文件)</li>\n<li>-amin -10(十分钟存取的文件)</li>\n<li>-atime -10(十小时存取的文件)</li>\n<li>-size +10k(查找大小为10k的文件)</li>\n</ul>\n</blockquote>\n<h2 id=\"这里的用到了转义字符，不然系统会给我们报错的信息\"><a href=\"#这里的用到了转义字符，不然系统会给我们报错的信息\" class=\"headerlink\" title=\"这里的用到了转义字符，不然系统会给我们报错的信息\"></a><strong>这里的用到了转义字符，不然系统会给我们报错的信息</strong></h2><blockquote>\n<blockquote>\n<p>whereis<br><strong>用来看查找可执行程序和应用程序和手册</strong></p>\n<ul>\n<li>-b(只查找二进制文件)</li>\n<li>-B(在指定的目录下查找二进制文件)</li>\n<li>-f(使用-B参数，用来终止最后的目录)</li>\n<li>-u(查找不包含指定类型的文件)</li>\n</ul>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>注释</p>","more":"# linux操作系统 &gt; 操作系统:是一种软件，用来帮助其它的程序控制计算机硬件并和用户进行交互。 1. 应用程序也是一种软件，用来向计算机的用户提供某种服务，而不仅仅是控制计算机的硬件。 2. 操作系统的共同之处: <em> 引导计算机硬件，以便操作系统和其它软件程序可以正常工作。 </em> 为使用操作系统的程序分配系统资源，如内存处理时间。 <em> 跟踪同时运行的多个程序。 </em> 为所有使用系统设备的程序提供规范的访问借口。 3. 操作系统中主要的部分: <em> 内核:操作系统的核心，用来在多个应用程序之间分配计算机资源。 </em> 设备的驱动程序:是一个允许内核访问硬件设备(如键盘，鼠标，硬盘，扫描器或显卡)的软件 <em> shell:是一个可以通过用户输入的命令计算机进行处理的软件。 </em> 工具软件:管理软件和操作系统特性的软件。 <em> 图形用户界面:是一种软件，它是基于在鼠标这个接口之上的，用户可以通过这个接口在图形化应用程序可以使用菜单，</em> 按钮以及层叠窗口来进行操作。 * 完整的linux的系统: 1. 允许linux和外设一起工作的硬件驱动程序。 2. 图形化桌面坏境和管理操作系统的图形界面工具 3. 应用程序 4. 方便用户在计算机上安装所有linux文件的程序 5. 用于监视和配置系统功能的网络和系统管理工具。 —- # 常用的linux命令 <strong>因为我用的是manjaro-linux，不同的发行版所用到的命令是不一样的。这些在这里也没什么好说的，因为我也是一个小白。</strong> <strong>我觉得每个人的私密工作一定要做好，不然谁都可以顺起你的电脑造起来，这就不太好了。</strong> <p></p>\n<ul>\n<li>passwd (更换用户的密码)</li>\n<li>su + 用户名 (切换用户)</li>\n<li>passwd -l + 用户名  (锁定用户)</li>\n<li>passwd -S + 用户名  (解锁)</li>\n<li>sl–小骚(小火车)</li>\n<li>cmatrix(代码)</li>\n<li>ls–是查看当前目录的所有文件</li>\n<li>df–查看硬盘的空间 参数(-k -m -g)</li>\n<li>du -sh +目录 (查看目录的大小)</li>\n<li>swapon (查看分区的大小)<br><strong>在Linux里一却都是文件，我想这句话对我们来说都不陌生了。</strong></li>\n<li>touch + 文件名 (创建文件)</li>\n<li>rm + 文件名 (删除文件)</li>\n<li>grep (在文件中查找你想查找的内容)-n +(文件名)</li>\n<li>grep -vn + 文件名 (显示在文件里没要查找的内容) </li>\n<li>-i(忽略大小写)</li>\n<li>-n(输出匹配的行号)</li>\n<li>-V(显示版本)</li>\n<li>-v(显示没匹配的内容)</li>\n<li>-o(只显示匹配的部分，不显示行号)</li>\n<li>-c(显示匹配的行的个数)</li>\n<li>-L(查询多文件时，只显示文件名)</li>\n</ul>\n<ol>\n<li>^(一行开始的标志)^big{匹配以big开头的行}</li>\n<li>$(一行结束的标志)$big{匹配以big结束的行}</li>\n<li>?(匹配任意一个字符)big?yet{在两个字符中间匹配任意一个字符}</li>\n<li>x{m}(重复x字符m次)x{5}匹配重复x字符5次的行</li>\n<li>x{m,}(至少m次x字符)x{5,}匹配5次以上x字符的行</li>\n<li>x{m,n}(m到n次的x字符)x{1,10}匹配1～10次x字符的行</li>\n<li>[a-g] (查找a~g的字符)</li>\n</ol>\n<ul>\n<li>格式   —    grep “^abc” 文件名</li>\n</ul>\n<hr>\n<h1 id=\"管道符\"><a href=\"#管道符\" class=\"headerlink\" title=\"管道符\"></a>管道符</h1><blockquote>\n<p>echo</p>\n<ol>\n<li>echo “你好帅啊“ &gt; a   //把输出的文字写进a文件里</li>\n<li>man ls &gt;&gt;a          //把ls的手册以追加的形式写进a文件里</li>\n<li>假如在主目录里没有b文件</li>\n<li>ls -l b 2&gt; a         //把错误信息写进a文件里</li>\n</ol>\n</blockquote>\n<ol start=\"5\">\n<li>ls -l b 2&gt;&gt; a        //和上面的意思一样</li>\n</ol>\n<hr>\n<h1 id=\"比较文件\"><a href=\"#比较文件\" class=\"headerlink\" title=\"比较文件\"></a>比较文件</h1><blockquote>\n<p>diff</p>\n<ul>\n<li>-a (以文本的形式比较两个文件)</li>\n<li>-q (只输出两个文件是否有差异，不输出其它)</li>\n<li>-s (比较两个文件是否相同)</li>\n<li>diff -u (可以把两个文件的比较内容)</li>\n<li>test(123)        test1(123456)<br>//只是把test和test1文件的内容显示出来</li>\n<li>diff -u test test1 &gt; file<br>//把前面两个文件比较的内容写进file文件里</li>\n<li>patch -b test file<br>//把以补丁的形式把原先缺少内容的test文件补回到我们想看的样子<blockquote>\n<p>cmp</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置\"><a href=\"#比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置\" class=\"headerlink\" title=\"比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置\"></a><strong>比较文件的命令，但一般用来比较文本文件，判断两个文件的不同之处，以及查看不同之处的位置</strong></h2><ul>\n<li>-l(显示两个比较文件每个不同点的字节号和字节数，前者十进制显示，后者八进制显示)</li>\n<li>-s(不显示错误信息退出)</li>\n<li>-v(显示版本信息)<blockquote>\n<blockquote>\n<blockquote>\n<p>comm</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li>-1(显示文件1没有的内容)</li>\n<li>-2(显示文件2没有的内容)</li>\n<li>-3(文件1和文件2同时出现的内容不显示)</li>\n<li>-12(显示两个文件有的内容)</li>\n<li>-23(显示文件1有而文件2没有的内容)</li>\n<li>-123(什么内容都不显示)<br><strong>值得注意的是，comm比较的是排序的文件，显示出来的格式是以一行一行的形式输出的。</strong></li>\n</ul>\n<hr>\n<h1 id=\"SHELL\"><a href=\"#SHELL\" class=\"headerlink\" title=\"SHELL\"></a>SHELL</h1><p><strong>脚本是用户成功登录系统后启动，并始终作为用户与系统内核的交互接口。</strong></p>\n<ul>\n<li>系统都有一个默认的脚本，我们也可以在终端用find /bin/sh*命令查看我们有那几种脚本。</li>\n<li>我们也可以自定义文件的权限，以便实现文件的内容，简单点说就是脚本编程，通过改变文件的权限来把文件的实现。<h1 id=\"基本目录的解析\"><a href=\"#基本目录的解析\" class=\"headerlink\" title=\"基本目录的解析\"></a>基本目录的解析</h1><strong>基本上每台linux电脑都会有一个名为家的目录，在linux下的一切都是以文件的形式存放在目录下的，我们还可以通过更改文件的权限来把文件里的内容效果实现出来，这说的就有点远了，让我们回到刚刚的目录，我们都知道文件是存放在目录下面的，所以想想都知道目录的重要性了。</strong></li>\n<li>/ —         根目录</li>\n<li>bin/ —   存放必要的命令</li>\n<li>dev/ —   存放设备文件</li>\n<li>etc/ —   存放配置文件</li>\n<li>home/ —   主目录(存放用户的数据)</li>\n<li>lib/ —    存放必要的库</li>\n<li>mnt/ —    存放挂载的目录(一般为空)</li>\n<li>root/ —   超级用户的主目录</li>\n<li>proc/ —   虚拟目录(内存的映射)</li>\n<li>sbin/ —   存放用户经常使用的命令</li>\n<li>usr/ —    存放应用程序和文件(内存最大的目录) </li>\n</ul>\n<hr>\n<h1 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h1><p><strong>权限分为数字权限和隐藏权限</strong></p>\n<ol>\n<li>数字权限 —- 关键字— chmod</li>\n</ol>\n<ul>\n<li>权限分为可读，可写，可执行。数字表示分为4,2,1</li>\n<li>chmod 777  +文件名   更改文件的权限</li>\n</ul>\n<ol start=\"2\">\n<li>隐藏文件</li>\n</ol>\n<ul>\n<li>关键字 — chattr<br><img src=\"/2019/06/04/Noteslinux1/chattr.png\" alt=\"参数解析\"></li>\n<li>chattr +i 文件名</li>\n<li>查看的命令 —-   lsattr +文件名</li>\n</ul>\n<hr>\n<h1 id=\"查找文件的命令\"><a href=\"#查找文件的命令\" class=\"headerlink\" title=\"查找文件的命令\"></a>查找文件的命令</h1><blockquote>\n<p>find<br><strong>最大范围的查找文件，你也可以用这个命令来查找任何你想找的文件</strong></p>\n<ul>\n<li>分为时间查找和文件大小查找和名字查找</li>\n</ul>\n<ol>\n<li>比如自己建立一个测试目录并名为Test/</li>\n<li>里面都是以t开头的文件名</li>\n<li>我们就是在这个目录下查找这些子文件</li>\n</ol>\n<ul>\n<li>find ./ -name t* -ls</li>\n<li>-cmin -10(十分钟更改过的文件)</li>\n<li>-ctime -10(十小时更改过的文件)</li>\n<li>-amin -10(十分钟存取的文件)</li>\n<li>-atime -10(十小时存取的文件)</li>\n<li>-size +10k(查找大小为10k的文件)</li>\n</ul>\n</blockquote>\n<h2 id=\"这里的用到了转义字符，不然系统会给我们报错的信息\"><a href=\"#这里的用到了转义字符，不然系统会给我们报错的信息\" class=\"headerlink\" title=\"这里的用到了转义字符，不然系统会给我们报错的信息\"></a><strong>这里的用到了转义字符，不然系统会给我们报错的信息</strong></h2><blockquote>\n<blockquote>\n<p>whereis<br><strong>用来看查找可执行程序和应用程序和手册</strong></p>\n<ul>\n<li>-b(只查找二进制文件)</li>\n<li>-B(在指定的目录下查找二进制文件)</li>\n<li>-f(使用-B参数，用来终止最后的目录)</li>\n<li>-u(查找不包含指定类型的文件)</li>\n</ul>\n</blockquote>\n</blockquote>"},{"title":"c++Notes","date":"2019-05-21T07:13:50.000Z","_content":"      类\n<!--more-->\n\n\n# 关于类的一些理解\n----\n> 1:类是面对对象的编程，它是以对象为基本来进行编程的。这样的说法就是安慰一些我们这些编程人也可以每天面对对象，仅此而已。\n### 2:类有三种特性：封装,继承,多态。\n>> 类的封装，其实就是把成员变量设为私有的，也就是隐藏起来，然后再用方法/函数来实现你想要的结果。在类里面用set来进行封装，用get来返回。\n\n----\n# 类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！\n**这里是用指针来new了一个空间，使用访问的时候也要用访问指针的方法来访问它，“->”**\n![main](c-Notes/YC4.png)\n![程序结果](c-Notes/YC5.png)\n\n----\n# this指针，它可以访问类里面的所有成员变量和函数，（this->加成员变量/成员函数）\n----\n> 构造函数也可以叫做重载函数，它的作用是初始化类的成员变量。\n>> 构造函数分为无参构造和有参构造；其实还有一个拷贝构造。\n1. 无参构造函数，也叫默认构造函数，随你喜欢。还有就是，无参构造函数是计算机自动调用的，就算你没调用它，计算机也会自动帮你调用。\n\n![无参构造函数](c-Notes/WC.png)\n\n----\n2. 有参构造函数，其实就是带参数的函数。\n\n![有参构造](c-Notes/YC.png)\n\n>>> 类里面的构造函数都是可以和show方法一起连用的，这样就可以看到构造函数无，有参之间的变化。\n\n![show](c-Notes/YC3.png)\n\n----\n\n![main函数](c-Notes/YC1.png)\n\n----\n![程序结果](c-Notes/YC2.png)\n\n----\n# 析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。\n","source":"_posts/c-Notes.md","raw":"---\ntitle: c++Notes\ndate: 2019-05-21 15:13:50\ntags:\n---\n      类\n<!--more-->\n\n\n# 关于类的一些理解\n----\n> 1:类是面对对象的编程，它是以对象为基本来进行编程的。这样的说法就是安慰一些我们这些编程人也可以每天面对对象，仅此而已。\n### 2:类有三种特性：封装,继承,多态。\n>> 类的封装，其实就是把成员变量设为私有的，也就是隐藏起来，然后再用方法/函数来实现你想要的结果。在类里面用set来进行封装，用get来返回。\n\n----\n# 类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！\n**这里是用指针来new了一个空间，使用访问的时候也要用访问指针的方法来访问它，“->”**\n![main](c-Notes/YC4.png)\n![程序结果](c-Notes/YC5.png)\n\n----\n# this指针，它可以访问类里面的所有成员变量和函数，（this->加成员变量/成员函数）\n----\n> 构造函数也可以叫做重载函数，它的作用是初始化类的成员变量。\n>> 构造函数分为无参构造和有参构造；其实还有一个拷贝构造。\n1. 无参构造函数，也叫默认构造函数，随你喜欢。还有就是，无参构造函数是计算机自动调用的，就算你没调用它，计算机也会自动帮你调用。\n\n![无参构造函数](c-Notes/WC.png)\n\n----\n2. 有参构造函数，其实就是带参数的函数。\n\n![有参构造](c-Notes/YC.png)\n\n>>> 类里面的构造函数都是可以和show方法一起连用的，这样就可以看到构造函数无，有参之间的变化。\n\n![show](c-Notes/YC3.png)\n\n----\n\n![main函数](c-Notes/YC1.png)\n\n----\n![程序结果](c-Notes/YC2.png)\n\n----\n# 析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。\n","slug":"c-Notes","published":1,"updated":"2019-09-12T07:19:33.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7r100064ez70vb1pub5","content":"<pre><code>类\n</code></pre><a id=\"more\"></a>\n<h1 id=\"关于类的一些理解\"><a href=\"#关于类的一些理解\" class=\"headerlink\" title=\"关于类的一些理解\"></a>关于类的一些理解</h1><hr>\n<blockquote>\n<p>1:类是面对对象的编程，它是以对象为基本来进行编程的。这样的说法就是安慰一些我们这些编程人也可以每天面对对象，仅此而已。</p>\n</blockquote>\n<h3 id=\"2-类有三种特性：封装-继承-多态。\"><a href=\"#2-类有三种特性：封装-继承-多态。\" class=\"headerlink\" title=\"2:类有三种特性：封装,继承,多态。\"></a>2:类有三种特性：封装,继承,多态。</h3><blockquote>\n<blockquote>\n<p>类的封装，其实就是把成员变量设为私有的，也就是隐藏起来，然后再用方法/函数来实现你想要的结果。在类里面用set来进行封装，用get来返回。</p>\n</blockquote>\n</blockquote>\n<hr>\n<h1 id=\"类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！\"><a href=\"#类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！\" class=\"headerlink\" title=\"类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！\"></a>类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！</h1><p><strong>这里是用指针来new了一个空间，使用访问的时候也要用访问指针的方法来访问它，“-&gt;”</strong><br><img src=\"/2019/05/21/c-Notes/YC4.png\" alt=\"main\"><br><img src=\"/2019/05/21/c-Notes/YC5.png\" alt=\"程序结果\"></p>\n<hr>\n<h1 id=\"this指针，它可以访问类里面的所有成员变量和函数，（this-gt-加成员变量-成员函数）\"><a href=\"#this指针，它可以访问类里面的所有成员变量和函数，（this-gt-加成员变量-成员函数）\" class=\"headerlink\" title=\"this指针，它可以访问类里面的所有成员变量和函数，（this-&gt;加成员变量/成员函数）\"></a>this指针，它可以访问类里面的所有成员变量和函数，（this-&gt;加成员变量/成员函数）</h1><hr>\n<blockquote>\n<p>构造函数也可以叫做重载函数，它的作用是初始化类的成员变量。</p>\n<blockquote>\n<p>构造函数分为无参构造和有参构造；其实还有一个拷贝构造。</p>\n<ol>\n<li>无参构造函数，也叫默认构造函数，随你喜欢。还有就是，无参构造函数是计算机自动调用的，就算你没调用它，计算机也会自动帮你调用。</li>\n</ol>\n</blockquote>\n</blockquote>\n<p><img src=\"/2019/05/21/c-Notes/WC.png\" alt=\"无参构造函数\"></p>\n<hr>\n<ol start=\"2\">\n<li>有参构造函数，其实就是带参数的函数。</li>\n</ol>\n<p><img src=\"/2019/05/21/c-Notes/YC.png\" alt=\"有参构造\"></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>类里面的构造函数都是可以和show方法一起连用的，这样就可以看到构造函数无，有参之间的变化。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><img src=\"/2019/05/21/c-Notes/YC3.png\" alt=\"show\"></p>\n<hr>\n<p><img src=\"/2019/05/21/c-Notes/YC1.png\" alt=\"main函数\"></p>\n<hr>\n<p><img src=\"/2019/05/21/c-Notes/YC2.png\" alt=\"程序结果\"></p>\n<hr>\n<h1 id=\"析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。\"><a href=\"#析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。\" class=\"headerlink\" title=\"析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。\"></a>析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。</h1>","site":{"data":{}},"excerpt":"<pre><code>类\n</code></pre>","more":"<h1 id=\"关于类的一些理解\"><a href=\"#关于类的一些理解\" class=\"headerlink\" title=\"关于类的一些理解\"></a>关于类的一些理解</h1><hr>\n<blockquote>\n<p>1:类是面对对象的编程，它是以对象为基本来进行编程的。这样的说法就是安慰一些我们这些编程人也可以每天面对对象，仅此而已。</p>\n</blockquote>\n<h3 id=\"2-类有三种特性：封装-继承-多态。\"><a href=\"#2-类有三种特性：封装-继承-多态。\" class=\"headerlink\" title=\"2:类有三种特性：封装,继承,多态。\"></a>2:类有三种特性：封装,继承,多态。</h3><blockquote>\n<blockquote>\n<p>类的封装，其实就是把成员变量设为私有的，也就是隐藏起来，然后再用方法/函数来实现你想要的结果。在类里面用set来进行封装，用get来返回。</p>\n</blockquote>\n</blockquote>\n<hr>\n<h1 id=\"类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！\"><a href=\"#类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！\" class=\"headerlink\" title=\"类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！\"></a>类还可以用指针来实现。用new在堆内存里申请一个空间，记得要用delete来释放空间！！！</h1><p><strong>这里是用指针来new了一个空间，使用访问的时候也要用访问指针的方法来访问它，“-&gt;”</strong><br><img src=\"/2019/05/21/c-Notes/YC4.png\" alt=\"main\"><br><img src=\"/2019/05/21/c-Notes/YC5.png\" alt=\"程序结果\"></p>\n<hr>\n<h1 id=\"this指针，它可以访问类里面的所有成员变量和函数，（this-gt-加成员变量-成员函数）\"><a href=\"#this指针，它可以访问类里面的所有成员变量和函数，（this-gt-加成员变量-成员函数）\" class=\"headerlink\" title=\"this指针，它可以访问类里面的所有成员变量和函数，（this-&gt;加成员变量/成员函数）\"></a>this指针，它可以访问类里面的所有成员变量和函数，（this-&gt;加成员变量/成员函数）</h1><hr>\n<blockquote>\n<p>构造函数也可以叫做重载函数，它的作用是初始化类的成员变量。</p>\n<blockquote>\n<p>构造函数分为无参构造和有参构造；其实还有一个拷贝构造。</p>\n<ol>\n<li>无参构造函数，也叫默认构造函数，随你喜欢。还有就是，无参构造函数是计算机自动调用的，就算你没调用它，计算机也会自动帮你调用。</li>\n</ol>\n</blockquote>\n</blockquote>\n<p><img src=\"/2019/05/21/c-Notes/WC.png\" alt=\"无参构造函数\"></p>\n<hr>\n<ol start=\"2\">\n<li>有参构造函数，其实就是带参数的函数。</li>\n</ol>\n<p><img src=\"/2019/05/21/c-Notes/YC.png\" alt=\"有参构造\"></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>类里面的构造函数都是可以和show方法一起连用的，这样就可以看到构造函数无，有参之间的变化。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><img src=\"/2019/05/21/c-Notes/YC3.png\" alt=\"show\"></p>\n<hr>\n<p><img src=\"/2019/05/21/c-Notes/YC1.png\" alt=\"main函数\"></p>\n<hr>\n<p><img src=\"/2019/05/21/c-Notes/YC2.png\" alt=\"程序结果\"></p>\n<hr>\n<h1 id=\"析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。\"><a href=\"#析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。\" class=\"headerlink\" title=\"析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。\"></a>析构函数其实是释放为指针成员变量的。比如你用指针new了一个新的成员变量，那在你程序完以后你得要释放它吧，总不能让它成为我们所畏惧的野指针，这时你就可以在析构函数里释放。</h1>"},{"title":"constellation","date":"2019-06-19T11:09:20.000Z","_content":"         星座\n<!--more-->\n\n# 星座\n* 根据输入的生日日期来输出星座\n```\n#include<iostream>\nusing namespace std;\nint main(){\n    int a(0),b(0);\n    string conste[12][2]{//把十二个星座按照月份放进数组里\n        {\"魔蟹座\",\"水瓶座\"},\n        {\"水瓶座\",\"双鱼座\"},\n        {\"双鱼座\",\"白羊座\"},\n        {\"白羊座\",\"金牛座\"},\n        {\"金牛座\",\"双子座\"},\n        {\"双子座\",\"巨蟹座\"},\n        {\"巨蟹座\",\"狮子座\"},\n        {\"狮子座\",\"处女座\"},\n        {\"处女座\",\"天秤座\"},\n        {\"天秤座\",\"天蝎座\"},\n        {\"天蝎座\",\"射手座\"},\n        {\"射手座\",\"魔蟹座\"},\n    };\n    int constel[]{20,19,21,20,21,22,23,23,23,24,23,22};\n    //把所有星座的转换日期放进数组里\n    cout<<\"请输入你生日的月份：\"<<endl;\n    cin>>a;\n    cout<<\"请输入你生日的日期：\"<<endl;\n    cin>>b;\n    cout<<\"你的星座是：\"<<conset[a-1][b/consetl[a-1]]<<endl;\n}\n```\n**这只是简单的打印星座，思路是，先把十二星座按照月份写进一个二位数组里面，然后再把每个星座的转换日期写进另外一个数组里，用输入的生日的几号来处以星座转换日期，得到的0为当前月份的前者，得到1为当前月份的后者。**\n","source":"_posts/constellation.md","raw":"---\ntitle: constellation\ndate: 2019-06-19 19:09:20\ntags:\n---\n         星座\n<!--more-->\n\n# 星座\n* 根据输入的生日日期来输出星座\n```\n#include<iostream>\nusing namespace std;\nint main(){\n    int a(0),b(0);\n    string conste[12][2]{//把十二个星座按照月份放进数组里\n        {\"魔蟹座\",\"水瓶座\"},\n        {\"水瓶座\",\"双鱼座\"},\n        {\"双鱼座\",\"白羊座\"},\n        {\"白羊座\",\"金牛座\"},\n        {\"金牛座\",\"双子座\"},\n        {\"双子座\",\"巨蟹座\"},\n        {\"巨蟹座\",\"狮子座\"},\n        {\"狮子座\",\"处女座\"},\n        {\"处女座\",\"天秤座\"},\n        {\"天秤座\",\"天蝎座\"},\n        {\"天蝎座\",\"射手座\"},\n        {\"射手座\",\"魔蟹座\"},\n    };\n    int constel[]{20,19,21,20,21,22,23,23,23,24,23,22};\n    //把所有星座的转换日期放进数组里\n    cout<<\"请输入你生日的月份：\"<<endl;\n    cin>>a;\n    cout<<\"请输入你生日的日期：\"<<endl;\n    cin>>b;\n    cout<<\"你的星座是：\"<<conset[a-1][b/consetl[a-1]]<<endl;\n}\n```\n**这只是简单的打印星座，思路是，先把十二星座按照月份写进一个二位数组里面，然后再把每个星座的转换日期写进另外一个数组里，用输入的生日的几号来处以星座转换日期，得到的0为当前月份的前者，得到1为当前月份的后者。**\n","slug":"constellation","published":1,"updated":"2019-09-12T07:18:59.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7r800074ez7wqqhkqip","content":"<pre><code>星座\n</code></pre><a id=\"more\"></a>\n<h1 id=\"星座\"><a href=\"#星座\" class=\"headerlink\" title=\"星座\"></a>星座</h1><ul>\n<li>根据输入的生日日期来输出星座<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int a(0),b(0);</span><br><span class=\"line\">    string conste[12][2]&#123;//把十二个星座按照月份放进数组里</span><br><span class=\"line\">        &#123;&quot;魔蟹座&quot;,&quot;水瓶座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;水瓶座&quot;,&quot;双鱼座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;双鱼座&quot;,&quot;白羊座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;白羊座&quot;,&quot;金牛座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;金牛座&quot;,&quot;双子座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;双子座&quot;,&quot;巨蟹座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;巨蟹座&quot;,&quot;狮子座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;狮子座&quot;,&quot;处女座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;处女座&quot;,&quot;天秤座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;天秤座&quot;,&quot;天蝎座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;天蝎座&quot;,&quot;射手座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;射手座&quot;,&quot;魔蟹座&quot;&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    int constel[]&#123;20,19,21,20,21,22,23,23,23,24,23,22&#125;;</span><br><span class=\"line\">    //把所有星座的转换日期放进数组里</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入你生日的月份：&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入你生日的日期：&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;b;</span><br><span class=\"line\">    cout&lt;&lt;&quot;你的星座是：&quot;&lt;&lt;conset[a-1][b/consetl[a-1]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>这只是简单的打印星座，思路是，先把十二星座按照月份写进一个二位数组里面，然后再把每个星座的转换日期写进另外一个数组里，用输入的生日的几号来处以星座转换日期，得到的0为当前月份的前者，得到1为当前月份的后者。</strong></p>\n","site":{"data":{}},"excerpt":"<pre><code>星座\n</code></pre>","more":"<h1 id=\"星座\"><a href=\"#星座\" class=\"headerlink\" title=\"星座\"></a>星座</h1><ul>\n<li>根据输入的生日日期来输出星座<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int a(0),b(0);</span><br><span class=\"line\">    string conste[12][2]&#123;//把十二个星座按照月份放进数组里</span><br><span class=\"line\">        &#123;&quot;魔蟹座&quot;,&quot;水瓶座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;水瓶座&quot;,&quot;双鱼座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;双鱼座&quot;,&quot;白羊座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;白羊座&quot;,&quot;金牛座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;金牛座&quot;,&quot;双子座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;双子座&quot;,&quot;巨蟹座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;巨蟹座&quot;,&quot;狮子座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;狮子座&quot;,&quot;处女座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;处女座&quot;,&quot;天秤座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;天秤座&quot;,&quot;天蝎座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;天蝎座&quot;,&quot;射手座&quot;&#125;,</span><br><span class=\"line\">        &#123;&quot;射手座&quot;,&quot;魔蟹座&quot;&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    int constel[]&#123;20,19,21,20,21,22,23,23,23,24,23,22&#125;;</span><br><span class=\"line\">    //把所有星座的转换日期放进数组里</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入你生日的月份：&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入你生日的日期：&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;b;</span><br><span class=\"line\">    cout&lt;&lt;&quot;你的星座是：&quot;&lt;&lt;conset[a-1][b/consetl[a-1]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>这只是简单的打印星座，思路是，先把十二星座按照月份写进一个二位数组里面，然后再把每个星座的转换日期写进另外一个数组里，用输入的生日的几号来处以星座转换日期，得到的0为当前月份的前者，得到1为当前月份的后者。</strong></p>"},{"title":"Hello World","_content":"注释\n<!--more-->\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n```bash\n$ hexo n + 文件名 1. 在本地建立文件\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n```bash\n$ hexo s          2. 推送到本地库\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n```bash\n$ hexo g          3. 在本地生成\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n```bash\n$ hexo d          4. 推送到远程库\n```\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\n注释\n<!--more-->\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n```bash\n$ hexo n + 文件名 1. 在本地建立文件\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n```bash\n$ hexo s          2. 推送到本地库\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n```bash\n$ hexo g          3. 在本地生成\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n```bash\n$ hexo d          4. 推送到远程库\n```\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2019-09-10T09:11:24.860Z","updated":"2019-09-10T09:11:24.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7re000a4ez7envoo73b","content":"<p>注释<br><a id=\"more\"></a><br>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo n + 文件名 1. 在本地建立文件</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s          2. 推送到本地库</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g          3. 在本地生成</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d          4. 推送到远程库</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>注释<br></p>","more":"<br>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.<p></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo n + 文件名 1. 在本地建立文件</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s          2. 推送到本地库</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g          3. 在本地生成</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d          4. 推送到远程库</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"file","date":"2019-05-31T05:57:01.000Z","_content":"注释\n<!--more-->\n# 流\n**c++中的流，可以让我们做很多我们想不到的操作，文件流，输入和输出流。**\n1. 文件流的头文件(fstream)\n2. 输入和输出流的头文件(istream)\n* 把输入流当做函数的参数\n```\n#include <iostream>\nusing namespace std;\nvoid test(istream &a){\n    do{\n    char A;\n    cout<<请输入字符<<endl;\n    a.get(A);//这里是以一个字符的形式输入\n    cout.put(A);//是以字符串的形式输出\n    }while(A!=' ');//把条件设为变量不能等于空格\n}\nint main(){\n    test(cin);\n}\n```\n运行结果\n```\n请输入字符\nabc\nabc\n```\n----\n# 文件\n> 文件有两种类型：\n* 文本文件--以ASCLL码形式存储在计算机中。\n* 二进制文件--以二进制写进计算机。\n>> 分为三种类型：1.写文件（ofstream）,2.读文件（ifstream）3.（fstream）。\n* 写入文件分为5大部分：\n1. 先把写文件的头文件包含进去。\n2. 然后确定你要写的文件的类型\n3. 之后确定文件的名字和打开的方式\n4. 把内容写进去\n5. 关闭文件\n![打开方式](file/file.png)\n```\n#include<iostream>\n#include<fstream>//引入写文件的头文件\nusing namespace std;\nvoid test(){\n    ofstream ofs;// 文件的类型 写入文件\n    ofs.open(\"test.txt\",ios::out);文件名和打开的方式(写的方式)\n    ofs<<\"你好！\"<<endl;把你要写进文件的内容写进去\n    ofs.close(); 关闭文件\n}\nvoid test1(){\n    ifstream ifs;//文件类型，读文件\n    ifs.open(\"test.txt\",ios::in);//打开的文件名和打开方式(读的方式)\n    if(!ifs.is_open()){//判断打开文件\n        cout<<\"文件打开失败\"<<endl;\n    }\n    string buf;\n    while(getline(ifs,buf)){//以一行的形式读入编译器并输出\n        cout<<buf<<endl;\n    }\n    ifs.close();关闭文件\n}\nint main(){\n    test();//调用test函数\n    test1();//调用函数\n}\n```\n## 对于写的内容追加到文件中的命令是如下：\n```\n#include <iostream>\n#include <fstream>\nusing namestape std;\nint main(){\n    ofstream ofs;//声明文件的形式\n    ofs.open(\"test\",ios::app);//打开的方式\n    ofs<<\"你好\"<<endl;//写进的内容\n    ofs.close();//关闭文件\n    ifstream ifs;//声明文件的形式\n    ifs.open(\"test\",ios::in);//打开的方式\n    if(!ifs.isopen()){//判断文件的打开是否成功\n        cout<<\"文件打开失败\"<<endl;\n    }\n    ifs.close();//关闭文件\n}\n```\n* 在这里运行几次之后的结果会和第一次的不一样，因为在这里是以追加的形式向文件中写入你的内容。\n![运行结果](file/file1.png)\n# 用输出流来控制小数点\n* 这里是用输出流来控制小数点的个数\n```\n#include <iostream>\n#include <iomanip>//下面的函数会用到这个头文件\nusing namespace std;\nint main(){\n    double a(10.1234)\n    cout<<a<<endl;\n    cout.setf(ios::fixed);//小数点后的位数,默认为6个数位\n    cout.setf(ios::showpoint);//打印小数点和小数点的个数，默认为6个数位\n    cout<<a<<endl;\n    cout<<setw(2)<<setprecision(2)<<a<<endl;//给出小数点后的几位数\n    cout<<setw(6)<<a<<endl;\n}\n\n```\n运行结果：\n```\n10.1234\n10.123400\n10.12\n 10.12\n```\n# 四舍五入\n* 简单的把数字四舍五入\n```\n#include <iostream>\n#include <cmath>//在c++中有很多预定义的算术函数，都需要用到这个头文件\nusing namespace std;\nint main(){\n    double numb(0);\n    int test(0);\n    cout<<\"请输入要四舍五入的数字：\"<<endl;\n    cin>>numb;\n    test=static_cast<int >(floor(numb+0.5));//把四舍五入后的数字强制转换成int类型\n    cout<<test<<endl;\n}\n```\n//简单的输出算术平方跟\n```\n#include <iostream>\n#include <cmath>//c++与定义的函数调用\nusing namespace std;\nint main(){\n    double test(9.0),test1(0);\n    test1=sqrt(test);//预定义平方跟函数\n    cout<<test1<<endl;\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint);\n    cout<<setw(6)<<setprecision(2)<<test1<<endl;\n    cout<<pow(3,2)<<endl;\n    //pow函数，实现的是数字的几次方，前面的参数是数字，后面的参数是几次方,但函数返回的是double类性的数，因为我们上面把输出流设置成小数点后2位，本来的结果应该是9。\n}\n```\n运行结果：\n```\n3\n  3.00\n9.00\n```\n**在c++中还有很多类似于写好的函数放在不一样的c++库中,这样的做法无非就是方便了我们这些短命子以后不用自己在写一遍实现的代码。比如我们经常用到的cin cout 这些都是放在一个库里面的我们需要的时候都是从iostrean库中的调用的。其实在这些里面还有很多很好玩的，比如上面用到的利用输出流来控制我们的变量输出格式，这些虽然看起来简单，但要我们代码来一一实现的话就有点小自闭了，也没什么必要这么做，因为现在都有现成的了，为什么不要？要是还想知道c++里还有哪些好玩的库，你自己以后慢慢寻找。** \n# 随机数字\n**生成的随机数字的范围是1～6**\n```\n#include <iostream>\n#include <cstdlib>//随机种子的头文件\nusing namespace std;\nvoid test(){\n    srand(time(0));\n    int a,b;\n    cout<<\"请输入最大的数字\"<<endl;\n    cin>>a;\n    cout<<\"请输入最小的数字\"<<endl;\n    cin>>b;\n    if(b==0){\n        cout<<(rand()%a)+1<<endl;\n    }else{\n        cout<<(rand()%a)+b<<endl;\n    }\n}\nint main (){\n    srand(time(0));//声明时间种子\n    cout<<(rand()%6)+1<<endl;模6(得到的是0～5)+1(是把数字都加上1)\n}\n```\n# 黑盒\n* 也叫做函数的抽象化。\n","source":"_posts/file.md","raw":"---\ntitle: file\ndate: 2019-05-31 13:57:01\ntags:\n---\n注释\n<!--more-->\n# 流\n**c++中的流，可以让我们做很多我们想不到的操作，文件流，输入和输出流。**\n1. 文件流的头文件(fstream)\n2. 输入和输出流的头文件(istream)\n* 把输入流当做函数的参数\n```\n#include <iostream>\nusing namespace std;\nvoid test(istream &a){\n    do{\n    char A;\n    cout<<请输入字符<<endl;\n    a.get(A);//这里是以一个字符的形式输入\n    cout.put(A);//是以字符串的形式输出\n    }while(A!=' ');//把条件设为变量不能等于空格\n}\nint main(){\n    test(cin);\n}\n```\n运行结果\n```\n请输入字符\nabc\nabc\n```\n----\n# 文件\n> 文件有两种类型：\n* 文本文件--以ASCLL码形式存储在计算机中。\n* 二进制文件--以二进制写进计算机。\n>> 分为三种类型：1.写文件（ofstream）,2.读文件（ifstream）3.（fstream）。\n* 写入文件分为5大部分：\n1. 先把写文件的头文件包含进去。\n2. 然后确定你要写的文件的类型\n3. 之后确定文件的名字和打开的方式\n4. 把内容写进去\n5. 关闭文件\n![打开方式](file/file.png)\n```\n#include<iostream>\n#include<fstream>//引入写文件的头文件\nusing namespace std;\nvoid test(){\n    ofstream ofs;// 文件的类型 写入文件\n    ofs.open(\"test.txt\",ios::out);文件名和打开的方式(写的方式)\n    ofs<<\"你好！\"<<endl;把你要写进文件的内容写进去\n    ofs.close(); 关闭文件\n}\nvoid test1(){\n    ifstream ifs;//文件类型，读文件\n    ifs.open(\"test.txt\",ios::in);//打开的文件名和打开方式(读的方式)\n    if(!ifs.is_open()){//判断打开文件\n        cout<<\"文件打开失败\"<<endl;\n    }\n    string buf;\n    while(getline(ifs,buf)){//以一行的形式读入编译器并输出\n        cout<<buf<<endl;\n    }\n    ifs.close();关闭文件\n}\nint main(){\n    test();//调用test函数\n    test1();//调用函数\n}\n```\n## 对于写的内容追加到文件中的命令是如下：\n```\n#include <iostream>\n#include <fstream>\nusing namestape std;\nint main(){\n    ofstream ofs;//声明文件的形式\n    ofs.open(\"test\",ios::app);//打开的方式\n    ofs<<\"你好\"<<endl;//写进的内容\n    ofs.close();//关闭文件\n    ifstream ifs;//声明文件的形式\n    ifs.open(\"test\",ios::in);//打开的方式\n    if(!ifs.isopen()){//判断文件的打开是否成功\n        cout<<\"文件打开失败\"<<endl;\n    }\n    ifs.close();//关闭文件\n}\n```\n* 在这里运行几次之后的结果会和第一次的不一样，因为在这里是以追加的形式向文件中写入你的内容。\n![运行结果](file/file1.png)\n# 用输出流来控制小数点\n* 这里是用输出流来控制小数点的个数\n```\n#include <iostream>\n#include <iomanip>//下面的函数会用到这个头文件\nusing namespace std;\nint main(){\n    double a(10.1234)\n    cout<<a<<endl;\n    cout.setf(ios::fixed);//小数点后的位数,默认为6个数位\n    cout.setf(ios::showpoint);//打印小数点和小数点的个数，默认为6个数位\n    cout<<a<<endl;\n    cout<<setw(2)<<setprecision(2)<<a<<endl;//给出小数点后的几位数\n    cout<<setw(6)<<a<<endl;\n}\n\n```\n运行结果：\n```\n10.1234\n10.123400\n10.12\n 10.12\n```\n# 四舍五入\n* 简单的把数字四舍五入\n```\n#include <iostream>\n#include <cmath>//在c++中有很多预定义的算术函数，都需要用到这个头文件\nusing namespace std;\nint main(){\n    double numb(0);\n    int test(0);\n    cout<<\"请输入要四舍五入的数字：\"<<endl;\n    cin>>numb;\n    test=static_cast<int >(floor(numb+0.5));//把四舍五入后的数字强制转换成int类型\n    cout<<test<<endl;\n}\n```\n//简单的输出算术平方跟\n```\n#include <iostream>\n#include <cmath>//c++与定义的函数调用\nusing namespace std;\nint main(){\n    double test(9.0),test1(0);\n    test1=sqrt(test);//预定义平方跟函数\n    cout<<test1<<endl;\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint);\n    cout<<setw(6)<<setprecision(2)<<test1<<endl;\n    cout<<pow(3,2)<<endl;\n    //pow函数，实现的是数字的几次方，前面的参数是数字，后面的参数是几次方,但函数返回的是double类性的数，因为我们上面把输出流设置成小数点后2位，本来的结果应该是9。\n}\n```\n运行结果：\n```\n3\n  3.00\n9.00\n```\n**在c++中还有很多类似于写好的函数放在不一样的c++库中,这样的做法无非就是方便了我们这些短命子以后不用自己在写一遍实现的代码。比如我们经常用到的cin cout 这些都是放在一个库里面的我们需要的时候都是从iostrean库中的调用的。其实在这些里面还有很多很好玩的，比如上面用到的利用输出流来控制我们的变量输出格式，这些虽然看起来简单，但要我们代码来一一实现的话就有点小自闭了，也没什么必要这么做，因为现在都有现成的了，为什么不要？要是还想知道c++里还有哪些好玩的库，你自己以后慢慢寻找。** \n# 随机数字\n**生成的随机数字的范围是1～6**\n```\n#include <iostream>\n#include <cstdlib>//随机种子的头文件\nusing namespace std;\nvoid test(){\n    srand(time(0));\n    int a,b;\n    cout<<\"请输入最大的数字\"<<endl;\n    cin>>a;\n    cout<<\"请输入最小的数字\"<<endl;\n    cin>>b;\n    if(b==0){\n        cout<<(rand()%a)+1<<endl;\n    }else{\n        cout<<(rand()%a)+b<<endl;\n    }\n}\nint main (){\n    srand(time(0));//声明时间种子\n    cout<<(rand()%6)+1<<endl;模6(得到的是0～5)+1(是把数字都加上1)\n}\n```\n# 黑盒\n* 也叫做函数的抽象化。\n","slug":"file","published":1,"updated":"2019-09-12T05:12:30.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7ri000b4ez7sakizs05","content":"<p>注释<br><a id=\"more\"></a></p>\n<h1 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h1><p><strong>c++中的流，可以让我们做很多我们想不到的操作，文件流，输入和输出流。</strong></p>\n<ol>\n<li>文件流的头文件(fstream)</li>\n<li>输入和输出流的头文件(istream)</li>\n</ol>\n<ul>\n<li>把输入流当做函数的参数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">void test(istream &amp;a)&#123;</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">    char A;</span><br><span class=\"line\">    cout&lt;&lt;请输入字符&lt;&lt;endl;</span><br><span class=\"line\">    a.get(A);//这里是以一个字符的形式输入</span><br><span class=\"line\">    cout.put(A);//是以字符串的形式输出</span><br><span class=\"line\">    &#125;while(A!=&apos; &apos;);//把条件设为变量不能等于空格</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test(cin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入字符</span><br><span class=\"line\">abc</span><br><span class=\"line\">abc</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h1><blockquote>\n<p>文件有两种类型：</p>\n<ul>\n<li>文本文件–以ASCLL码形式存储在计算机中。</li>\n<li>二进制文件–以二进制写进计算机。<blockquote>\n<p>分为三种类型：1.写文件（ofstream）,2.读文件（ifstream）3.（fstream）。</p>\n</blockquote>\n</li>\n<li>写入文件分为5大部分：</li>\n</ul>\n<ol>\n<li>先把写文件的头文件包含进去。</li>\n<li>然后确定你要写的文件的类型</li>\n<li>之后确定文件的名字和打开的方式</li>\n<li>把内容写进去</li>\n<li>关闭文件<br><img src=\"/2019/05/31/file/file.png\" alt=\"打开方式\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;fstream&gt;//引入写文件的头文件</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">void test()&#123;</span><br><span class=\"line\">    ofstream ofs;// 文件的类型 写入文件</span><br><span class=\"line\">    ofs.open(&quot;test.txt&quot;,ios::out);文件名和打开的方式(写的方式)</span><br><span class=\"line\">    ofs&lt;&lt;&quot;你好！&quot;&lt;&lt;endl;把你要写进文件的内容写进去</span><br><span class=\"line\">    ofs.close(); 关闭文件</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void test1()&#123;</span><br><span class=\"line\">    ifstream ifs;//文件类型，读文件</span><br><span class=\"line\">    ifs.open(&quot;test.txt&quot;,ios::in);//打开的文件名和打开方式(读的方式)</span><br><span class=\"line\">    if(!ifs.is_open())&#123;//判断打开文件</span><br><span class=\"line\">        cout&lt;&lt;&quot;文件打开失败&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string buf;</span><br><span class=\"line\">    while(getline(ifs,buf))&#123;//以一行的形式读入编译器并输出</span><br><span class=\"line\">        cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ifs.close();关闭文件</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test();//调用test函数</span><br><span class=\"line\">    test1();//调用函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"对于写的内容追加到文件中的命令是如下：\"><a href=\"#对于写的内容追加到文件中的命令是如下：\" class=\"headerlink\" title=\"对于写的内容追加到文件中的命令是如下：\"></a>对于写的内容追加到文件中的命令是如下：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">using namestape std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    ofstream ofs;//声明文件的形式</span><br><span class=\"line\">    ofs.open(&quot;test&quot;,ios::app);//打开的方式</span><br><span class=\"line\">    ofs&lt;&lt;&quot;你好&quot;&lt;&lt;endl;//写进的内容</span><br><span class=\"line\">    ofs.close();//关闭文件</span><br><span class=\"line\">    ifstream ifs;//声明文件的形式</span><br><span class=\"line\">    ifs.open(&quot;test&quot;,ios::in);//打开的方式</span><br><span class=\"line\">    if(!ifs.isopen())&#123;//判断文件的打开是否成功</span><br><span class=\"line\">        cout&lt;&lt;&quot;文件打开失败&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ifs.close();//关闭文件</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在这里运行几次之后的结果会和第一次的不一样，因为在这里是以追加的形式向文件中写入你的内容。<br><img src=\"/2019/05/31/file/file1.png\" alt=\"运行结果\"><h1 id=\"用输出流来控制小数点\"><a href=\"#用输出流来控制小数点\" class=\"headerlink\" title=\"用输出流来控制小数点\"></a>用输出流来控制小数点</h1></li>\n<li>这里是用输出流来控制小数点的个数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;iomanip&gt;//下面的函数会用到这个头文件</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double a(10.1234)</span><br><span class=\"line\">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">    cout.setf(ios::fixed);//小数点后的位数,默认为6个数位</span><br><span class=\"line\">    cout.setf(ios::showpoint);//打印小数点和小数点的个数，默认为6个数位</span><br><span class=\"line\">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;setw(2)&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl;//给出小数点后的几位数</span><br><span class=\"line\">    cout&lt;&lt;setw(6)&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.1234</span><br><span class=\"line\">10.123400</span><br><span class=\"line\">10.12</span><br><span class=\"line\"> 10.12</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"四舍五入\"><a href=\"#四舍五入\" class=\"headerlink\" title=\"四舍五入\"></a>四舍五入</h1><ul>\n<li>简单的把数字四舍五入<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;//在c++中有很多预定义的算术函数，都需要用到这个头文件</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double numb(0);</span><br><span class=\"line\">    int test(0);</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入要四舍五入的数字：&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;numb;</span><br><span class=\"line\">    test=static_cast&lt;int &gt;(floor(numb+0.5));//把四舍五入后的数字强制转换成int类型</span><br><span class=\"line\">    cout&lt;&lt;test&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>//简单的输出算术平方跟<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;//c++与定义的函数调用</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double test(9.0),test1(0);</span><br><span class=\"line\">    test1=sqrt(test);//预定义平方跟函数</span><br><span class=\"line\">    cout&lt;&lt;test1&lt;&lt;endl;</span><br><span class=\"line\">    cout.setf(ios::fixed);</span><br><span class=\"line\">    cout.setf(ios::showpoint);</span><br><span class=\"line\">    cout&lt;&lt;setw(6)&lt;&lt;setprecision(2)&lt;&lt;test1&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;pow(3,2)&lt;&lt;endl;</span><br><span class=\"line\">    //pow函数，实现的是数字的几次方，前面的参数是数字，后面的参数是几次方,但函数返回的是double类性的数，因为我们上面把输出流设置成小数点后2位，本来的结果应该是9。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">  3.00</span><br><span class=\"line\">9.00</span><br></pre></td></tr></table></figure></p>\n<p><strong>在c++中还有很多类似于写好的函数放在不一样的c++库中,这样的做法无非就是方便了我们这些短命子以后不用自己在写一遍实现的代码。比如我们经常用到的cin cout 这些都是放在一个库里面的我们需要的时候都是从iostrean库中的调用的。其实在这些里面还有很多很好玩的，比如上面用到的利用输出流来控制我们的变量输出格式，这些虽然看起来简单，但要我们代码来一一实现的话就有点小自闭了，也没什么必要这么做，因为现在都有现成的了，为什么不要？要是还想知道c++里还有哪些好玩的库，你自己以后慢慢寻找。</strong> </p>\n<h1 id=\"随机数字\"><a href=\"#随机数字\" class=\"headerlink\" title=\"随机数字\"></a>随机数字</h1><p><strong>生成的随机数字的范围是1～6</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cstdlib&gt;//随机种子的头文件</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">void test()&#123;</span><br><span class=\"line\">    srand(time(0));</span><br><span class=\"line\">    int a,b;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入最大的数字&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入最小的数字&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;b;</span><br><span class=\"line\">    if(b==0)&#123;</span><br><span class=\"line\">        cout&lt;&lt;(rand()%a)+1&lt;&lt;endl;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        cout&lt;&lt;(rand()%a)+b&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main ()&#123;</span><br><span class=\"line\">    srand(time(0));//声明时间种子</span><br><span class=\"line\">    cout&lt;&lt;(rand()%6)+1&lt;&lt;endl;模6(得到的是0～5)+1(是把数字都加上1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"黑盒\"><a href=\"#黑盒\" class=\"headerlink\" title=\"黑盒\"></a>黑盒</h1><ul>\n<li>也叫做函数的抽象化。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>注释<br></p>","more":"<p></p>\n<h1 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h1><p><strong>c++中的流，可以让我们做很多我们想不到的操作，文件流，输入和输出流。</strong></p>\n<ol>\n<li>文件流的头文件(fstream)</li>\n<li>输入和输出流的头文件(istream)</li>\n</ol>\n<ul>\n<li>把输入流当做函数的参数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">void test(istream &amp;a)&#123;</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">    char A;</span><br><span class=\"line\">    cout&lt;&lt;请输入字符&lt;&lt;endl;</span><br><span class=\"line\">    a.get(A);//这里是以一个字符的形式输入</span><br><span class=\"line\">    cout.put(A);//是以字符串的形式输出</span><br><span class=\"line\">    &#125;while(A!=&apos; &apos;);//把条件设为变量不能等于空格</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test(cin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入字符</span><br><span class=\"line\">abc</span><br><span class=\"line\">abc</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h1><blockquote>\n<p>文件有两种类型：</p>\n<ul>\n<li>文本文件–以ASCLL码形式存储在计算机中。</li>\n<li>二进制文件–以二进制写进计算机。<blockquote>\n<p>分为三种类型：1.写文件（ofstream）,2.读文件（ifstream）3.（fstream）。</p>\n</blockquote>\n</li>\n<li>写入文件分为5大部分：</li>\n</ul>\n<ol>\n<li>先把写文件的头文件包含进去。</li>\n<li>然后确定你要写的文件的类型</li>\n<li>之后确定文件的名字和打开的方式</li>\n<li>把内容写进去</li>\n<li>关闭文件<br><img src=\"/2019/05/31/file/file.png\" alt=\"打开方式\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;fstream&gt;//引入写文件的头文件</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">void test()&#123;</span><br><span class=\"line\">    ofstream ofs;// 文件的类型 写入文件</span><br><span class=\"line\">    ofs.open(&quot;test.txt&quot;,ios::out);文件名和打开的方式(写的方式)</span><br><span class=\"line\">    ofs&lt;&lt;&quot;你好！&quot;&lt;&lt;endl;把你要写进文件的内容写进去</span><br><span class=\"line\">    ofs.close(); 关闭文件</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void test1()&#123;</span><br><span class=\"line\">    ifstream ifs;//文件类型，读文件</span><br><span class=\"line\">    ifs.open(&quot;test.txt&quot;,ios::in);//打开的文件名和打开方式(读的方式)</span><br><span class=\"line\">    if(!ifs.is_open())&#123;//判断打开文件</span><br><span class=\"line\">        cout&lt;&lt;&quot;文件打开失败&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string buf;</span><br><span class=\"line\">    while(getline(ifs,buf))&#123;//以一行的形式读入编译器并输出</span><br><span class=\"line\">        cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ifs.close();关闭文件</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test();//调用test函数</span><br><span class=\"line\">    test1();//调用函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"对于写的内容追加到文件中的命令是如下：\"><a href=\"#对于写的内容追加到文件中的命令是如下：\" class=\"headerlink\" title=\"对于写的内容追加到文件中的命令是如下：\"></a>对于写的内容追加到文件中的命令是如下：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">using namestape std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    ofstream ofs;//声明文件的形式</span><br><span class=\"line\">    ofs.open(&quot;test&quot;,ios::app);//打开的方式</span><br><span class=\"line\">    ofs&lt;&lt;&quot;你好&quot;&lt;&lt;endl;//写进的内容</span><br><span class=\"line\">    ofs.close();//关闭文件</span><br><span class=\"line\">    ifstream ifs;//声明文件的形式</span><br><span class=\"line\">    ifs.open(&quot;test&quot;,ios::in);//打开的方式</span><br><span class=\"line\">    if(!ifs.isopen())&#123;//判断文件的打开是否成功</span><br><span class=\"line\">        cout&lt;&lt;&quot;文件打开失败&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ifs.close();//关闭文件</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在这里运行几次之后的结果会和第一次的不一样，因为在这里是以追加的形式向文件中写入你的内容。<br><img src=\"/2019/05/31/file/file1.png\" alt=\"运行结果\"><h1 id=\"用输出流来控制小数点\"><a href=\"#用输出流来控制小数点\" class=\"headerlink\" title=\"用输出流来控制小数点\"></a>用输出流来控制小数点</h1></li>\n<li>这里是用输出流来控制小数点的个数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;iomanip&gt;//下面的函数会用到这个头文件</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double a(10.1234)</span><br><span class=\"line\">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">    cout.setf(ios::fixed);//小数点后的位数,默认为6个数位</span><br><span class=\"line\">    cout.setf(ios::showpoint);//打印小数点和小数点的个数，默认为6个数位</span><br><span class=\"line\">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;setw(2)&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl;//给出小数点后的几位数</span><br><span class=\"line\">    cout&lt;&lt;setw(6)&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.1234</span><br><span class=\"line\">10.123400</span><br><span class=\"line\">10.12</span><br><span class=\"line\"> 10.12</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"四舍五入\"><a href=\"#四舍五入\" class=\"headerlink\" title=\"四舍五入\"></a>四舍五入</h1><ul>\n<li>简单的把数字四舍五入<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;//在c++中有很多预定义的算术函数，都需要用到这个头文件</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double numb(0);</span><br><span class=\"line\">    int test(0);</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入要四舍五入的数字：&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;numb;</span><br><span class=\"line\">    test=static_cast&lt;int &gt;(floor(numb+0.5));//把四舍五入后的数字强制转换成int类型</span><br><span class=\"line\">    cout&lt;&lt;test&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>//简单的输出算术平方跟<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;//c++与定义的函数调用</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double test(9.0),test1(0);</span><br><span class=\"line\">    test1=sqrt(test);//预定义平方跟函数</span><br><span class=\"line\">    cout&lt;&lt;test1&lt;&lt;endl;</span><br><span class=\"line\">    cout.setf(ios::fixed);</span><br><span class=\"line\">    cout.setf(ios::showpoint);</span><br><span class=\"line\">    cout&lt;&lt;setw(6)&lt;&lt;setprecision(2)&lt;&lt;test1&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;pow(3,2)&lt;&lt;endl;</span><br><span class=\"line\">    //pow函数，实现的是数字的几次方，前面的参数是数字，后面的参数是几次方,但函数返回的是double类性的数，因为我们上面把输出流设置成小数点后2位，本来的结果应该是9。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">  3.00</span><br><span class=\"line\">9.00</span><br></pre></td></tr></table></figure></p>\n<p><strong>在c++中还有很多类似于写好的函数放在不一样的c++库中,这样的做法无非就是方便了我们这些短命子以后不用自己在写一遍实现的代码。比如我们经常用到的cin cout 这些都是放在一个库里面的我们需要的时候都是从iostrean库中的调用的。其实在这些里面还有很多很好玩的，比如上面用到的利用输出流来控制我们的变量输出格式，这些虽然看起来简单，但要我们代码来一一实现的话就有点小自闭了，也没什么必要这么做，因为现在都有现成的了，为什么不要？要是还想知道c++里还有哪些好玩的库，你自己以后慢慢寻找。</strong> </p>\n<h1 id=\"随机数字\"><a href=\"#随机数字\" class=\"headerlink\" title=\"随机数字\"></a>随机数字</h1><p><strong>生成的随机数字的范围是1～6</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cstdlib&gt;//随机种子的头文件</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">void test()&#123;</span><br><span class=\"line\">    srand(time(0));</span><br><span class=\"line\">    int a,b;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入最大的数字&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    cout&lt;&lt;&quot;请输入最小的数字&quot;&lt;&lt;endl;</span><br><span class=\"line\">    cin&gt;&gt;b;</span><br><span class=\"line\">    if(b==0)&#123;</span><br><span class=\"line\">        cout&lt;&lt;(rand()%a)+1&lt;&lt;endl;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        cout&lt;&lt;(rand()%a)+b&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main ()&#123;</span><br><span class=\"line\">    srand(time(0));//声明时间种子</span><br><span class=\"line\">    cout&lt;&lt;(rand()%6)+1&lt;&lt;endl;模6(得到的是0～5)+1(是把数字都加上1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"黑盒\"><a href=\"#黑盒\" class=\"headerlink\" title=\"黑盒\"></a>黑盒</h1><ul>\n<li>也叫做函数的抽象化。</li>\n</ul>"},{"title":"i3.md","date":"2019-09-22T08:31:39.000Z","_content":"**这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。**\n---\n\n\n<!--more-->\n# 慢慢理解的过程\n* 我是从暑假开始接触i3的，当然只是很表面的理解了一点点，这也是我宿友的骚操作，因为他也是中了up主的迷，一个github上叫theniceboy的一个小伙子，刚开始只是vim的着迷到最后的配置，然而那个小伙子还是有点东西的。\n* 其实来说，我的想法就是多学点东西，我觉得每个人的想法都是一样的。\n\n## *i3*\n* 值得我们去学习，但却不用伸进去。也就是说我们可以按照自己的想法去玩，但是呢，要有点自制。\n![小骚](i3/113997.jpg)\n[小骚](~/touch/41219.jpg)\n[http://www.baidu.com](http://www.baidu.com)\n---\n**只是一张照片**\n*只是一张照片* \n---\n~~删除~~ 我们不想要的东西\n---\n![小骚](i3/41912.jpg)\n---\n\n[github](https://github.com)\n---\n- [ ] [github](https://github.com)\n### vim\n**对于lunix玩家来说，我们编辑的时候大多数人都会选择vim来编辑文件的，所以我们会把vim配置好，接下来的还是那个up主来带飞我们。**\n---\n[github](https://theniceboy.github.com)\n* 这是他的github号，里面有很多关于vim或者i3的配置文件，感觉他很强大，帮了我们很多我们没有想到的便捷。**当然我们在这里承认是小白的话问题不大。**\n---\n\n*视频方面的话，b站欢迎你们。*\n\n[bilibili](http://bilibili.com)\n\n*你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。*\n---\n\n*请大家欣赏一下我找的紫色壁纸*\n![小骚](i3/228533.jpg)\n**告辞**\n---\n","source":"_posts/i3.md","raw":"---\ntitle : i3.md\ndate : 2019-09-22 16:31:39\ntags:\n---\n**这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。**\n---\n\n\n<!--more-->\n# 慢慢理解的过程\n* 我是从暑假开始接触i3的，当然只是很表面的理解了一点点，这也是我宿友的骚操作，因为他也是中了up主的迷，一个github上叫theniceboy的一个小伙子，刚开始只是vim的着迷到最后的配置，然而那个小伙子还是有点东西的。\n* 其实来说，我的想法就是多学点东西，我觉得每个人的想法都是一样的。\n\n## *i3*\n* 值得我们去学习，但却不用伸进去。也就是说我们可以按照自己的想法去玩，但是呢，要有点自制。\n![小骚](i3/113997.jpg)\n[小骚](~/touch/41219.jpg)\n[http://www.baidu.com](http://www.baidu.com)\n---\n**只是一张照片**\n*只是一张照片* \n---\n~~删除~~ 我们不想要的东西\n---\n![小骚](i3/41912.jpg)\n---\n\n[github](https://github.com)\n---\n- [ ] [github](https://github.com)\n### vim\n**对于lunix玩家来说，我们编辑的时候大多数人都会选择vim来编辑文件的，所以我们会把vim配置好，接下来的还是那个up主来带飞我们。**\n---\n[github](https://theniceboy.github.com)\n* 这是他的github号，里面有很多关于vim或者i3的配置文件，感觉他很强大，帮了我们很多我们没有想到的便捷。**当然我们在这里承认是小白的话问题不大。**\n---\n\n*视频方面的话，b站欢迎你们。*\n\n[bilibili](http://bilibili.com)\n\n*你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。*\n---\n\n*请大家欣赏一下我找的紫色壁纸*\n![小骚](i3/228533.jpg)\n**告辞**\n---\n","slug":"i3","published":1,"updated":"2019-09-23T10:09:58.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7rm000d4ez707i1wgvr","content":"<h2 id=\"这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。\"><a href=\"#这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。\" class=\"headerlink\" title=\"这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。\"></a><strong>这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。</strong></h2><a id=\"more\"></a>\n<h1 id=\"慢慢理解的过程\"><a href=\"#慢慢理解的过程\" class=\"headerlink\" title=\"慢慢理解的过程\"></a>慢慢理解的过程</h1><ul>\n<li>我是从暑假开始接触i3的，当然只是很表面的理解了一点点，这也是我宿友的骚操作，因为他也是中了up主的迷，一个github上叫theniceboy的一个小伙子，刚开始只是vim的着迷到最后的配置，然而那个小伙子还是有点东西的。</li>\n<li>其实来说，我的想法就是多学点东西，我觉得每个人的想法都是一样的。</li>\n</ul>\n<h2 id=\"i3\"><a href=\"#i3\" class=\"headerlink\" title=\"i3\"></a><em>i3</em></h2><ul>\n<li>值得我们去学习，但却不用伸进去。也就是说我们可以按照自己的想法去玩，但是呢，要有点自制。<br><img src=\"/2019/09/22/i3/113997.jpg\" alt=\"小骚\"><br><a href=\"~/touch/41219.jpg\">小骚</a><br><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a></li>\n</ul>\n<hr>\n<p><strong>只是一张照片</strong></p>\n<h2 id=\"只是一张照片\"><a href=\"#只是一张照片\" class=\"headerlink\" title=\"只是一张照片 \"></a><em>只是一张照片</em> </h2><h2 id=\"删除-我们不想要的东西\"><a href=\"#删除-我们不想要的东西\" class=\"headerlink\" title=\"删除 我们不想要的东西\"></a><del>删除</del> 我们不想要的东西</h2><h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2019/09/22/i3/41912.jpg\" alt=\"小骚\"></h2><h2 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a><a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">github</a></h2><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> <a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">github</a><h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><strong>对于lunix玩家来说，我们编辑的时候大多数人都会选择vim来编辑文件的，所以我们会把vim配置好，接下来的还是那个up主来带飞我们。</strong></li>\n</ul>\n<hr>\n<p><a href=\"https://theniceboy.github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<ul>\n<li>这是他的github号，里面有很多关于vim或者i3的配置文件，感觉他很强大，帮了我们很多我们没有想到的便捷。<strong>当然我们在这里承认是小白的话问题不大。</strong></li>\n</ul>\n<hr>\n<p><em>视频方面的话，b站欢迎你们。</em></p>\n<p><a href=\"http://bilibili.com\" target=\"_blank\" rel=\"noopener\">bilibili</a></p>\n<h2 id=\"你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。\"><a href=\"#你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。\" class=\"headerlink\" title=\"你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。\"></a><em>你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。</em></h2><p><em>请大家欣赏一下我找的紫色壁纸</em><br><img src=\"/2019/09/22/i3/228533.jpg\" alt=\"小骚\"></p>\n<h2 id=\"告辞\"><a href=\"#告辞\" class=\"headerlink\" title=\"告辞\"></a><strong>告辞</strong></h2>","site":{"data":{}},"excerpt":"<h2 id=\"这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。\"><a href=\"#这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。\" class=\"headerlink\" title=\"这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。\"></a><strong>这是我第一次用了up主的配置文件写的第一篇博客，感觉还行，以后会坚持下来一直用的。</strong></h2>","more":"<h1 id=\"慢慢理解的过程\"><a href=\"#慢慢理解的过程\" class=\"headerlink\" title=\"慢慢理解的过程\"></a>慢慢理解的过程</h1><ul>\n<li>我是从暑假开始接触i3的，当然只是很表面的理解了一点点，这也是我宿友的骚操作，因为他也是中了up主的迷，一个github上叫theniceboy的一个小伙子，刚开始只是vim的着迷到最后的配置，然而那个小伙子还是有点东西的。</li>\n<li>其实来说，我的想法就是多学点东西，我觉得每个人的想法都是一样的。</li>\n</ul>\n<h2 id=\"i3\"><a href=\"#i3\" class=\"headerlink\" title=\"i3\"></a><em>i3</em></h2><ul>\n<li>值得我们去学习，但却不用伸进去。也就是说我们可以按照自己的想法去玩，但是呢，要有点自制。<br><img src=\"/2019/09/22/i3/113997.jpg\" alt=\"小骚\"><br><a href=\"~/touch/41219.jpg\">小骚</a><br><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a></li>\n</ul>\n<hr>\n<p><strong>只是一张照片</strong></p>\n<h2 id=\"只是一张照片\"><a href=\"#只是一张照片\" class=\"headerlink\" title=\"只是一张照片 \"></a><em>只是一张照片</em> </h2><h2 id=\"删除-我们不想要的东西\"><a href=\"#删除-我们不想要的东西\" class=\"headerlink\" title=\"删除 我们不想要的东西\"></a><del>删除</del> 我们不想要的东西</h2><h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2019/09/22/i3/41912.jpg\" alt=\"小骚\"></h2><h2 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a><a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">github</a></h2><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> <a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">github</a><h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><strong>对于lunix玩家来说，我们编辑的时候大多数人都会选择vim来编辑文件的，所以我们会把vim配置好，接下来的还是那个up主来带飞我们。</strong></li>\n</ul>\n<hr>\n<p><a href=\"https://theniceboy.github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<ul>\n<li>这是他的github号，里面有很多关于vim或者i3的配置文件，感觉他很强大，帮了我们很多我们没有想到的便捷。<strong>当然我们在这里承认是小白的话问题不大。</strong></li>\n</ul>\n<hr>\n<p><em>视频方面的话，b站欢迎你们。</em></p>\n<p><a href=\"http://bilibili.com\" target=\"_blank\" rel=\"noopener\">bilibili</a></p>\n<h2 id=\"你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。\"><a href=\"#你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。\" class=\"headerlink\" title=\"你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。\"></a><em>你只需要在b站里面搜索vim关键字就会有一个什么上古vim的标题，当然我在这里也就是提一下，看不就是你们的事情了，关于up主，我同学给的比方就是，只有别人问他问题。</em></h2><p><em>请大家欣赏一下我找的紫色壁纸</em><br><img src=\"/2019/09/22/i3/228533.jpg\" alt=\"小骚\"></p>\n<h2 id=\"告辞\"><a href=\"#告辞\" class=\"headerlink\" title=\"告辞\"></a><strong>告辞</strong></h2>"},{"title":"wed","date":"2019-09-10T07:12:01.000Z","_content":"                                       数据库\n<!--more-->\n# 第一节(数据库系统概述)\n1. 数据(date)\n* 是描述事物的符号记录，是指用物理符号记录下来的，可以鉴别的信息。\n---\n2. 数据库(DB)\n* 存储数据的仓库。\n> 特点\n* 永久储存，有组织，可共享。\n----\n3. 数据库管理系统(ABS)\n* 专门用于建立和管理数据库的软件，以及提供必要的安全性和完整性。\n> 功能\n1. 数据定义功能\n2. 数据操纵功能\n3. 数据库的运行管理功能\n4. 数据库的建立和维护功能\n5. 数据有组织,存储和管理功能\n6. 其他功能(通信功能，不同数据库之间数据的相互共享)\n----\n4. 数据库系统(DBS) ----  数据库管理员(DBA)\n# 第二节(数据管理技术的发展)\n* 应用程序管理数据\n*特点* \n* 数据面向应用\n----\n2. 文件管理系统\n*特点* \n* 数据可长期存放在磁盘\n* 数据的逻辑结构与物理结构有了区别\n* 文件组织呈多样化\n* 对数据的操作以记录为单位\n* 数据不再属于某个特定的程序可重复使用\n----\n3. 数据库系统阶段(E,F,code)\n*重大事件* \n* 1968年 美国IBM公司 (层次模型)\n* 1969年 美国 codesy (网状模型)\n* 1970年 美国 EFcode (关系模型)\n*特点* \n1. 数据集成\n2. 数据共享性高\n3. 数据冗余小(文件系统的缺陷)\n4. 数据一致性(文件系统的缺陷)\n5. 数据独立性高(文件系统的缺陷)\n*数据库保护* \n1. 数据的安全性\n2. 数据的完整性\n3. 并发控制\n4. 故障恢复\n# 第三节(数据库系统的结构)\n1. 三级模式的结构\n  外模式(子模式和用户模式)\n* 模式(概念模式和逻辑模式)\n* 内模式(存储模式)\n* 两层映像\n1. 外模式和概念模式(多个)\n2. 逻辑模式和内模式(唯一一个)\n----\n2. 数据库系统的运行与应用结构\n* 用户与服务器结构(C/S)\n* 浏览器与服务器结构(B/S)\n\n# 第四节(数据模型)\n## 1. 数据模型的组成要素\n1. 数据结构(静态特征)\n2. 数据操作(动态特征)\n3. 数据约束(依存关系)\n### 2. 数据模型的分类\n*概念层数据模型* \n* 概念层是数据抽象级别的最高层，其目的是按用户的观点来对世界建模。\n* 可分为：\n1. 实体：客观存在相互区别的食物。\n2. 属性：实体所具有的某种特性。\n3. 码或键：唯一标识实体的属性集。\n4. 域：属性的取值范围。\n5. 实体性：具有相同属性的实体必然具有共同的特征和性质。\n6. 实体集：同型实体的集合。\n7. 联系：事物内部和事物之间是有联系的。\n* 概念模型的表示方法（1：1 ; 1：n ; n:n）\n*逻辑层数据模型* \n1. 层次模型(使用最早)\n2. 网状模型(复杂)\n3. 关系模型(二维表结构，使用最广)\n4. 面向对象模型\n*物理层数据模型* \n* 定义：描述数据在介质上存储，是逻辑模型的物理实现。\n1. 概念模型到逻辑模型的转换是由数据库设计人员完成的。\n2. 逻辑到物理是由数据库管理系统完成的。\n----\n# 第二章 关系数据库\n**第一节关系数据库概述**\n----\n* 特征：是使用关系数据模型来组织数据。(主流数据模型)\n\n**第二节关系数据模型**\n----\n1. 关系数据结构\n* 表：被称为关系，是一个二维表(由表名，构成表的各个列和数据组成)。\n* 关系：可分为三种关系，(基本关系，查询表，视图表)。\n* 列：被称为字段或属性。\n* 属性：和列是同一个意思。\n* 行： 被称为元组或记录。\n* 元组：\n* 分量：元组中的每一个属性值。\n* 码或键()\n---\n\n**关系操作集合**\n1. 查询操作可以分为：选择，投影，连接，除，并，差，交，笛卡尔积，其中选择，投影，并，差，笛卡尔积是五种基础的，(增，删，改，查，插)。\n2. 关系数据语言的分类\n* **结构化查询语言**(SQL)\n* **数据定义语言**(DDL)\n* **数据操纵语言**(DML)\n* **数据控制语言(DCL)**\n3. **关系的完整性约束**\n* *数据库的数据完整性是指：数据库中的数据的正确性，相容性，一致性。*\n\n1.*关系模型中有三类完整性约束：实体完整性约束，参照完整性约束，用户定义完整性约束，其中(实体完整性约束和参照完整性约束是关系的两个不变性)。*\n* **实体关系完整性约束是指：关系的主属性，即主码的组成不能为空。**\n* **参照完整性约束是指：定义在主码和外码之间的引用规则。**\n* **用户定义完整性约束：是针对某一应用环境的完整性约束条件。**\n---\n\n**关系数据库的规范化理论**\n\n*关系模式中可能存在的冗余和异常的问题*\n* 数据冗余\n* 更新异常\n* 插入异常\n* 删除异常\n\n**数据依赖(函数依赖与关键字)**\n---\n- [ ] 函数依赖与关键字\n* 函数依赖分为：完全函数依赖，部分函数依赖，传递函数依赖。\n- [ ] 范式与关系规范化过程\n\n**规范化：一个低一级范式的关系模式通过模式分解可以转换为多个高一级范式的关系模式的集合** \n\n**规范化的优点：** \n\n1. 大大减少了数据冗余\n2. 改进了数据库整体组织\n3. 增强了数据的一致性\n4. 增加了数据库的设计性\n* 第一范式(列的字段名不可再分)\n* 第二范式(必须满足于一范式，表中非主键列必须完全依赖与任意一个主键位)问题：插入，删除，更新异常，数据冗余。\n* 第三范式(必须满足于第二范式，每个非主键位列与主键不存在传递依赖而是完全依赖)\n* BCNF(必须满足三范式，消去了主属性对键的传递函数依赖)\n---\n\n**数据库操作是在终端下运行的。** \n* 首先是要下载mysql来进行我们的操作\n* 然后就是一些mysql的基本操作了\n---\n\n// 进入到mysql\nmysql -u root -p\n\n// 接下来只需要输入你的密码就行了\npassword:\n\n// 接下来我们就可以直接使用命令来做我们想做的一些基本操作了\n// 显示数据库\nshow databases;\n\n![数据库显示](mysql/mysql0.png) \n\n// 创建你自己的数据库\n\ncreate database xiaogu(数据库名);\n\n// 显示一下数据库\n\nshow databases;\n\n![创建数据库的显示](mysql/mysql1.png) \n\n// 删除自己创建的数据库\n\ndrop database xiaogu;(数据库名)\n\nshow databases;\n\n![删除自己创建的数据库](mysql/mysql2.png) \n\nuse xiaogu(更换数据库)\n\n![更换数据库](mysql/mysql3.png) \n\n// 接下来是对表进行操作了\n\ncreate table xsb(id int(11)not null,name varchar(3),qq int(11));\n\ndesc xsb;\n\ninsert into xsb values(214242,'小灰',24441444);\n\nselect * from xsb;\n\n![表的操作](mysql/mysql4.png) \n\n//更改表名\n\nrename table xsb to 学生表;\n\n![更改表名](mysql/mysql5.png) \n\n// 在表里添加参数\n\nalter table xsb add phone int(11);\n\n// 在表里修改参数\n\nalter table xsb change id _id int(11);\n\n// 在表里删除参数\n\nalter table xsb drop id;\n\nqeqee|eqeqeq|\n|------|------|\n|<++>|<++>|\n","source":"_posts/mysql.md","raw":"---\ntitle: wed\ndate: 2019-09-10 15:12:01\ntags:\n---\n                                       数据库\n<!--more-->\n# 第一节(数据库系统概述)\n1. 数据(date)\n* 是描述事物的符号记录，是指用物理符号记录下来的，可以鉴别的信息。\n---\n2. 数据库(DB)\n* 存储数据的仓库。\n> 特点\n* 永久储存，有组织，可共享。\n----\n3. 数据库管理系统(ABS)\n* 专门用于建立和管理数据库的软件，以及提供必要的安全性和完整性。\n> 功能\n1. 数据定义功能\n2. 数据操纵功能\n3. 数据库的运行管理功能\n4. 数据库的建立和维护功能\n5. 数据有组织,存储和管理功能\n6. 其他功能(通信功能，不同数据库之间数据的相互共享)\n----\n4. 数据库系统(DBS) ----  数据库管理员(DBA)\n# 第二节(数据管理技术的发展)\n* 应用程序管理数据\n*特点* \n* 数据面向应用\n----\n2. 文件管理系统\n*特点* \n* 数据可长期存放在磁盘\n* 数据的逻辑结构与物理结构有了区别\n* 文件组织呈多样化\n* 对数据的操作以记录为单位\n* 数据不再属于某个特定的程序可重复使用\n----\n3. 数据库系统阶段(E,F,code)\n*重大事件* \n* 1968年 美国IBM公司 (层次模型)\n* 1969年 美国 codesy (网状模型)\n* 1970年 美国 EFcode (关系模型)\n*特点* \n1. 数据集成\n2. 数据共享性高\n3. 数据冗余小(文件系统的缺陷)\n4. 数据一致性(文件系统的缺陷)\n5. 数据独立性高(文件系统的缺陷)\n*数据库保护* \n1. 数据的安全性\n2. 数据的完整性\n3. 并发控制\n4. 故障恢复\n# 第三节(数据库系统的结构)\n1. 三级模式的结构\n  外模式(子模式和用户模式)\n* 模式(概念模式和逻辑模式)\n* 内模式(存储模式)\n* 两层映像\n1. 外模式和概念模式(多个)\n2. 逻辑模式和内模式(唯一一个)\n----\n2. 数据库系统的运行与应用结构\n* 用户与服务器结构(C/S)\n* 浏览器与服务器结构(B/S)\n\n# 第四节(数据模型)\n## 1. 数据模型的组成要素\n1. 数据结构(静态特征)\n2. 数据操作(动态特征)\n3. 数据约束(依存关系)\n### 2. 数据模型的分类\n*概念层数据模型* \n* 概念层是数据抽象级别的最高层，其目的是按用户的观点来对世界建模。\n* 可分为：\n1. 实体：客观存在相互区别的食物。\n2. 属性：实体所具有的某种特性。\n3. 码或键：唯一标识实体的属性集。\n4. 域：属性的取值范围。\n5. 实体性：具有相同属性的实体必然具有共同的特征和性质。\n6. 实体集：同型实体的集合。\n7. 联系：事物内部和事物之间是有联系的。\n* 概念模型的表示方法（1：1 ; 1：n ; n:n）\n*逻辑层数据模型* \n1. 层次模型(使用最早)\n2. 网状模型(复杂)\n3. 关系模型(二维表结构，使用最广)\n4. 面向对象模型\n*物理层数据模型* \n* 定义：描述数据在介质上存储，是逻辑模型的物理实现。\n1. 概念模型到逻辑模型的转换是由数据库设计人员完成的。\n2. 逻辑到物理是由数据库管理系统完成的。\n----\n# 第二章 关系数据库\n**第一节关系数据库概述**\n----\n* 特征：是使用关系数据模型来组织数据。(主流数据模型)\n\n**第二节关系数据模型**\n----\n1. 关系数据结构\n* 表：被称为关系，是一个二维表(由表名，构成表的各个列和数据组成)。\n* 关系：可分为三种关系，(基本关系，查询表，视图表)。\n* 列：被称为字段或属性。\n* 属性：和列是同一个意思。\n* 行： 被称为元组或记录。\n* 元组：\n* 分量：元组中的每一个属性值。\n* 码或键()\n---\n\n**关系操作集合**\n1. 查询操作可以分为：选择，投影，连接，除，并，差，交，笛卡尔积，其中选择，投影，并，差，笛卡尔积是五种基础的，(增，删，改，查，插)。\n2. 关系数据语言的分类\n* **结构化查询语言**(SQL)\n* **数据定义语言**(DDL)\n* **数据操纵语言**(DML)\n* **数据控制语言(DCL)**\n3. **关系的完整性约束**\n* *数据库的数据完整性是指：数据库中的数据的正确性，相容性，一致性。*\n\n1.*关系模型中有三类完整性约束：实体完整性约束，参照完整性约束，用户定义完整性约束，其中(实体完整性约束和参照完整性约束是关系的两个不变性)。*\n* **实体关系完整性约束是指：关系的主属性，即主码的组成不能为空。**\n* **参照完整性约束是指：定义在主码和外码之间的引用规则。**\n* **用户定义完整性约束：是针对某一应用环境的完整性约束条件。**\n---\n\n**关系数据库的规范化理论**\n\n*关系模式中可能存在的冗余和异常的问题*\n* 数据冗余\n* 更新异常\n* 插入异常\n* 删除异常\n\n**数据依赖(函数依赖与关键字)**\n---\n- [ ] 函数依赖与关键字\n* 函数依赖分为：完全函数依赖，部分函数依赖，传递函数依赖。\n- [ ] 范式与关系规范化过程\n\n**规范化：一个低一级范式的关系模式通过模式分解可以转换为多个高一级范式的关系模式的集合** \n\n**规范化的优点：** \n\n1. 大大减少了数据冗余\n2. 改进了数据库整体组织\n3. 增强了数据的一致性\n4. 增加了数据库的设计性\n* 第一范式(列的字段名不可再分)\n* 第二范式(必须满足于一范式，表中非主键列必须完全依赖与任意一个主键位)问题：插入，删除，更新异常，数据冗余。\n* 第三范式(必须满足于第二范式，每个非主键位列与主键不存在传递依赖而是完全依赖)\n* BCNF(必须满足三范式，消去了主属性对键的传递函数依赖)\n---\n\n**数据库操作是在终端下运行的。** \n* 首先是要下载mysql来进行我们的操作\n* 然后就是一些mysql的基本操作了\n---\n\n// 进入到mysql\nmysql -u root -p\n\n// 接下来只需要输入你的密码就行了\npassword:\n\n// 接下来我们就可以直接使用命令来做我们想做的一些基本操作了\n// 显示数据库\nshow databases;\n\n![数据库显示](mysql/mysql0.png) \n\n// 创建你自己的数据库\n\ncreate database xiaogu(数据库名);\n\n// 显示一下数据库\n\nshow databases;\n\n![创建数据库的显示](mysql/mysql1.png) \n\n// 删除自己创建的数据库\n\ndrop database xiaogu;(数据库名)\n\nshow databases;\n\n![删除自己创建的数据库](mysql/mysql2.png) \n\nuse xiaogu(更换数据库)\n\n![更换数据库](mysql/mysql3.png) \n\n// 接下来是对表进行操作了\n\ncreate table xsb(id int(11)not null,name varchar(3),qq int(11));\n\ndesc xsb;\n\ninsert into xsb values(214242,'小灰',24441444);\n\nselect * from xsb;\n\n![表的操作](mysql/mysql4.png) \n\n//更改表名\n\nrename table xsb to 学生表;\n\n![更改表名](mysql/mysql5.png) \n\n// 在表里添加参数\n\nalter table xsb add phone int(11);\n\n// 在表里修改参数\n\nalter table xsb change id _id int(11);\n\n// 在表里删除参数\n\nalter table xsb drop id;\n\nqeqee|eqeqeq|\n|------|------|\n|<++>|<++>|\n","slug":"mysql","published":1,"updated":"2019-11-05T07:03:16.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7rp000e4ez72xqe7dv1","content":"<pre><code>数据库\n</code></pre><a id=\"more\"></a>\n<h1 id=\"第一节-数据库系统概述\"><a href=\"#第一节-数据库系统概述\" class=\"headerlink\" title=\"第一节(数据库系统概述)\"></a>第一节(数据库系统概述)</h1><ol>\n<li>数据(date)</li>\n</ol>\n<ul>\n<li>是描述事物的符号记录，是指用物理符号记录下来的，可以鉴别的信息。</li>\n</ul>\n<hr>\n<ol start=\"2\">\n<li>数据库(DB)</li>\n</ol>\n<ul>\n<li>存储数据的仓库。<blockquote>\n<p>特点</p>\n</blockquote>\n</li>\n<li>永久储存，有组织，可共享。</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li>数据库管理系统(ABS)</li>\n</ol>\n<ul>\n<li>专门用于建立和管理数据库的软件，以及提供必要的安全性和完整性。<blockquote>\n<p>功能</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>数据定义功能</li>\n<li>数据操纵功能</li>\n<li>数据库的运行管理功能</li>\n<li>数据库的建立和维护功能</li>\n<li>数据有组织,存储和管理功能</li>\n<li>其他功能(通信功能，不同数据库之间数据的相互共享)</li>\n</ol>\n<hr>\n<ol start=\"4\">\n<li>数据库系统(DBS) —-  数据库管理员(DBA)<h1 id=\"第二节-数据管理技术的发展\"><a href=\"#第二节-数据管理技术的发展\" class=\"headerlink\" title=\"第二节(数据管理技术的发展)\"></a>第二节(数据管理技术的发展)</h1></li>\n</ol>\n<ul>\n<li>应用程序管理数据<br><em>特点</em> </li>\n<li>数据面向应用</li>\n</ul>\n<hr>\n<ol start=\"2\">\n<li>文件管理系统<br><em>特点</em> </li>\n</ol>\n<ul>\n<li>数据可长期存放在磁盘</li>\n<li>数据的逻辑结构与物理结构有了区别</li>\n<li>文件组织呈多样化</li>\n<li>对数据的操作以记录为单位</li>\n<li>数据不再属于某个特定的程序可重复使用</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li>数据库系统阶段(E,F,code)<br><em>重大事件</em> </li>\n</ol>\n<ul>\n<li>1968年 美国IBM公司 (层次模型)</li>\n<li>1969年 美国 codesy (网状模型)</li>\n<li>1970年 美国 EFcode (关系模型)<br><em>特点</em> </li>\n</ul>\n<ol>\n<li>数据集成</li>\n<li>数据共享性高</li>\n<li>数据冗余小(文件系统的缺陷)</li>\n<li>数据一致性(文件系统的缺陷)</li>\n<li>数据独立性高(文件系统的缺陷)<br><em>数据库保护</em> </li>\n<li>数据的安全性</li>\n<li>数据的完整性</li>\n<li>并发控制</li>\n<li>故障恢复<h1 id=\"第三节-数据库系统的结构\"><a href=\"#第三节-数据库系统的结构\" class=\"headerlink\" title=\"第三节(数据库系统的结构)\"></a>第三节(数据库系统的结构)</h1></li>\n<li>三级模式的结构<br>外模式(子模式和用户模式)</li>\n</ol>\n<ul>\n<li>模式(概念模式和逻辑模式)</li>\n<li>内模式(存储模式)</li>\n<li>两层映像</li>\n</ul>\n<ol>\n<li>外模式和概念模式(多个)</li>\n<li>逻辑模式和内模式(唯一一个)</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li>数据库系统的运行与应用结构</li>\n</ol>\n<ul>\n<li>用户与服务器结构(C/S)</li>\n<li>浏览器与服务器结构(B/S)</li>\n</ul>\n<h1 id=\"第四节-数据模型\"><a href=\"#第四节-数据模型\" class=\"headerlink\" title=\"第四节(数据模型)\"></a>第四节(数据模型)</h1><h2 id=\"1-数据模型的组成要素\"><a href=\"#1-数据模型的组成要素\" class=\"headerlink\" title=\"1. 数据模型的组成要素\"></a>1. 数据模型的组成要素</h2><ol>\n<li>数据结构(静态特征)</li>\n<li>数据操作(动态特征)</li>\n<li>数据约束(依存关系)<h3 id=\"2-数据模型的分类\"><a href=\"#2-数据模型的分类\" class=\"headerlink\" title=\"2. 数据模型的分类\"></a>2. 数据模型的分类</h3><em>概念层数据模型</em> </li>\n</ol>\n<ul>\n<li>概念层是数据抽象级别的最高层，其目的是按用户的观点来对世界建模。</li>\n<li>可分为：</li>\n</ul>\n<ol>\n<li>实体：客观存在相互区别的食物。</li>\n<li>属性：实体所具有的某种特性。</li>\n<li>码或键：唯一标识实体的属性集。</li>\n<li>域：属性的取值范围。</li>\n<li>实体性：具有相同属性的实体必然具有共同的特征和性质。</li>\n<li>实体集：同型实体的集合。</li>\n<li>联系：事物内部和事物之间是有联系的。</li>\n</ol>\n<ul>\n<li>概念模型的表示方法（1：1 ; 1：n ; n:n）<br><em>逻辑层数据模型</em> </li>\n</ul>\n<ol>\n<li>层次模型(使用最早)</li>\n<li>网状模型(复杂)</li>\n<li>关系模型(二维表结构，使用最广)</li>\n<li>面向对象模型<br><em>物理层数据模型</em> </li>\n</ol>\n<ul>\n<li>定义：描述数据在介质上存储，是逻辑模型的物理实现。</li>\n</ul>\n<ol>\n<li>概念模型到逻辑模型的转换是由数据库设计人员完成的。</li>\n<li>逻辑到物理是由数据库管理系统完成的。</li>\n</ol>\n<hr>\n<h1 id=\"第二章-关系数据库\"><a href=\"#第二章-关系数据库\" class=\"headerlink\" title=\"第二章 关系数据库\"></a>第二章 关系数据库</h1><h2 id=\"第一节关系数据库概述\"><a href=\"#第一节关系数据库概述\" class=\"headerlink\" title=\"第一节关系数据库概述\"></a><strong>第一节关系数据库概述</strong></h2><ul>\n<li>特征：是使用关系数据模型来组织数据。(主流数据模型)</li>\n</ul>\n<h2 id=\"第二节关系数据模型\"><a href=\"#第二节关系数据模型\" class=\"headerlink\" title=\"第二节关系数据模型\"></a><strong>第二节关系数据模型</strong></h2><ol>\n<li>关系数据结构</li>\n</ol>\n<ul>\n<li>表：被称为关系，是一个二维表(由表名，构成表的各个列和数据组成)。</li>\n<li>关系：可分为三种关系，(基本关系，查询表，视图表)。</li>\n<li>列：被称为字段或属性。</li>\n<li>属性：和列是同一个意思。</li>\n<li>行： 被称为元组或记录。</li>\n<li>元组：</li>\n<li>分量：元组中的每一个属性值。</li>\n<li>码或键()</li>\n</ul>\n<hr>\n<p><strong>关系操作集合</strong></p>\n<ol>\n<li>查询操作可以分为：选择，投影，连接，除，并，差，交，笛卡尔积，其中选择，投影，并，差，笛卡尔积是五种基础的，(增，删，改，查，插)。</li>\n<li>关系数据语言的分类</li>\n</ol>\n<ul>\n<li><strong>结构化查询语言</strong>(SQL)</li>\n<li><strong>数据定义语言</strong>(DDL)</li>\n<li><strong>数据操纵语言</strong>(DML)</li>\n<li><strong>数据控制语言(DCL)</strong></li>\n</ul>\n<ol start=\"3\">\n<li><strong>关系的完整性约束</strong></li>\n</ol>\n<ul>\n<li><em>数据库的数据完整性是指：数据库中的数据的正确性，相容性，一致性。</em></li>\n</ul>\n<p>1.<em>关系模型中有三类完整性约束：实体完整性约束，参照完整性约束，用户定义完整性约束，其中(实体完整性约束和参照完整性约束是关系的两个不变性)。</em></p>\n<ul>\n<li><strong>实体关系完整性约束是指：关系的主属性，即主码的组成不能为空。</strong></li>\n<li><strong>参照完整性约束是指：定义在主码和外码之间的引用规则。</strong></li>\n<li><strong>用户定义完整性约束：是针对某一应用环境的完整性约束条件。</strong></li>\n</ul>\n<hr>\n<p><strong>关系数据库的规范化理论</strong></p>\n<p><em>关系模式中可能存在的冗余和异常的问题</em></p>\n<ul>\n<li>数据冗余</li>\n<li>更新异常</li>\n<li>插入异常</li>\n<li>删除异常</li>\n</ul>\n<h2 id=\"数据依赖-函数依赖与关键字\"><a href=\"#数据依赖-函数依赖与关键字\" class=\"headerlink\" title=\"数据依赖(函数依赖与关键字)\"></a><strong>数据依赖(函数依赖与关键字)</strong></h2><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 函数依赖与关键字</li>\n</ul>\n<ul>\n<li>函数依赖分为：完全函数依赖，部分函数依赖，传递函数依赖。</li>\n</ul>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 范式与关系规范化过程</li>\n</ul>\n<p><strong>规范化：一个低一级范式的关系模式通过模式分解可以转换为多个高一级范式的关系模式的集合</strong> </p>\n<p><strong>规范化的优点：</strong> </p>\n<ol>\n<li>大大减少了数据冗余</li>\n<li>改进了数据库整体组织</li>\n<li>增强了数据的一致性</li>\n<li>增加了数据库的设计性</li>\n</ol>\n<ul>\n<li>第一范式(列的字段名不可再分)</li>\n<li>第二范式(必须满足于一范式，表中非主键列必须完全依赖与任意一个主键位)问题：插入，删除，更新异常，数据冗余。</li>\n<li>第三范式(必须满足于第二范式，每个非主键位列与主键不存在传递依赖而是完全依赖)</li>\n<li>BCNF(必须满足三范式，消去了主属性对键的传递函数依赖)</li>\n</ul>\n<hr>\n<p><strong>数据库操作是在终端下运行的。</strong> </p>\n<ul>\n<li>首先是要下载mysql来进行我们的操作</li>\n<li>然后就是一些mysql的基本操作了</li>\n</ul>\n<hr>\n<p>// 进入到mysql<br>mysql -u root -p</p>\n<p>// 接下来只需要输入你的密码就行了<br>password:</p>\n<p>// 接下来我们就可以直接使用命令来做我们想做的一些基本操作了<br>// 显示数据库<br>show databases;</p>\n<p><img src=\"/2019/09/10/mysql/mysql0.png\" alt=\"数据库显示\"> </p>\n<p>// 创建你自己的数据库</p>\n<p>create database xiaogu(数据库名);</p>\n<p>// 显示一下数据库</p>\n<p>show databases;</p>\n<p><img src=\"/2019/09/10/mysql/mysql1.png\" alt=\"创建数据库的显示\"> </p>\n<p>// 删除自己创建的数据库</p>\n<p>drop database xiaogu;(数据库名)</p>\n<p>show databases;</p>\n<p><img src=\"/2019/09/10/mysql/mysql2.png\" alt=\"删除自己创建的数据库\"> </p>\n<p>use xiaogu(更换数据库)</p>\n<p><img src=\"/2019/09/10/mysql/mysql3.png\" alt=\"更换数据库\"> </p>\n<p>// 接下来是对表进行操作了</p>\n<p>create table xsb(id int(11)not null,name varchar(3),qq int(11));</p>\n<p>desc xsb;</p>\n<p>insert into xsb values(214242,’小灰’,24441444);</p>\n<p>select * from xsb;</p>\n<p><img src=\"/2019/09/10/mysql/mysql4.png\" alt=\"表的操作\"> </p>\n<p>//更改表名</p>\n<p>rename table xsb to 学生表;</p>\n<p><img src=\"/2019/09/10/mysql/mysql5.png\" alt=\"更改表名\"> </p>\n<p>// 在表里添加参数</p>\n<p>alter table xsb add phone int(11);</p>\n<p>// 在表里修改参数</p>\n<p>alter table xsb change id _id int(11);</p>\n<p>// 在表里删除参数</p>\n<p>alter table xsb drop id;</p>\n<p>qeqee|eqeqeq|<br>|——|——|<br>|&lt;++&gt;|&lt;++&gt;|</p>\n","site":{"data":{}},"excerpt":"<pre><code>数据库\n</code></pre>","more":"<h1 id=\"第一节-数据库系统概述\"><a href=\"#第一节-数据库系统概述\" class=\"headerlink\" title=\"第一节(数据库系统概述)\"></a>第一节(数据库系统概述)</h1><ol>\n<li>数据(date)</li>\n</ol>\n<ul>\n<li>是描述事物的符号记录，是指用物理符号记录下来的，可以鉴别的信息。</li>\n</ul>\n<hr>\n<ol start=\"2\">\n<li>数据库(DB)</li>\n</ol>\n<ul>\n<li>存储数据的仓库。<blockquote>\n<p>特点</p>\n</blockquote>\n</li>\n<li>永久储存，有组织，可共享。</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li>数据库管理系统(ABS)</li>\n</ol>\n<ul>\n<li>专门用于建立和管理数据库的软件，以及提供必要的安全性和完整性。<blockquote>\n<p>功能</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>数据定义功能</li>\n<li>数据操纵功能</li>\n<li>数据库的运行管理功能</li>\n<li>数据库的建立和维护功能</li>\n<li>数据有组织,存储和管理功能</li>\n<li>其他功能(通信功能，不同数据库之间数据的相互共享)</li>\n</ol>\n<hr>\n<ol start=\"4\">\n<li>数据库系统(DBS) —-  数据库管理员(DBA)<h1 id=\"第二节-数据管理技术的发展\"><a href=\"#第二节-数据管理技术的发展\" class=\"headerlink\" title=\"第二节(数据管理技术的发展)\"></a>第二节(数据管理技术的发展)</h1></li>\n</ol>\n<ul>\n<li>应用程序管理数据<br><em>特点</em> </li>\n<li>数据面向应用</li>\n</ul>\n<hr>\n<ol start=\"2\">\n<li>文件管理系统<br><em>特点</em> </li>\n</ol>\n<ul>\n<li>数据可长期存放在磁盘</li>\n<li>数据的逻辑结构与物理结构有了区别</li>\n<li>文件组织呈多样化</li>\n<li>对数据的操作以记录为单位</li>\n<li>数据不再属于某个特定的程序可重复使用</li>\n</ul>\n<hr>\n<ol start=\"3\">\n<li>数据库系统阶段(E,F,code)<br><em>重大事件</em> </li>\n</ol>\n<ul>\n<li>1968年 美国IBM公司 (层次模型)</li>\n<li>1969年 美国 codesy (网状模型)</li>\n<li>1970年 美国 EFcode (关系模型)<br><em>特点</em> </li>\n</ul>\n<ol>\n<li>数据集成</li>\n<li>数据共享性高</li>\n<li>数据冗余小(文件系统的缺陷)</li>\n<li>数据一致性(文件系统的缺陷)</li>\n<li>数据独立性高(文件系统的缺陷)<br><em>数据库保护</em> </li>\n<li>数据的安全性</li>\n<li>数据的完整性</li>\n<li>并发控制</li>\n<li>故障恢复<h1 id=\"第三节-数据库系统的结构\"><a href=\"#第三节-数据库系统的结构\" class=\"headerlink\" title=\"第三节(数据库系统的结构)\"></a>第三节(数据库系统的结构)</h1></li>\n<li>三级模式的结构<br>外模式(子模式和用户模式)</li>\n</ol>\n<ul>\n<li>模式(概念模式和逻辑模式)</li>\n<li>内模式(存储模式)</li>\n<li>两层映像</li>\n</ul>\n<ol>\n<li>外模式和概念模式(多个)</li>\n<li>逻辑模式和内模式(唯一一个)</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li>数据库系统的运行与应用结构</li>\n</ol>\n<ul>\n<li>用户与服务器结构(C/S)</li>\n<li>浏览器与服务器结构(B/S)</li>\n</ul>\n<h1 id=\"第四节-数据模型\"><a href=\"#第四节-数据模型\" class=\"headerlink\" title=\"第四节(数据模型)\"></a>第四节(数据模型)</h1><h2 id=\"1-数据模型的组成要素\"><a href=\"#1-数据模型的组成要素\" class=\"headerlink\" title=\"1. 数据模型的组成要素\"></a>1. 数据模型的组成要素</h2><ol>\n<li>数据结构(静态特征)</li>\n<li>数据操作(动态特征)</li>\n<li>数据约束(依存关系)<h3 id=\"2-数据模型的分类\"><a href=\"#2-数据模型的分类\" class=\"headerlink\" title=\"2. 数据模型的分类\"></a>2. 数据模型的分类</h3><em>概念层数据模型</em> </li>\n</ol>\n<ul>\n<li>概念层是数据抽象级别的最高层，其目的是按用户的观点来对世界建模。</li>\n<li>可分为：</li>\n</ul>\n<ol>\n<li>实体：客观存在相互区别的食物。</li>\n<li>属性：实体所具有的某种特性。</li>\n<li>码或键：唯一标识实体的属性集。</li>\n<li>域：属性的取值范围。</li>\n<li>实体性：具有相同属性的实体必然具有共同的特征和性质。</li>\n<li>实体集：同型实体的集合。</li>\n<li>联系：事物内部和事物之间是有联系的。</li>\n</ol>\n<ul>\n<li>概念模型的表示方法（1：1 ; 1：n ; n:n）<br><em>逻辑层数据模型</em> </li>\n</ul>\n<ol>\n<li>层次模型(使用最早)</li>\n<li>网状模型(复杂)</li>\n<li>关系模型(二维表结构，使用最广)</li>\n<li>面向对象模型<br><em>物理层数据模型</em> </li>\n</ol>\n<ul>\n<li>定义：描述数据在介质上存储，是逻辑模型的物理实现。</li>\n</ul>\n<ol>\n<li>概念模型到逻辑模型的转换是由数据库设计人员完成的。</li>\n<li>逻辑到物理是由数据库管理系统完成的。</li>\n</ol>\n<hr>\n<h1 id=\"第二章-关系数据库\"><a href=\"#第二章-关系数据库\" class=\"headerlink\" title=\"第二章 关系数据库\"></a>第二章 关系数据库</h1><h2 id=\"第一节关系数据库概述\"><a href=\"#第一节关系数据库概述\" class=\"headerlink\" title=\"第一节关系数据库概述\"></a><strong>第一节关系数据库概述</strong></h2><ul>\n<li>特征：是使用关系数据模型来组织数据。(主流数据模型)</li>\n</ul>\n<h2 id=\"第二节关系数据模型\"><a href=\"#第二节关系数据模型\" class=\"headerlink\" title=\"第二节关系数据模型\"></a><strong>第二节关系数据模型</strong></h2><ol>\n<li>关系数据结构</li>\n</ol>\n<ul>\n<li>表：被称为关系，是一个二维表(由表名，构成表的各个列和数据组成)。</li>\n<li>关系：可分为三种关系，(基本关系，查询表，视图表)。</li>\n<li>列：被称为字段或属性。</li>\n<li>属性：和列是同一个意思。</li>\n<li>行： 被称为元组或记录。</li>\n<li>元组：</li>\n<li>分量：元组中的每一个属性值。</li>\n<li>码或键()</li>\n</ul>\n<hr>\n<p><strong>关系操作集合</strong></p>\n<ol>\n<li>查询操作可以分为：选择，投影，连接，除，并，差，交，笛卡尔积，其中选择，投影，并，差，笛卡尔积是五种基础的，(增，删，改，查，插)。</li>\n<li>关系数据语言的分类</li>\n</ol>\n<ul>\n<li><strong>结构化查询语言</strong>(SQL)</li>\n<li><strong>数据定义语言</strong>(DDL)</li>\n<li><strong>数据操纵语言</strong>(DML)</li>\n<li><strong>数据控制语言(DCL)</strong></li>\n</ul>\n<ol start=\"3\">\n<li><strong>关系的完整性约束</strong></li>\n</ol>\n<ul>\n<li><em>数据库的数据完整性是指：数据库中的数据的正确性，相容性，一致性。</em></li>\n</ul>\n<p>1.<em>关系模型中有三类完整性约束：实体完整性约束，参照完整性约束，用户定义完整性约束，其中(实体完整性约束和参照完整性约束是关系的两个不变性)。</em></p>\n<ul>\n<li><strong>实体关系完整性约束是指：关系的主属性，即主码的组成不能为空。</strong></li>\n<li><strong>参照完整性约束是指：定义在主码和外码之间的引用规则。</strong></li>\n<li><strong>用户定义完整性约束：是针对某一应用环境的完整性约束条件。</strong></li>\n</ul>\n<hr>\n<p><strong>关系数据库的规范化理论</strong></p>\n<p><em>关系模式中可能存在的冗余和异常的问题</em></p>\n<ul>\n<li>数据冗余</li>\n<li>更新异常</li>\n<li>插入异常</li>\n<li>删除异常</li>\n</ul>\n<h2 id=\"数据依赖-函数依赖与关键字\"><a href=\"#数据依赖-函数依赖与关键字\" class=\"headerlink\" title=\"数据依赖(函数依赖与关键字)\"></a><strong>数据依赖(函数依赖与关键字)</strong></h2><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 函数依赖与关键字</li>\n</ul>\n<ul>\n<li>函数依赖分为：完全函数依赖，部分函数依赖，传递函数依赖。</li>\n</ul>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 范式与关系规范化过程</li>\n</ul>\n<p><strong>规范化：一个低一级范式的关系模式通过模式分解可以转换为多个高一级范式的关系模式的集合</strong> </p>\n<p><strong>规范化的优点：</strong> </p>\n<ol>\n<li>大大减少了数据冗余</li>\n<li>改进了数据库整体组织</li>\n<li>增强了数据的一致性</li>\n<li>增加了数据库的设计性</li>\n</ol>\n<ul>\n<li>第一范式(列的字段名不可再分)</li>\n<li>第二范式(必须满足于一范式，表中非主键列必须完全依赖与任意一个主键位)问题：插入，删除，更新异常，数据冗余。</li>\n<li>第三范式(必须满足于第二范式，每个非主键位列与主键不存在传递依赖而是完全依赖)</li>\n<li>BCNF(必须满足三范式，消去了主属性对键的传递函数依赖)</li>\n</ul>\n<hr>\n<p><strong>数据库操作是在终端下运行的。</strong> </p>\n<ul>\n<li>首先是要下载mysql来进行我们的操作</li>\n<li>然后就是一些mysql的基本操作了</li>\n</ul>\n<hr>\n<p>// 进入到mysql<br>mysql -u root -p</p>\n<p>// 接下来只需要输入你的密码就行了<br>password:</p>\n<p>// 接下来我们就可以直接使用命令来做我们想做的一些基本操作了<br>// 显示数据库<br>show databases;</p>\n<p><img src=\"/2019/09/10/mysql/mysql0.png\" alt=\"数据库显示\"> </p>\n<p>// 创建你自己的数据库</p>\n<p>create database xiaogu(数据库名);</p>\n<p>// 显示一下数据库</p>\n<p>show databases;</p>\n<p><img src=\"/2019/09/10/mysql/mysql1.png\" alt=\"创建数据库的显示\"> </p>\n<p>// 删除自己创建的数据库</p>\n<p>drop database xiaogu;(数据库名)</p>\n<p>show databases;</p>\n<p><img src=\"/2019/09/10/mysql/mysql2.png\" alt=\"删除自己创建的数据库\"> </p>\n<p>use xiaogu(更换数据库)</p>\n<p><img src=\"/2019/09/10/mysql/mysql3.png\" alt=\"更换数据库\"> </p>\n<p>// 接下来是对表进行操作了</p>\n<p>create table xsb(id int(11)not null,name varchar(3),qq int(11));</p>\n<p>desc xsb;</p>\n<p>insert into xsb values(214242,’小灰’,24441444);</p>\n<p>select * from xsb;</p>\n<p><img src=\"/2019/09/10/mysql/mysql4.png\" alt=\"表的操作\"> </p>\n<p>//更改表名</p>\n<p>rename table xsb to 学生表;</p>\n<p><img src=\"/2019/09/10/mysql/mysql5.png\" alt=\"更改表名\"> </p>\n<p>// 在表里添加参数</p>\n<p>alter table xsb add phone int(11);</p>\n<p>// 在表里修改参数</p>\n<p>alter table xsb change id _id int(11);</p>\n<p>// 在表里删除参数</p>\n<p>alter table xsb drop id;</p>\n<p>qeqee|eqeqeq|<br>|——|——|<br>|&lt;++&gt;|&lt;++&gt;|</p>"},{"title":"tar","date":"2019-06-03T09:55:22.000Z","_content":"注释\n<!--more-->\n# TAR\n**tar(打包命令)也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令**\n---\n//声明:test1,test2,是存在的文件，也是你接下来要操作的文件。\n1. tar -cf file.tar test1    \n//这里是把test1这个文件打包在一个file.tar的包里面,这里的c是创建一个文件，f后面是紧跟这文件名。\n2. tar -rf file.tar test2\n//这里是把test2追加到file.tar文件中,r是追加。\n3. tar -uf file.tar\n//这里是把刚刚的file.tar文件更新，u是更新的意思。\n4. tar -tf file.tar\n//这里是把file.tar文件的内容列出来，t是查看文件中的内容。\n5. tar -xf file.tar\n解压file.tar文件\n**值得注意的是后面跟着的一定要是文件名！！！**\n> tar调用gzip\n* tar -czf filetest1.tar.gz file1\n//调用gzip要使用-z的参数，意思是和上面一样的，c是创建一个文件，f后面紧跟着文件名。 \n* tar -xzf filetest1.tar.gz\n//解压上面的文件\n>> 压缩\n1. 上面是用tar打包，这里就是用zip压缩。\nzip -r test3.zip file.tar\n//这里是把上面的文件压缩到新的文件。\nunzip test3.zip\n//解压。\n**在这里文件的后缀名很重要，因为这关系着我们的文件性质，有的时候你会因为文件的后缀名而把你自己搞自闭，**\n**所以你要在每次操作文件之前要想清楚操作之后的文件的后缀是什么类型的，也要接的上你将要操作文件的后缀,**\n**不能说，前一个文件后缀和你后面的文件的后缀不一样，这样也是不可以的。**\n---\n![ta](tar/tar.png)\n***\n**压缩的方法有多种，但我觉得也没必要都记住，因为大多数都只是参数不一样而已，大多的格式是一样的。**\n**只要我们能在工作中解决自身的小问题就行，其它的，慢慢就会记住的，在这里我还是挺赞同小伙子说的一句话。**\n**你想要最短的时间学会你想学的东西，你就一定要多去用它，这样你才是最快的掌握它。**\n***\n![](tar/tar1.png)\n#### 无标题\n1. 我是从下午四点多学到现在的，中间尝试了很多，自己也就慢慢的理解了，接下来也就是有事没事就操作一波的事情。\n2. 感觉linux要完全掌握真的不是一件简单的事情，要一步一步的走向它，你得慢慢地去学，我希望以后的自己是每天都有学习的，因为我是这么想的，但偶尔给自己放放假也是可以的,因为你是人，不是一个冷冰冰的机器，你有开心，难过，伤心，烦躁的时候，但你随着时间的流逝，有时你的年龄是不允许你做的一些事情，没有小时候的随心所欲，在别人的眼里只不过是一个小孩子的幼稚而已。\n3. 七月的风，八月的雨，卑微的我喜欢遥远的你。\n","source":"_posts/tar.md","raw":"---\ntitle: tar\ndate: 2019-06-03 17:55:22\ntags:\n---\n注释\n<!--more-->\n# TAR\n**tar(打包命令)也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令**\n---\n//声明:test1,test2,是存在的文件，也是你接下来要操作的文件。\n1. tar -cf file.tar test1    \n//这里是把test1这个文件打包在一个file.tar的包里面,这里的c是创建一个文件，f后面是紧跟这文件名。\n2. tar -rf file.tar test2\n//这里是把test2追加到file.tar文件中,r是追加。\n3. tar -uf file.tar\n//这里是把刚刚的file.tar文件更新，u是更新的意思。\n4. tar -tf file.tar\n//这里是把file.tar文件的内容列出来，t是查看文件中的内容。\n5. tar -xf file.tar\n解压file.tar文件\n**值得注意的是后面跟着的一定要是文件名！！！**\n> tar调用gzip\n* tar -czf filetest1.tar.gz file1\n//调用gzip要使用-z的参数，意思是和上面一样的，c是创建一个文件，f后面紧跟着文件名。 \n* tar -xzf filetest1.tar.gz\n//解压上面的文件\n>> 压缩\n1. 上面是用tar打包，这里就是用zip压缩。\nzip -r test3.zip file.tar\n//这里是把上面的文件压缩到新的文件。\nunzip test3.zip\n//解压。\n**在这里文件的后缀名很重要，因为这关系着我们的文件性质，有的时候你会因为文件的后缀名而把你自己搞自闭，**\n**所以你要在每次操作文件之前要想清楚操作之后的文件的后缀是什么类型的，也要接的上你将要操作文件的后缀,**\n**不能说，前一个文件后缀和你后面的文件的后缀不一样，这样也是不可以的。**\n---\n![ta](tar/tar.png)\n***\n**压缩的方法有多种，但我觉得也没必要都记住，因为大多数都只是参数不一样而已，大多的格式是一样的。**\n**只要我们能在工作中解决自身的小问题就行，其它的，慢慢就会记住的，在这里我还是挺赞同小伙子说的一句话。**\n**你想要最短的时间学会你想学的东西，你就一定要多去用它，这样你才是最快的掌握它。**\n***\n![](tar/tar1.png)\n#### 无标题\n1. 我是从下午四点多学到现在的，中间尝试了很多，自己也就慢慢的理解了，接下来也就是有事没事就操作一波的事情。\n2. 感觉linux要完全掌握真的不是一件简单的事情，要一步一步的走向它，你得慢慢地去学，我希望以后的自己是每天都有学习的，因为我是这么想的，但偶尔给自己放放假也是可以的,因为你是人，不是一个冷冰冰的机器，你有开心，难过，伤心，烦躁的时候，但你随着时间的流逝，有时你的年龄是不允许你做的一些事情，没有小时候的随心所欲，在别人的眼里只不过是一个小孩子的幼稚而已。\n3. 七月的风，八月的雨，卑微的我喜欢遥远的你。\n","slug":"tar","published":1,"updated":"2019-09-10T09:09:34.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7rr000g4ez7cave8c25","content":"<p>注释<br><a id=\"more\"></a></p>\n<h1 id=\"TAR\"><a href=\"#TAR\" class=\"headerlink\" title=\"TAR\"></a>TAR</h1><h2 id=\"tar-打包命令-也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令\"><a href=\"#tar-打包命令-也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令\" class=\"headerlink\" title=\"tar(打包命令)也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令\"></a><strong>tar(打包命令)也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令</strong></h2><p>//声明:test1,test2,是存在的文件，也是你接下来要操作的文件。</p>\n<ol>\n<li>tar -cf file.tar test1<br>//这里是把test1这个文件打包在一个file.tar的包里面,这里的c是创建一个文件，f后面是紧跟这文件名。</li>\n<li>tar -rf file.tar test2<br>//这里是把test2追加到file.tar文件中,r是追加。</li>\n<li>tar -uf file.tar<br>//这里是把刚刚的file.tar文件更新，u是更新的意思。</li>\n<li>tar -tf file.tar<br>//这里是把file.tar文件的内容列出来，t是查看文件中的内容。</li>\n<li>tar -xf file.tar<br>解压file.tar文件<br><strong>值得注意的是后面跟着的一定要是文件名！！！</strong><blockquote>\n<p>tar调用gzip</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>tar -czf filetest1.tar.gz file1<br>//调用gzip要使用-z的参数，意思是和上面一样的，c是创建一个文件，f后面紧跟着文件名。 </li>\n<li>tar -xzf filetest1.tar.gz<br>//解压上面的文件<blockquote>\n<blockquote>\n<p>压缩</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>上面是用tar打包，这里就是用zip压缩。<br>zip -r test3.zip file.tar<br>//这里是把上面的文件压缩到新的文件。<br>unzip test3.zip<br>//解压。<br><strong>在这里文件的后缀名很重要，因为这关系着我们的文件性质，有的时候你会因为文件的后缀名而把你自己搞自闭，</strong><br><strong>所以你要在每次操作文件之前要想清楚操作之后的文件的后缀是什么类型的，也要接的上你将要操作文件的后缀,</strong><br><strong>不能说，前一个文件后缀和你后面的文件的后缀不一样，这样也是不可以的。</strong></li>\n</ol>\n<hr>\n<p><img src=\"/2019/06/03/tar/tar.png\" alt=\"ta\"></p>\n<hr>\n<p><strong>压缩的方法有多种，但我觉得也没必要都记住，因为大多数都只是参数不一样而已，大多的格式是一样的。</strong><br><strong>只要我们能在工作中解决自身的小问题就行，其它的，慢慢就会记住的，在这里我还是挺赞同小伙子说的一句话。</strong><br><strong>你想要最短的时间学会你想学的东西，你就一定要多去用它，这样你才是最快的掌握它。</strong></p>\n<hr>\n<p><img src=\"/2019/06/03/tar/tar1.png\" alt></p>\n<h4 id=\"无标题\"><a href=\"#无标题\" class=\"headerlink\" title=\"无标题\"></a>无标题</h4><ol>\n<li>我是从下午四点多学到现在的，中间尝试了很多，自己也就慢慢的理解了，接下来也就是有事没事就操作一波的事情。</li>\n<li>感觉linux要完全掌握真的不是一件简单的事情，要一步一步的走向它，你得慢慢地去学，我希望以后的自己是每天都有学习的，因为我是这么想的，但偶尔给自己放放假也是可以的,因为你是人，不是一个冷冰冰的机器，你有开心，难过，伤心，烦躁的时候，但你随着时间的流逝，有时你的年龄是不允许你做的一些事情，没有小时候的随心所欲，在别人的眼里只不过是一个小孩子的幼稚而已。</li>\n<li>七月的风，八月的雨，卑微的我喜欢遥远的你。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>注释<br></p>","more":"<p></p>\n<h1 id=\"TAR\"><a href=\"#TAR\" class=\"headerlink\" title=\"TAR\"></a>TAR</h1><h2 id=\"tar-打包命令-也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令\"><a href=\"#tar-打包命令-也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令\" class=\"headerlink\" title=\"tar(打包命令)也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令\"></a><strong>tar(打包命令)也可以说是备份，在我们管理文件的时候有很多的好处，当我们的文件各自的位置不一样的时候这时就是打包发挥的时候了。你只需要一条命令就可解决这些傻逼问题，下面是一些tar常用的命令</strong></h2><p>//声明:test1,test2,是存在的文件，也是你接下来要操作的文件。</p>\n<ol>\n<li>tar -cf file.tar test1<br>//这里是把test1这个文件打包在一个file.tar的包里面,这里的c是创建一个文件，f后面是紧跟这文件名。</li>\n<li>tar -rf file.tar test2<br>//这里是把test2追加到file.tar文件中,r是追加。</li>\n<li>tar -uf file.tar<br>//这里是把刚刚的file.tar文件更新，u是更新的意思。</li>\n<li>tar -tf file.tar<br>//这里是把file.tar文件的内容列出来，t是查看文件中的内容。</li>\n<li>tar -xf file.tar<br>解压file.tar文件<br><strong>值得注意的是后面跟着的一定要是文件名！！！</strong><blockquote>\n<p>tar调用gzip</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>tar -czf filetest1.tar.gz file1<br>//调用gzip要使用-z的参数，意思是和上面一样的，c是创建一个文件，f后面紧跟着文件名。 </li>\n<li>tar -xzf filetest1.tar.gz<br>//解压上面的文件<blockquote>\n<blockquote>\n<p>压缩</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>上面是用tar打包，这里就是用zip压缩。<br>zip -r test3.zip file.tar<br>//这里是把上面的文件压缩到新的文件。<br>unzip test3.zip<br>//解压。<br><strong>在这里文件的后缀名很重要，因为这关系着我们的文件性质，有的时候你会因为文件的后缀名而把你自己搞自闭，</strong><br><strong>所以你要在每次操作文件之前要想清楚操作之后的文件的后缀是什么类型的，也要接的上你将要操作文件的后缀,</strong><br><strong>不能说，前一个文件后缀和你后面的文件的后缀不一样，这样也是不可以的。</strong></li>\n</ol>\n<hr>\n<p><img src=\"/2019/06/03/tar/tar.png\" alt=\"ta\"></p>\n<hr>\n<p><strong>压缩的方法有多种，但我觉得也没必要都记住，因为大多数都只是参数不一样而已，大多的格式是一样的。</strong><br><strong>只要我们能在工作中解决自身的小问题就行，其它的，慢慢就会记住的，在这里我还是挺赞同小伙子说的一句话。</strong><br><strong>你想要最短的时间学会你想学的东西，你就一定要多去用它，这样你才是最快的掌握它。</strong></p>\n<hr>\n<p><img src=\"/2019/06/03/tar/tar1.png\" alt></p>\n<h4 id=\"无标题\"><a href=\"#无标题\" class=\"headerlink\" title=\"无标题\"></a>无标题</h4><ol>\n<li>我是从下午四点多学到现在的，中间尝试了很多，自己也就慢慢的理解了，接下来也就是有事没事就操作一波的事情。</li>\n<li>感觉linux要完全掌握真的不是一件简单的事情，要一步一步的走向它，你得慢慢地去学，我希望以后的自己是每天都有学习的，因为我是这么想的，但偶尔给自己放放假也是可以的,因为你是人，不是一个冷冰冰的机器，你有开心，难过，伤心，烦躁的时候，但你随着时间的流逝，有时你的年龄是不允许你做的一些事情，没有小时候的随心所欲，在别人的眼里只不过是一个小孩子的幼稚而已。</li>\n<li>七月的风，八月的雨，卑微的我喜欢遥远的你。</li>\n</ol>"},{"title":"test","date":"2019-05-31T13:43:15.000Z","_content":"注释\n<!--more-->\n","source":"_posts/test-1.md","raw":"---\ntitle: test\ndate: 2019-05-31 21:43:15\ntags:\n---\n注释\n<!--more-->\n","slug":"test-1","published":1,"updated":"2019-09-12T07:16:43.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7rs000h4ez7zuc9t2jv","content":"<p>注释<br><a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<p>注释<br></p>","more":"<p></p>"},{"title":"test","date":"2019-11-25T00:37:21.000Z","_content":"\n![test](Java/java4.png)\n\n","source":"_posts/test-2.md","raw":"---\ntitle: test\ndate: 2019-11-25 08:37:21\ntags:\n---\n\n![test](Java/java4.png)\n\n","slug":"test-2","published":1,"updated":"2019-11-25T00:39:08.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7rt000i4ez7xxycsueh","content":"<p><img src=\"/2019/11/25/test-2/java4.png\" alt=\"test\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/11/25/test-2/java4.png\" alt=\"test\"></p>\n"},{"title":"test","date":"2019-05-19T14:37:18.000Z","_content":"注释\n<!--more-->\n\n# 小新\n\n![小新](test/a.jpg)\n# one\n**我现在有点想睡觉，但也是说给自己看看的，随便也就说说心里话。我刚开始是有点词穷的。但我也不慌，因为我刚刚听到了一首歌的歌词很不错，我刚刚也是想写下来的，但一下子想不起来，这可能是瞬时的记忆，导致我记不起来更细致的记忆，没有梦想何必远方。这是刚刚有出来的歌词，我感觉自己运气还是不错的。因为我最后还是记起来了，有点小开心。**\n\n----\n# two\n我手会出汗，这让我平时有点很不开心，也不能说很吧，但就是自闭，我也不，知道怎么才能不出汗，据说要做个小手术，要割弃汗腺。我怕啊。我的身体还是刚从我妈身体刚出来的时候，~~只是某些地方随着时间的流逝而变大~~这个我也不想的，因为太大了，这在我日常生活中有点不好。很真实，幸好我是靠着墙的，对于我说了那么多，也就只有我一个人看得见，不然我也不会写这些让小姐姐脸红的文字。这个我说的有点肯定了，小姐姐看到了也不一定会脸红，因为现在的小姐姐都是见过大世面的人物，我在她们眼里也就只是小垃圾。\n\n----\n# three\n> 此时此刻我只想吟诗一首\n>> 我随口一说就是古诗\n>>> 当时的李白心里想的肯定是这样的\n>>>> 我是最厉害的，喝酒第一，造人第二，造诗第三。\n>>>>> 但他万万没想到最后自己最不想做的事情的反而实现了。并让后人传颂至今。\n\n----\n# four\n**总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。**\n----\n----\n**本故事纯属虚构，要想逼逼，随时见证，**\n----\n\n","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2019-05-19 22:37:18\ntags:\n---\n注释\n<!--more-->\n\n# 小新\n\n![小新](test/a.jpg)\n# one\n**我现在有点想睡觉，但也是说给自己看看的，随便也就说说心里话。我刚开始是有点词穷的。但我也不慌，因为我刚刚听到了一首歌的歌词很不错，我刚刚也是想写下来的，但一下子想不起来，这可能是瞬时的记忆，导致我记不起来更细致的记忆，没有梦想何必远方。这是刚刚有出来的歌词，我感觉自己运气还是不错的。因为我最后还是记起来了，有点小开心。**\n\n----\n# two\n我手会出汗，这让我平时有点很不开心，也不能说很吧，但就是自闭，我也不，知道怎么才能不出汗，据说要做个小手术，要割弃汗腺。我怕啊。我的身体还是刚从我妈身体刚出来的时候，~~只是某些地方随着时间的流逝而变大~~这个我也不想的，因为太大了，这在我日常生活中有点不好。很真实，幸好我是靠着墙的，对于我说了那么多，也就只有我一个人看得见，不然我也不会写这些让小姐姐脸红的文字。这个我说的有点肯定了，小姐姐看到了也不一定会脸红，因为现在的小姐姐都是见过大世面的人物，我在她们眼里也就只是小垃圾。\n\n----\n# three\n> 此时此刻我只想吟诗一首\n>> 我随口一说就是古诗\n>>> 当时的李白心里想的肯定是这样的\n>>>> 我是最厉害的，喝酒第一，造人第二，造诗第三。\n>>>>> 但他万万没想到最后自己最不想做的事情的反而实现了。并让后人传颂至今。\n\n----\n# four\n**总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。**\n----\n----\n**本故事纯属虚构，要想逼逼，随时见证，**\n----\n\n","slug":"test","published":1,"updated":"2019-09-12T07:15:56.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7ru000j4ez797cw9x6j","content":"<p>注释<br><a id=\"more\"></a></p>\n<h1 id=\"小新\"><a href=\"#小新\" class=\"headerlink\" title=\"小新\"></a>小新</h1><p><img src=\"/2019/05/19/test/a.jpg\" alt=\"小新\"></p>\n<h1 id=\"one\"><a href=\"#one\" class=\"headerlink\" title=\"one\"></a>one</h1><p><strong>我现在有点想睡觉，但也是说给自己看看的，随便也就说说心里话。我刚开始是有点词穷的。但我也不慌，因为我刚刚听到了一首歌的歌词很不错，我刚刚也是想写下来的，但一下子想不起来，这可能是瞬时的记忆，导致我记不起来更细致的记忆，没有梦想何必远方。这是刚刚有出来的歌词，我感觉自己运气还是不错的。因为我最后还是记起来了，有点小开心。</strong></p>\n<hr>\n<h1 id=\"two\"><a href=\"#two\" class=\"headerlink\" title=\"two\"></a>two</h1><p>我手会出汗，这让我平时有点很不开心，也不能说很吧，但就是自闭，我也不，知道怎么才能不出汗，据说要做个小手术，要割弃汗腺。我怕啊。我的身体还是刚从我妈身体刚出来的时候，<del>只是某些地方随着时间的流逝而变大</del>这个我也不想的，因为太大了，这在我日常生活中有点不好。很真实，幸好我是靠着墙的，对于我说了那么多，也就只有我一个人看得见，不然我也不会写这些让小姐姐脸红的文字。这个我说的有点肯定了，小姐姐看到了也不一定会脸红，因为现在的小姐姐都是见过大世面的人物，我在她们眼里也就只是小垃圾。</p>\n<hr>\n<h1 id=\"three\"><a href=\"#three\" class=\"headerlink\" title=\"three\"></a>three</h1><blockquote>\n<p>此时此刻我只想吟诗一首</p>\n<blockquote>\n<p>我随口一说就是古诗</p>\n<blockquote>\n<p>当时的李白心里想的肯定是这样的</p>\n<blockquote>\n<p>我是最厉害的，喝酒第一，造人第二，造诗第三。</p>\n<blockquote>\n<p>但他万万没想到最后自己最不想做的事情的反而实现了。并让后人传颂至今。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<hr>\n<h1 id=\"four\"><a href=\"#four\" class=\"headerlink\" title=\"four\"></a>four</h1><h2 id=\"总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。\"><a href=\"#总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。\" class=\"headerlink\" title=\"总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。\"></a><strong>总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。</strong></h2><hr>\n<h2 id=\"本故事纯属虚构，要想逼逼，随时见证，\"><a href=\"#本故事纯属虚构，要想逼逼，随时见证，\" class=\"headerlink\" title=\"本故事纯属虚构，要想逼逼，随时见证，\"></a><strong>本故事纯属虚构，要想逼逼，随时见证，</strong></h2>","site":{"data":{}},"excerpt":"<p>注释<br></p>","more":"<p></p>\n<h1 id=\"小新\"><a href=\"#小新\" class=\"headerlink\" title=\"小新\"></a>小新</h1><p><img src=\"/2019/05/19/test/a.jpg\" alt=\"小新\"></p>\n<h1 id=\"one\"><a href=\"#one\" class=\"headerlink\" title=\"one\"></a>one</h1><p><strong>我现在有点想睡觉，但也是说给自己看看的，随便也就说说心里话。我刚开始是有点词穷的。但我也不慌，因为我刚刚听到了一首歌的歌词很不错，我刚刚也是想写下来的，但一下子想不起来，这可能是瞬时的记忆，导致我记不起来更细致的记忆，没有梦想何必远方。这是刚刚有出来的歌词，我感觉自己运气还是不错的。因为我最后还是记起来了，有点小开心。</strong></p>\n<hr>\n<h1 id=\"two\"><a href=\"#two\" class=\"headerlink\" title=\"two\"></a>two</h1><p>我手会出汗，这让我平时有点很不开心，也不能说很吧，但就是自闭，我也不，知道怎么才能不出汗，据说要做个小手术，要割弃汗腺。我怕啊。我的身体还是刚从我妈身体刚出来的时候，<del>只是某些地方随着时间的流逝而变大</del>这个我也不想的，因为太大了，这在我日常生活中有点不好。很真实，幸好我是靠着墙的，对于我说了那么多，也就只有我一个人看得见，不然我也不会写这些让小姐姐脸红的文字。这个我说的有点肯定了，小姐姐看到了也不一定会脸红，因为现在的小姐姐都是见过大世面的人物，我在她们眼里也就只是小垃圾。</p>\n<hr>\n<h1 id=\"three\"><a href=\"#three\" class=\"headerlink\" title=\"three\"></a>three</h1><blockquote>\n<p>此时此刻我只想吟诗一首</p>\n<blockquote>\n<p>我随口一说就是古诗</p>\n<blockquote>\n<p>当时的李白心里想的肯定是这样的</p>\n<blockquote>\n<p>我是最厉害的，喝酒第一，造人第二，造诗第三。</p>\n<blockquote>\n<p>但他万万没想到最后自己最不想做的事情的反而实现了。并让后人传颂至今。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<hr>\n<h1 id=\"four\"><a href=\"#four\" class=\"headerlink\" title=\"four\"></a>four</h1><h2 id=\"总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。\"><a href=\"#总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。\" class=\"headerlink\" title=\"总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。\"></a><strong>总而言之，言而总之。我现在的精神也没刚刚开始那么懒散，脑子一动，精神就会慢慢起来，就好比此时，我心里是受伤的，但我相信未来的不久我又是自信满满的少年。</strong></h2><hr>\n<h2 id=\"本故事纯属虚构，要想逼逼，随时见证，\"><a href=\"#本故事纯属虚构，要想逼逼，随时见证，\" class=\"headerlink\" title=\"本故事纯属虚构，要想逼逼，随时见证，\"></a><strong>本故事纯属虚构，要想逼逼，随时见证，</strong></h2>"},{"title":"test2","date":"2019-05-31T13:44:22.000Z","_content":"注释\n<!--more-->\n\n![test](test2/desktop.jpg)\n","source":"_posts/test2.md","raw":"---\ntitle: test2\ndate: 2019-05-31 21:44:22\ntags: test\n---\n注释\n<!--more-->\n\n![test](test2/desktop.jpg)\n","slug":"test2","published":1,"updated":"2019-09-10T09:12:17.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7rv000k4ez7xv3ven5c","content":"<p>注释<br><a id=\"more\"></a></p>\n<p><img src=\"/2019/05/31/test2/desktop.jpg\" alt=\"test\"></p>\n","site":{"data":{}},"excerpt":"<p>注释<br></p>","more":"<p></p>\n<p><img src=\"/2019/05/31/test2/desktop.jpg\" alt=\"test\"></p>"},{"title":"小萝莉","date":"2019-05-06T14:22:11.000Z","_content":"注释\n<!--more-->\n# 小萝莉\n**这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。**\n----\n> 虚构一：\n>> 我要是现在说我爱你，你觉得会不会快了一点，还是要慢慢来培养感情？\n>>> 你只能说好，因为这是我的世界，你们是没有写的权利，只有读的权利，感觉有点熟悉，你们的脑子是怎么运作的我不知道，但老子感觉有点熟悉，因为老子在给你们上课，或许你们可能觉得我在胡乱逼逼，这样的想法是不可有的，在这个世界上想你们这么帅的人已经很少了，或许你现在心里美美的，但对不起，我说的是你旁边的小姐姐，我想她，她是我日思夜想的，没错了，你现在心里想的就是了，你真聪明，就是你以前看过的最可怕的那女鬼。\n>>>> 你现在很怕？想打我？想骂我？这就是你来我这里的原因？我不懂你们的心里，放着这么好的时间不好好珍惜，来我这里看一个小骚年写的无序头文章，你真的有病，难怪小萝莉会找上你，你现在应该拿起你的手机call me （请允许我装个逼）。\n>>>> 预知后事如何，请看明天谁第一个发现你的尸体。\n\n----\n> 虚构二：\n>> 男人要想混得好，头发必须往后倒！这句话就想是。。。等等我音乐有点自闭，感觉是催眠，\n>>> 老子刚刚出去换歌，怎么了，就是这么任性，年轻，有钱，任性。有点小高调，你想要的，我却不能给你我全部，我能给的却又不是你想要的。我讨厌这么不知好歹的小姐姐，大家都是人，我给你的你要好好拿着，或许就是不要，就这两个选择，不要跟我虚的，磨磨唧唧的，难怪最后受伤的都是你们这些女的，我不一样，因为我是男的，我是属于那种小骚小骚的，具体我是怎么样的我也不清楚，所以，你还是听马克思的话，不要想着去了解一个人，往往这个人心里也是搞不懂自己到底是一个怎么样的人，我之所以会这样，就是不听前人的劝告，你们还是不要去的好，把自己每天搞得充充实实的就好了，那样的你真的很好，虽然平时练习代码的时候很狼狈，但是你运行没bug时，你那一副天下都是你的样子真的很欠打。\n----\n> 虚构三：![大哥](小萝莉/test.png)\n>> 老子出去一下。\n----\n![test](小萝莉/sda.jpg)\n\n|name|year|\n|-----|-----|\n|blue|20|:\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|red|18|\n|tearllo|19|\n|blue|20|\n","source":"_posts/小萝莉.md","raw":"---\ntitle: 小萝莉\ndate: 2019-05-06 22:22:11\ntags:\n---\n注释\n<!--more-->\n# 小萝莉\n**这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。**\n----\n> 虚构一：\n>> 我要是现在说我爱你，你觉得会不会快了一点，还是要慢慢来培养感情？\n>>> 你只能说好，因为这是我的世界，你们是没有写的权利，只有读的权利，感觉有点熟悉，你们的脑子是怎么运作的我不知道，但老子感觉有点熟悉，因为老子在给你们上课，或许你们可能觉得我在胡乱逼逼，这样的想法是不可有的，在这个世界上想你们这么帅的人已经很少了，或许你现在心里美美的，但对不起，我说的是你旁边的小姐姐，我想她，她是我日思夜想的，没错了，你现在心里想的就是了，你真聪明，就是你以前看过的最可怕的那女鬼。\n>>>> 你现在很怕？想打我？想骂我？这就是你来我这里的原因？我不懂你们的心里，放着这么好的时间不好好珍惜，来我这里看一个小骚年写的无序头文章，你真的有病，难怪小萝莉会找上你，你现在应该拿起你的手机call me （请允许我装个逼）。\n>>>> 预知后事如何，请看明天谁第一个发现你的尸体。\n\n----\n> 虚构二：\n>> 男人要想混得好，头发必须往后倒！这句话就想是。。。等等我音乐有点自闭，感觉是催眠，\n>>> 老子刚刚出去换歌，怎么了，就是这么任性，年轻，有钱，任性。有点小高调，你想要的，我却不能给你我全部，我能给的却又不是你想要的。我讨厌这么不知好歹的小姐姐，大家都是人，我给你的你要好好拿着，或许就是不要，就这两个选择，不要跟我虚的，磨磨唧唧的，难怪最后受伤的都是你们这些女的，我不一样，因为我是男的，我是属于那种小骚小骚的，具体我是怎么样的我也不清楚，所以，你还是听马克思的话，不要想着去了解一个人，往往这个人心里也是搞不懂自己到底是一个怎么样的人，我之所以会这样，就是不听前人的劝告，你们还是不要去的好，把自己每天搞得充充实实的就好了，那样的你真的很好，虽然平时练习代码的时候很狼狈，但是你运行没bug时，你那一副天下都是你的样子真的很欠打。\n----\n> 虚构三：![大哥](小萝莉/test.png)\n>> 老子出去一下。\n----\n![test](小萝莉/sda.jpg)\n\n|name|year|\n|-----|-----|\n|blue|20|:\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|<+++>|<++++>|\n|red|18|\n|tearllo|19|\n|blue|20|\n","slug":"小萝莉","published":1,"updated":"2019-10-02T14:34:32.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7rw000l4ez74mxq26t0","content":"<p>注释<br><a id=\"more\"></a></p>\n<h1 id=\"小萝莉\"><a href=\"#小萝莉\" class=\"headerlink\" title=\"小萝莉\"></a>小萝莉</h1><h2 id=\"这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。\"><a href=\"#这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。\" class=\"headerlink\" title=\"这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。\"></a><strong>这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。</strong></h2><blockquote>\n<p>虚构一：</p>\n<blockquote>\n<p>我要是现在说我爱你，你觉得会不会快了一点，还是要慢慢来培养感情？</p>\n<blockquote>\n<p>你只能说好，因为这是我的世界，你们是没有写的权利，只有读的权利，感觉有点熟悉，你们的脑子是怎么运作的我不知道，但老子感觉有点熟悉，因为老子在给你们上课，或许你们可能觉得我在胡乱逼逼，这样的想法是不可有的，在这个世界上想你们这么帅的人已经很少了，或许你现在心里美美的，但对不起，我说的是你旁边的小姐姐，我想她，她是我日思夜想的，没错了，你现在心里想的就是了，你真聪明，就是你以前看过的最可怕的那女鬼。</p>\n<blockquote>\n<p>你现在很怕？想打我？想骂我？这就是你来我这里的原因？我不懂你们的心里，放着这么好的时间不好好珍惜，来我这里看一个小骚年写的无序头文章，你真的有病，难怪小萝莉会找上你，你现在应该拿起你的手机call me （请允许我装个逼）。<br>预知后事如何，请看明天谁第一个发现你的尸体。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<p>虚构二：</p>\n<blockquote>\n<p>男人要想混得好，头发必须往后倒！这句话就想是。。。等等我音乐有点自闭，感觉是催眠，</p>\n<blockquote>\n<p>老子刚刚出去换歌，怎么了，就是这么任性，年轻，有钱，任性。有点小高调，你想要的，我却不能给你我全部，我能给的却又不是你想要的。我讨厌这么不知好歹的小姐姐，大家都是人，我给你的你要好好拿着，或许就是不要，就这两个选择，不要跟我虚的，磨磨唧唧的，难怪最后受伤的都是你们这些女的，我不一样，因为我是男的，我是属于那种小骚小骚的，具体我是怎么样的我也不清楚，所以，你还是听马克思的话，不要想着去了解一个人，往往这个人心里也是搞不懂自己到底是一个怎么样的人，我之所以会这样，就是不听前人的劝告，你们还是不要去的好，把自己每天搞得充充实实的就好了，那样的你真的很好，虽然平时练习代码的时候很狼狈，但是你运行没bug时，你那一副天下都是你的样子真的很欠打。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<p>虚构三：<img src=\"/2019/05/06/小萝莉/test.png\" alt=\"大哥\"></p>\n<blockquote>\n<p>老子出去一下。</p>\n</blockquote>\n</blockquote>\n<hr>\n<p><img src=\"/2019/05/06/小萝莉/sda.jpg\" alt=\"test\"></p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>year</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>blue</td>\n<td>20</td>\n<td>:</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>red</td>\n<td>18</td>\n</tr>\n<tr>\n<td>tearllo</td>\n<td>19</td>\n</tr>\n<tr>\n<td>blue</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>注释<br></p>","more":"<p></p>\n<h1 id=\"小萝莉\"><a href=\"#小萝莉\" class=\"headerlink\" title=\"小萝莉\"></a>小萝莉</h1><h2 id=\"这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。\"><a href=\"#这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。\" class=\"headerlink\" title=\"这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。\"></a><strong>这是一个没有剧本的故事，所以接下来会发生什么，本人也不敢保证，最好小孩要在大人的陪同下阅读的，看什么看，说的就是你，整个一傻逼，有事没事进来看什么东西，说到底，我写的这些就是来满足你们这些小傻逼的，整天无所事事，也不知道给老子找个小萝莉。</strong></h2><blockquote>\n<p>虚构一：</p>\n<blockquote>\n<p>我要是现在说我爱你，你觉得会不会快了一点，还是要慢慢来培养感情？</p>\n<blockquote>\n<p>你只能说好，因为这是我的世界，你们是没有写的权利，只有读的权利，感觉有点熟悉，你们的脑子是怎么运作的我不知道，但老子感觉有点熟悉，因为老子在给你们上课，或许你们可能觉得我在胡乱逼逼，这样的想法是不可有的，在这个世界上想你们这么帅的人已经很少了，或许你现在心里美美的，但对不起，我说的是你旁边的小姐姐，我想她，她是我日思夜想的，没错了，你现在心里想的就是了，你真聪明，就是你以前看过的最可怕的那女鬼。</p>\n<blockquote>\n<p>你现在很怕？想打我？想骂我？这就是你来我这里的原因？我不懂你们的心里，放着这么好的时间不好好珍惜，来我这里看一个小骚年写的无序头文章，你真的有病，难怪小萝莉会找上你，你现在应该拿起你的手机call me （请允许我装个逼）。<br>预知后事如何，请看明天谁第一个发现你的尸体。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<p>虚构二：</p>\n<blockquote>\n<p>男人要想混得好，头发必须往后倒！这句话就想是。。。等等我音乐有点自闭，感觉是催眠，</p>\n<blockquote>\n<p>老子刚刚出去换歌，怎么了，就是这么任性，年轻，有钱，任性。有点小高调，你想要的，我却不能给你我全部，我能给的却又不是你想要的。我讨厌这么不知好歹的小姐姐，大家都是人，我给你的你要好好拿着，或许就是不要，就这两个选择，不要跟我虚的，磨磨唧唧的，难怪最后受伤的都是你们这些女的，我不一样，因为我是男的，我是属于那种小骚小骚的，具体我是怎么样的我也不清楚，所以，你还是听马克思的话，不要想着去了解一个人，往往这个人心里也是搞不懂自己到底是一个怎么样的人，我之所以会这样，就是不听前人的劝告，你们还是不要去的好，把自己每天搞得充充实实的就好了，那样的你真的很好，虽然平时练习代码的时候很狼狈，但是你运行没bug时，你那一副天下都是你的样子真的很欠打。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<p>虚构三：<img src=\"/2019/05/06/小萝莉/test.png\" alt=\"大哥\"></p>\n<blockquote>\n<p>老子出去一下。</p>\n</blockquote>\n</blockquote>\n<hr>\n<p><img src=\"/2019/05/06/小萝莉/sda.jpg\" alt=\"test\"></p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>year</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>blue</td>\n<td>20</td>\n<td>:</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>&lt;+++&gt;</td>\n<td>&lt;++++&gt;</td>\n</tr>\n<tr>\n<td>red</td>\n<td>18</td>\n</tr>\n<tr>\n<td>tearllo</td>\n<td>19</td>\n</tr>\n<tr>\n<td>blue</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>"},{"title":"qt","date":"2019-08-05T14:24:37.000Z","_content":"                                                                                                  QT\n<!--more-->\n# Qt\n*图形化界面--GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。*\n----\n```\n#include <QApplication>//使用qt的头文件\n#include <QWidget>//窗口控制基类\n#include <QPushButton>//指定父对象的头文件\nint main(int argc,char *argv[]){\n        QApplication  a(argc,argv);\n        My_widget w;\n        w.setwindowTitle(\"主要看气质\");//文件头名\n        QPushButton b;//声明按钮的类     \n        b.setParent(&w);//让按钮放在父对象的函数\n        b.setText(\"删除\");//声明按钮,并赋值\n        b.move(100,100);//移动按钮\n        QPushButton b1(&w);//使用按钮构造函数并指向父对象\n        b1.setText(\"确认\");//声明按钮,并赋值\n        b1.move(200,200);//移动按钮\n        w.show();//输出函数\n        return app.exec();\n}\n```\n![运行结果](qt/qt1.png)\n\n**值得注意下的就是，如果不给按钮对象指向父对象，两个窗口是独立的。还有上面是用了两种方式来指向父对象，一个是用函数setParent(),另外一个是用构造函数来指向。**\n```\n#include <QApplication>\n#include <QWidget>\n#include <QLabel>\nint main(int argc,char *argv[]){\n            QApplication a(argc,argv);\n            QLabel label(\"Hello\");\n            return a.exec();\n}\n```\n![运行结果](qt/qt2_hello.png)\n\n**上面的代码有点不好，但要是一定要这样的话，那在main函数里面的代码是很多的。这样让别人看起来就有点不好的感觉。**\n**QPushButton--是按钮，QWidget--是窗口**\n* signals--信号(类似与广播，发出信号，如果有对它有意思的，就有connect连接，来把它连接在一起)\n* connect--连接(意思是，用自己的函数(成为槽(solt))来处理这个信号)\n```\n//练练手，长长记性\n//main函数里面的头文件\n#include <QApplication>\n#include <QPushButton>\n#include \"My_Widget.h\"\n\n//是以公有的方式继承了窗口化的类,.h文件\n#include \"sud.h\"\nclass My_Widget:public Widget{\npublic:\n        My_Widget(QWidget *parent =nullptr);\n        ~My_Widget();\n        void showb2();\n        void showwid();\n        void showxin();\nprivate:\n        QPushButton b1;\n        QPushButton *b2;\n        QPushButton b3;\n        sud s;\n}\n//.cpp文件\n#include \"My_Widget.h\"\nMy_Widget::MyWidget(QWidget *parent =nullptr):QWidget(parent){\n        b1.setParent(this);\n        b1.setText(\"^_^\");\n        b1.move(100,100);\n        b2=new QPushButton (this);\n        b2->setText(\"abc\");\n        connect(&b1,&QPushButton::released,this,&QPushButton::close);\n        connect(b2,&QPushButton::released,this,&My_Widget::show);\n        s.show();\n        this->setWindowTitle(\"老大\");\n        b3.setParent(this);\n        b3.setText(\"切换子窗口\");\n        connect(&b3,&QPushButton::released,this,My_Widget::showwid);\n        connect(&s,&sud::xin,this,&My_Widget::showxin);//接收信号并处理信号\n        resize(400,300);\n        //当信号发出时，被连接的槽函数会被回调用来处理信号发出的操作\n}\nvoid My_Widget::showb2(){\n        b2->setText(\"123\");\n}\nvoid My_Widget::showwid(){\n        s.show();\n        this->hide();\n}\nvoid My_Widget::showxin{\n        this->show();\n        s.hide();\n}\n\n//是以公有的方式继承My_Widget类的派生类\n#include <QWidget>\n#include <QPushButton>\nclass sud : public My_Widget{\npublic:\n        explicit*** sud(QWidget *parent =nullptr)\n        void showwid();//用来发射信号的函数\nsignals:\n        void xin();//信号\nprivate:\n        QPushButton b;\n}\nvoid sud::sud(QWidget *parent):QWidget(parent){\n        this->setWindowTitle(\"小弟\");\n        b.setParent(this);\n        b.setText(\"切换父窗口\");\n        connect(&b,QPushButton::clicked,this,&sud::showwid);//发送信号的\n        resize(400,300);\n}\nvoid sud::showwid(){\n        emit xin();\n}\n\n\nint main(int argc,char *argv[] ){\n        QApplication a(argc,argv);\n        My_Widget w;\n        w.show();\n        return a.exec();\n}\n```\n# connect\n* 槽\n1. 任意的成员函数，普通全局函数，静态函数\n2. 槽函数需要与信号一样(返回值和参数)由于信号没有返回值，所以槽函数也没有返回值\n\n* 信号\n1. 信号必须有关键字signals\n2. 信号没有返回值，是个函数,可以有参数\n3. 信号只有声明，无需为信号定义\n4. 使用的方法:使用关键字emit来调用\n* 按钮只是回调了槽函数，而窗口的所有改动都是该窗口改变的，和按钮是没什么关联的。\n\n* 内存\n1. 指定父对象后,直接或间接的继承于Q0bject\n2. 子对象如果动态分配空间(new)，不需要手动释放(delete)，系统会自动调用析构函数\n```\n#include <QMenuBar>//菜单栏\n#include <QMenu>//菜单\n#include <QAction>//控件\n#include <QToolBar>//快捷键\n#include <QDebug>//打印\n#include <QStatusBar>//状态栏\n#include <QLabel>//标签\n#include <QTextEdit>//核心控件\n#include <QDockWidget>//浮动窗口\n* 创建菜单栏和一些控件\n* 以下的代码是在构造函数的里面的，主要是懒得写了。\n        QMenuBar *mbar=menuBar();//声明一个菜单栏\n        Qmenu *f1=mbar->addAction(文件);//在菜单栏里写一个以文件为名的控件\n        QAction *p1=f1->addAction(\"新建\");//在文件里写一个以新建为名的控件\n        connect(p1,&QAction::triggered,//槽函数\n        []()\n        {\n                qDebug()<<\"新建被按下\";\n        });\n        f1->addSeparator();//分割线\n        QAction *p1_2=f1->addAction(\"打开\");//同上\n        Qmenu *f2=mbar->addAction(\"编辑\");\n        QAction *p2=f2->addAction(\"编辑\");\n        connect(p2,&QAction::triggered,\n        []()\n        {\n                qDebug()<<\"编辑被按下\";\n        });\n        QStatusBar *sbar=statusBar();//状态栏，声明状态栏\n        QLabel *label= new QLabel (this);//声明标签\n        sbar ->addAction(new QLabel(\"2\",this));//以从左往右的方式显示2\n        sbar-> addPermanentWidget(new QLabel(\"3\",this));\n        //以从右忘左的方式显示3\n        QTextEdit *text=new QTextEdit(this);//核心控件，也就是文件编辑的地方\n        setCentralWidget(text);\n        QDockWidget *dock=new QDockWidget(this);//浮动窗口\n        addDockWidget(Qt::LeftDockWidget,dock);//在左边显示\n        QTextWidget *text1=new QTextWidget(this);//声明编辑\n        dock->setWidget(text1);//在浮动窗口里显示文件编辑的地方\n\n```\n----\n![运行结果](qt/qt3_caidan.png)\n# 关于对话框\n----\n* 是在继承于MainWindow(主窗口)的类构造函数里\n```\n#include \"QMainWindow\"//继承与主窗口\n#include <QMenuBar>\n#include <Menu>\n#include <QAction>\n#include <QDebug>\n#include <QMessageBox>//对话框的头文件\n#include <QFileDialog>//查找文件的对话框的头文件\nMainWindow::MainWindow(QWinget *parent)\n        :MainWindow(parent){\n                QMenuBar *menub=menubar();\n                QMenu *p1=menub->addmenu(\"文件\");\n                QAction *A1=p1->addaction(\"关于对话框\");\n                connect(A1,&QAction::triggered,\n                [=]()\n                {\n                        QMessageBox ::about(this,\"about\",\"关于Qt\"); \n                        //简单的一个显示对话框\n                }\n                );\n                QAction *A2=p1->addaction(\"问题对话框\");\n                connect(A2,&QAction::triggered,\n                [=]()\n                {\n                        int val=QMessageBox::question(this,\"test\",\"is ok ?\",\n                        QMessageBox::ok|\n                        QMessageBox::Cancel);\n                        //显示一个对话框，调用枚举函数来实现，显示的对话内容可以自己选择，也可以随机匹配，返回值是一个整数类型的，可以定义一个整数来接住函数的返回值，这样载利用switch来做到自己想要的效果\n                }\n                switch (val){\n                        case QMessageBox::ok:\n                        qDebug()<<\"i am ok\";\n                        break;\n                        case QMessageBox::Cancel:\n                        qDebug()<<\"i am bad\";\n                        break;\n                        default:\n                        break;\n                }\n                );\n        }\n        QAction *A3=p1->addaction(\"文件对话框\");\n        connect(A3,&QAction::triggered,\n        [=]()\n        {\n                QFileDialog ::getOpenFileName(this,\"open\",\"/home\",\n                \"test(*.cpp *.md);;file(*.)\");\n                //利用Qt函数来实现查找文件的对话框，加上筛选的效果,来显示查找文件的强大性\n        }\n        );\n```\n![运行结果](qt/qt4_duihua.png)\n\n![运行结果](qt/qt5_duihua.png)\n# ui\n![这些是在ui模式下操作的](qt/qt6_ui.png)\n> **布局**\n----\n**局部布局和全局布局,**\n**一样是在ui的模式下进行的，因为这样比较简单而且实际。**\n----\n![运行结果](qt/qt7_ui.png)\n![运行结果](qt/qt8_ui.png)\n\n**布局最好在ui模式，因为简单！！！**\n----\n![简单的登录方式](qt/qt9_ui.png)\n# 设置\n**接下的操作是在ui的模式下完成的，并继承于Mainwindow**\n```\n#inlcude \"MainWindow.h\"\n#include <ui_mainwindow.h>\n#include <QDebug>//打印的头文件\n#include <QStringList>\n#include <QCompleter>\n\nMainWindow::MainWindow(QWidget *parent):QMainwindow(parent){\n        ui->setupUi(this);\n        //在ui的模式下添加LineEdit(行编辑)\n        QString str=ui->LineEdit->text();//获取一行里的内容\n        qDebug<<str;//打印\n        ui->LineEdit->setText(\"123456\");//设置内容\n        ui->LineEdit->setTextMargins(10,0,0,0);//更改方度(左,右,上,下)\n        ui->LineEdit->setEchomode(QLineEdit::psaaword);//把内容设置为密码的模式\n        QStringLest cin;//声明字符串\n        cin<<\"hello\"<<\"how are you\"<<\"Hehe\";//定义字符串\n        QCompleter *com=new QCompleter (cin,this);//把字符串放进模型里\n        com->setCaseSensitivity(Qt::CaseInsensitive);//把模型设置成不区分大小写\n        ui->LineEdit->setCompleter(com);//把模型加进行编辑\n}\n```\n# 样式\n1 方箱模型\n2 前景和背景\n3 控制大小\n4 创建缩放式\n5 处理伪状态\n**关键字(setStyleSheet)**\n* 创建的是Widget，是在ui的模式下添加了一个label和PushButton。\n```\n// .cpp\n  ui->pushButton->setStyleSheet(\"QPushButton{\"\n  \"color:rgb(0,255,255);\" //设置颜色，自动调制颜色\n  \"backgroud-color:red;\" //设置背景颜色\n  \"border: 2px outset grenn;\"//创建缩放式(设置边框像素，输出设置，输出的颜色)\n  \"border-image:url(:/new/prefix1/头像.jpg);\"//设置成相片，\n \"}\"\n        \"QPushButton:hover{\"//当鼠标抬起就更换照片\n        \"border-image:url(:/new/prefix1/test.jpg)\"\n        \"}\"\n        \"QPushButton:pressed{\"//当鼠标按下就更换照片\n        \"border-image:url(:/new/prefix1/test1.jpg)\"\n        \"}\"\n );\n```\n* border (平铺的方式) \n\n![运行结果](qt/qt10_ui.png)\n![方箱模型](qt/qt11_ui.png)\n![伪状态](qt/qt12_ui.png)\n# Event(事件)\n**事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。**\n----\n```\n// 这里是在ui的模式下添加了label，然后又添加了新文件，最后在ui里把label提升为槽函数而实现的。\n// .h\n#include <QLabel>\nclass Mylabel : public Qlabel{\n        protected://保护的(重写事件里的虚函数)\n        //鼠标按下\n        void mousePressEvent(QMouseEvent *ev);\n        //鼠标抬起\n        void mouseReleaseEvent(QMouseEvent *ev);\n        //鼠标移动\n        void mouseMoveEvent(QMouseEvent *ev);\n        //鼠标在里面\n        void enterEvent(QEvent *);\n        //鼠标在外面\n        void leaveEvent(QEvent *);\n}\n// .cpp\n#include \"Mylabel.h\"\n#include <MouseEvent>//事件的头文件\n#include <QDebug> //打印\nMylabel::Mylabel(QWidget *parent):QLabel(parent){\n        //设置追踪鼠标(设置了鼠标追踪就会在程序里自动追踪鼠标，没有设置的话，你还得在窗口里点一下才能出来数据)\n        this->setMouseTracking(true);\n}\nvoid Mylabel::mousePressEvent(QMouseEvent *ev){\n        int i=ev->x();//x的坐标\n        int j=ev->y();//y的坐标\nQSting str=QString (\"<center><h1>mouse press:(%1,%2)</h1></center>\")\n.arg(i).arg(j);\n// 语法(参数是字符) (center(字体加粗))\nthis->setText(str);//设置\nif(ev->Button()==Qt::LefeButton){//判断鼠标按钮在左边，右边，中间\n        qDebug()<<\"left\";\n}else if(ev->Button()==Qt::RightNutton){\n        qDebug()<<\"right\";\n}else if(ev->Button()==Qt::MidButton){\n        qDebug()<<\"wid\";\n}\nvoid Mylabel::mouseReleaseEvent(QMouseEvent *ev){\nQSting str=QString (\"<center><h1>mouse press:(%1,%2)</h1></center>\")\n.arg(ev->x()).arg(ev->y());\nthis->setText(str);\n}\nvoid Mylabel::mouseMoveEvent(QMouseEvent *ev){\n\nQSting str=QString (\"<center><h1>mouse move:(%1,%2)</h1></center>\")\n.arg(ev->x()).arg(ev->y());\nthis->setText(str);\n}\nvoid Mylabel::enterEvent(QEvent *e){\n        QString str=QString(\"<center><h1>Event:enter</h1></center>\");\n        this->setText(str);\n}\nvoid Mtlabel::lavceEvent(QEvent *e){\n        QString str=QString(\"<center><h1>Event:leave</h1><.center>\");\n        this->setText(str);\n}\n}\n```\n![运行结果](qt/qtEvent.png)\n\n![运行结果](qt/qtEvent1.png)\n\n![运行结果](qt/qtEvent2.png)\n\n![运行结果](qt/qtEvent3.png)\n> 时间的处理与忽略\n* 继承于widget的前提下，简写。\n```\n// .h\nvoid closeEvent (QEvent *event);//关闭事件\n// .cpp\n#include \"Widget.h\"\n#include <QMessageBox>//对话框头文件\nvoid Widget::closeEvent(QEvent *event){\n        int test=QMessageBox::question(this , \"question\",\"sure?\",\n        QMessageBox::Yes |\n        QMessageBox::No);\n        if(test==QMessageBox::Yes){\n                event->accept();//处理\n        }else{\n                event->ignore();//忽略\n        }\n\n}\n```\n![运行结果](qt/qtEvent4.png)\n# 绘画\n![运行的程序](qt/qtEventpainter1.png)\n![运行的结果](qt/qtEventpainter2.png)\n\n# 绘图设备\n* Pixmap(在平台上不能对图片进行修改)\n* Image(和平台无关平台上，可以对图片进行修改)\n* picture(保存绘图的状态，以二进制的文件进行保存)\n\n![pixmap](qt/qt_pixmap.png)\n![image](qt/qt_image.png)\n![picture](qt/qt_picture1.png)\n![picture](qt/qt_picture.png)\n![[icture]](qt/qt_picture2.png)\n\n**其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。**\n----\n> QPixmap&&QImage\n\n![](qt/qtzhuan.png)\n\n![](qt/qt_zhuan1.png)\n----\n# 不规则的窗口\n![程序](qt/qt_paint.png)\n![结果](qt/qt_paint1.png)\n\n**绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备(this)。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画(QPixmap(保存的是图片),QImage(保存的是图片),Qpicture(保存的是二进制文件))，save(保存),load(加载)，Rect(矩形)。**\n ----\n# File\n**不管在那个语言上，文件的操作都有一定的重要性，所以就把它学好。**\n* 普通的形式写读文件()\n\n```\n// 用到的头文件\n#include <QFile>\n#include <QFileDialg>\n#include <QFileInfo>\n```\n![](qt/qtFILE.png)\n![](qt/qtreadfile.png)\n![](qt/qtwritefile.png)\n* 是以二进制的形式保存文件\n```\n// 用到的头文件\n#include <QFile>\n#include <QDatestram>\n```\n![](qt/qt_Stream.png)\n# Server\n**记得在项目文件里加(network),这是针对于在类对象里没有提示。还有就是连则表达式(CONFIG+=c++11)**\n----\n![](qt/qt_server.png)\n**写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。**\n----\n```\n//用到的头文件\n#include <QTcpServer>\n#include <QTcpsocket>\n```\n![serven](qt/qt_tcpserven.png)\n![server](qt/qt_tcpserven1.png)\n![客户端](qt/qt_tcpserven2.png)\n**其实在上面的刚开始的第一张图就很清晰的讲到了tcp的连接过程，只要我们真的理解了就能看的明白。在这里也没什么好解释的，有很多的函数都是在函数里订好了的，只要我们搞清楚什么时候调用什么函数就行了。**\n> UDP\n* 它是面向无连接的通信，所以在这里就只需要通信的套接字(socket)。\n```\n// 用到的头文件\n#include <QUdpSocket> //.h(不要忘记在.h文件里声明socket套接字)\n#include <QHostAddress>// .cpp\n```\n![程序](qt/qt_udp1.png)\n![程序](qt/qt_udp2.png)\n![运行结果](qt/qt_udp.png)\n# tcpfile\n![流程图](qt/qt_tcpfile.png)\n**值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。**\n----\n# QThread\n**connect的第五个参数的意义(默认，队列，直接)默认的时候：分为多线程(默认使用队列)和单线程(默认使用直接)。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。** \n----\n","source":"_posts/qt.md","raw":"---\ntitle: qt\ndate: 2019-08-05 22:24:37\ntags:\n---\n                                                                                                  QT\n<!--more-->\n# Qt\n*图形化界面--GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。*\n----\n```\n#include <QApplication>//使用qt的头文件\n#include <QWidget>//窗口控制基类\n#include <QPushButton>//指定父对象的头文件\nint main(int argc,char *argv[]){\n        QApplication  a(argc,argv);\n        My_widget w;\n        w.setwindowTitle(\"主要看气质\");//文件头名\n        QPushButton b;//声明按钮的类     \n        b.setParent(&w);//让按钮放在父对象的函数\n        b.setText(\"删除\");//声明按钮,并赋值\n        b.move(100,100);//移动按钮\n        QPushButton b1(&w);//使用按钮构造函数并指向父对象\n        b1.setText(\"确认\");//声明按钮,并赋值\n        b1.move(200,200);//移动按钮\n        w.show();//输出函数\n        return app.exec();\n}\n```\n![运行结果](qt/qt1.png)\n\n**值得注意下的就是，如果不给按钮对象指向父对象，两个窗口是独立的。还有上面是用了两种方式来指向父对象，一个是用函数setParent(),另外一个是用构造函数来指向。**\n```\n#include <QApplication>\n#include <QWidget>\n#include <QLabel>\nint main(int argc,char *argv[]){\n            QApplication a(argc,argv);\n            QLabel label(\"Hello\");\n            return a.exec();\n}\n```\n![运行结果](qt/qt2_hello.png)\n\n**上面的代码有点不好，但要是一定要这样的话，那在main函数里面的代码是很多的。这样让别人看起来就有点不好的感觉。**\n**QPushButton--是按钮，QWidget--是窗口**\n* signals--信号(类似与广播，发出信号，如果有对它有意思的，就有connect连接，来把它连接在一起)\n* connect--连接(意思是，用自己的函数(成为槽(solt))来处理这个信号)\n```\n//练练手，长长记性\n//main函数里面的头文件\n#include <QApplication>\n#include <QPushButton>\n#include \"My_Widget.h\"\n\n//是以公有的方式继承了窗口化的类,.h文件\n#include \"sud.h\"\nclass My_Widget:public Widget{\npublic:\n        My_Widget(QWidget *parent =nullptr);\n        ~My_Widget();\n        void showb2();\n        void showwid();\n        void showxin();\nprivate:\n        QPushButton b1;\n        QPushButton *b2;\n        QPushButton b3;\n        sud s;\n}\n//.cpp文件\n#include \"My_Widget.h\"\nMy_Widget::MyWidget(QWidget *parent =nullptr):QWidget(parent){\n        b1.setParent(this);\n        b1.setText(\"^_^\");\n        b1.move(100,100);\n        b2=new QPushButton (this);\n        b2->setText(\"abc\");\n        connect(&b1,&QPushButton::released,this,&QPushButton::close);\n        connect(b2,&QPushButton::released,this,&My_Widget::show);\n        s.show();\n        this->setWindowTitle(\"老大\");\n        b3.setParent(this);\n        b3.setText(\"切换子窗口\");\n        connect(&b3,&QPushButton::released,this,My_Widget::showwid);\n        connect(&s,&sud::xin,this,&My_Widget::showxin);//接收信号并处理信号\n        resize(400,300);\n        //当信号发出时，被连接的槽函数会被回调用来处理信号发出的操作\n}\nvoid My_Widget::showb2(){\n        b2->setText(\"123\");\n}\nvoid My_Widget::showwid(){\n        s.show();\n        this->hide();\n}\nvoid My_Widget::showxin{\n        this->show();\n        s.hide();\n}\n\n//是以公有的方式继承My_Widget类的派生类\n#include <QWidget>\n#include <QPushButton>\nclass sud : public My_Widget{\npublic:\n        explicit*** sud(QWidget *parent =nullptr)\n        void showwid();//用来发射信号的函数\nsignals:\n        void xin();//信号\nprivate:\n        QPushButton b;\n}\nvoid sud::sud(QWidget *parent):QWidget(parent){\n        this->setWindowTitle(\"小弟\");\n        b.setParent(this);\n        b.setText(\"切换父窗口\");\n        connect(&b,QPushButton::clicked,this,&sud::showwid);//发送信号的\n        resize(400,300);\n}\nvoid sud::showwid(){\n        emit xin();\n}\n\n\nint main(int argc,char *argv[] ){\n        QApplication a(argc,argv);\n        My_Widget w;\n        w.show();\n        return a.exec();\n}\n```\n# connect\n* 槽\n1. 任意的成员函数，普通全局函数，静态函数\n2. 槽函数需要与信号一样(返回值和参数)由于信号没有返回值，所以槽函数也没有返回值\n\n* 信号\n1. 信号必须有关键字signals\n2. 信号没有返回值，是个函数,可以有参数\n3. 信号只有声明，无需为信号定义\n4. 使用的方法:使用关键字emit来调用\n* 按钮只是回调了槽函数，而窗口的所有改动都是该窗口改变的，和按钮是没什么关联的。\n\n* 内存\n1. 指定父对象后,直接或间接的继承于Q0bject\n2. 子对象如果动态分配空间(new)，不需要手动释放(delete)，系统会自动调用析构函数\n```\n#include <QMenuBar>//菜单栏\n#include <QMenu>//菜单\n#include <QAction>//控件\n#include <QToolBar>//快捷键\n#include <QDebug>//打印\n#include <QStatusBar>//状态栏\n#include <QLabel>//标签\n#include <QTextEdit>//核心控件\n#include <QDockWidget>//浮动窗口\n* 创建菜单栏和一些控件\n* 以下的代码是在构造函数的里面的，主要是懒得写了。\n        QMenuBar *mbar=menuBar();//声明一个菜单栏\n        Qmenu *f1=mbar->addAction(文件);//在菜单栏里写一个以文件为名的控件\n        QAction *p1=f1->addAction(\"新建\");//在文件里写一个以新建为名的控件\n        connect(p1,&QAction::triggered,//槽函数\n        []()\n        {\n                qDebug()<<\"新建被按下\";\n        });\n        f1->addSeparator();//分割线\n        QAction *p1_2=f1->addAction(\"打开\");//同上\n        Qmenu *f2=mbar->addAction(\"编辑\");\n        QAction *p2=f2->addAction(\"编辑\");\n        connect(p2,&QAction::triggered,\n        []()\n        {\n                qDebug()<<\"编辑被按下\";\n        });\n        QStatusBar *sbar=statusBar();//状态栏，声明状态栏\n        QLabel *label= new QLabel (this);//声明标签\n        sbar ->addAction(new QLabel(\"2\",this));//以从左往右的方式显示2\n        sbar-> addPermanentWidget(new QLabel(\"3\",this));\n        //以从右忘左的方式显示3\n        QTextEdit *text=new QTextEdit(this);//核心控件，也就是文件编辑的地方\n        setCentralWidget(text);\n        QDockWidget *dock=new QDockWidget(this);//浮动窗口\n        addDockWidget(Qt::LeftDockWidget,dock);//在左边显示\n        QTextWidget *text1=new QTextWidget(this);//声明编辑\n        dock->setWidget(text1);//在浮动窗口里显示文件编辑的地方\n\n```\n----\n![运行结果](qt/qt3_caidan.png)\n# 关于对话框\n----\n* 是在继承于MainWindow(主窗口)的类构造函数里\n```\n#include \"QMainWindow\"//继承与主窗口\n#include <QMenuBar>\n#include <Menu>\n#include <QAction>\n#include <QDebug>\n#include <QMessageBox>//对话框的头文件\n#include <QFileDialog>//查找文件的对话框的头文件\nMainWindow::MainWindow(QWinget *parent)\n        :MainWindow(parent){\n                QMenuBar *menub=menubar();\n                QMenu *p1=menub->addmenu(\"文件\");\n                QAction *A1=p1->addaction(\"关于对话框\");\n                connect(A1,&QAction::triggered,\n                [=]()\n                {\n                        QMessageBox ::about(this,\"about\",\"关于Qt\"); \n                        //简单的一个显示对话框\n                }\n                );\n                QAction *A2=p1->addaction(\"问题对话框\");\n                connect(A2,&QAction::triggered,\n                [=]()\n                {\n                        int val=QMessageBox::question(this,\"test\",\"is ok ?\",\n                        QMessageBox::ok|\n                        QMessageBox::Cancel);\n                        //显示一个对话框，调用枚举函数来实现，显示的对话内容可以自己选择，也可以随机匹配，返回值是一个整数类型的，可以定义一个整数来接住函数的返回值，这样载利用switch来做到自己想要的效果\n                }\n                switch (val){\n                        case QMessageBox::ok:\n                        qDebug()<<\"i am ok\";\n                        break;\n                        case QMessageBox::Cancel:\n                        qDebug()<<\"i am bad\";\n                        break;\n                        default:\n                        break;\n                }\n                );\n        }\n        QAction *A3=p1->addaction(\"文件对话框\");\n        connect(A3,&QAction::triggered,\n        [=]()\n        {\n                QFileDialog ::getOpenFileName(this,\"open\",\"/home\",\n                \"test(*.cpp *.md);;file(*.)\");\n                //利用Qt函数来实现查找文件的对话框，加上筛选的效果,来显示查找文件的强大性\n        }\n        );\n```\n![运行结果](qt/qt4_duihua.png)\n\n![运行结果](qt/qt5_duihua.png)\n# ui\n![这些是在ui模式下操作的](qt/qt6_ui.png)\n> **布局**\n----\n**局部布局和全局布局,**\n**一样是在ui的模式下进行的，因为这样比较简单而且实际。**\n----\n![运行结果](qt/qt7_ui.png)\n![运行结果](qt/qt8_ui.png)\n\n**布局最好在ui模式，因为简单！！！**\n----\n![简单的登录方式](qt/qt9_ui.png)\n# 设置\n**接下的操作是在ui的模式下完成的，并继承于Mainwindow**\n```\n#inlcude \"MainWindow.h\"\n#include <ui_mainwindow.h>\n#include <QDebug>//打印的头文件\n#include <QStringList>\n#include <QCompleter>\n\nMainWindow::MainWindow(QWidget *parent):QMainwindow(parent){\n        ui->setupUi(this);\n        //在ui的模式下添加LineEdit(行编辑)\n        QString str=ui->LineEdit->text();//获取一行里的内容\n        qDebug<<str;//打印\n        ui->LineEdit->setText(\"123456\");//设置内容\n        ui->LineEdit->setTextMargins(10,0,0,0);//更改方度(左,右,上,下)\n        ui->LineEdit->setEchomode(QLineEdit::psaaword);//把内容设置为密码的模式\n        QStringLest cin;//声明字符串\n        cin<<\"hello\"<<\"how are you\"<<\"Hehe\";//定义字符串\n        QCompleter *com=new QCompleter (cin,this);//把字符串放进模型里\n        com->setCaseSensitivity(Qt::CaseInsensitive);//把模型设置成不区分大小写\n        ui->LineEdit->setCompleter(com);//把模型加进行编辑\n}\n```\n# 样式\n1 方箱模型\n2 前景和背景\n3 控制大小\n4 创建缩放式\n5 处理伪状态\n**关键字(setStyleSheet)**\n* 创建的是Widget，是在ui的模式下添加了一个label和PushButton。\n```\n// .cpp\n  ui->pushButton->setStyleSheet(\"QPushButton{\"\n  \"color:rgb(0,255,255);\" //设置颜色，自动调制颜色\n  \"backgroud-color:red;\" //设置背景颜色\n  \"border: 2px outset grenn;\"//创建缩放式(设置边框像素，输出设置，输出的颜色)\n  \"border-image:url(:/new/prefix1/头像.jpg);\"//设置成相片，\n \"}\"\n        \"QPushButton:hover{\"//当鼠标抬起就更换照片\n        \"border-image:url(:/new/prefix1/test.jpg)\"\n        \"}\"\n        \"QPushButton:pressed{\"//当鼠标按下就更换照片\n        \"border-image:url(:/new/prefix1/test1.jpg)\"\n        \"}\"\n );\n```\n* border (平铺的方式) \n\n![运行结果](qt/qt10_ui.png)\n![方箱模型](qt/qt11_ui.png)\n![伪状态](qt/qt12_ui.png)\n# Event(事件)\n**事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。**\n----\n```\n// 这里是在ui的模式下添加了label，然后又添加了新文件，最后在ui里把label提升为槽函数而实现的。\n// .h\n#include <QLabel>\nclass Mylabel : public Qlabel{\n        protected://保护的(重写事件里的虚函数)\n        //鼠标按下\n        void mousePressEvent(QMouseEvent *ev);\n        //鼠标抬起\n        void mouseReleaseEvent(QMouseEvent *ev);\n        //鼠标移动\n        void mouseMoveEvent(QMouseEvent *ev);\n        //鼠标在里面\n        void enterEvent(QEvent *);\n        //鼠标在外面\n        void leaveEvent(QEvent *);\n}\n// .cpp\n#include \"Mylabel.h\"\n#include <MouseEvent>//事件的头文件\n#include <QDebug> //打印\nMylabel::Mylabel(QWidget *parent):QLabel(parent){\n        //设置追踪鼠标(设置了鼠标追踪就会在程序里自动追踪鼠标，没有设置的话，你还得在窗口里点一下才能出来数据)\n        this->setMouseTracking(true);\n}\nvoid Mylabel::mousePressEvent(QMouseEvent *ev){\n        int i=ev->x();//x的坐标\n        int j=ev->y();//y的坐标\nQSting str=QString (\"<center><h1>mouse press:(%1,%2)</h1></center>\")\n.arg(i).arg(j);\n// 语法(参数是字符) (center(字体加粗))\nthis->setText(str);//设置\nif(ev->Button()==Qt::LefeButton){//判断鼠标按钮在左边，右边，中间\n        qDebug()<<\"left\";\n}else if(ev->Button()==Qt::RightNutton){\n        qDebug()<<\"right\";\n}else if(ev->Button()==Qt::MidButton){\n        qDebug()<<\"wid\";\n}\nvoid Mylabel::mouseReleaseEvent(QMouseEvent *ev){\nQSting str=QString (\"<center><h1>mouse press:(%1,%2)</h1></center>\")\n.arg(ev->x()).arg(ev->y());\nthis->setText(str);\n}\nvoid Mylabel::mouseMoveEvent(QMouseEvent *ev){\n\nQSting str=QString (\"<center><h1>mouse move:(%1,%2)</h1></center>\")\n.arg(ev->x()).arg(ev->y());\nthis->setText(str);\n}\nvoid Mylabel::enterEvent(QEvent *e){\n        QString str=QString(\"<center><h1>Event:enter</h1></center>\");\n        this->setText(str);\n}\nvoid Mtlabel::lavceEvent(QEvent *e){\n        QString str=QString(\"<center><h1>Event:leave</h1><.center>\");\n        this->setText(str);\n}\n}\n```\n![运行结果](qt/qtEvent.png)\n\n![运行结果](qt/qtEvent1.png)\n\n![运行结果](qt/qtEvent2.png)\n\n![运行结果](qt/qtEvent3.png)\n> 时间的处理与忽略\n* 继承于widget的前提下，简写。\n```\n// .h\nvoid closeEvent (QEvent *event);//关闭事件\n// .cpp\n#include \"Widget.h\"\n#include <QMessageBox>//对话框头文件\nvoid Widget::closeEvent(QEvent *event){\n        int test=QMessageBox::question(this , \"question\",\"sure?\",\n        QMessageBox::Yes |\n        QMessageBox::No);\n        if(test==QMessageBox::Yes){\n                event->accept();//处理\n        }else{\n                event->ignore();//忽略\n        }\n\n}\n```\n![运行结果](qt/qtEvent4.png)\n# 绘画\n![运行的程序](qt/qtEventpainter1.png)\n![运行的结果](qt/qtEventpainter2.png)\n\n# 绘图设备\n* Pixmap(在平台上不能对图片进行修改)\n* Image(和平台无关平台上，可以对图片进行修改)\n* picture(保存绘图的状态，以二进制的文件进行保存)\n\n![pixmap](qt/qt_pixmap.png)\n![image](qt/qt_image.png)\n![picture](qt/qt_picture1.png)\n![picture](qt/qt_picture.png)\n![[icture]](qt/qt_picture2.png)\n\n**其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。**\n----\n> QPixmap&&QImage\n\n![](qt/qtzhuan.png)\n\n![](qt/qt_zhuan1.png)\n----\n# 不规则的窗口\n![程序](qt/qt_paint.png)\n![结果](qt/qt_paint1.png)\n\n**绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备(this)。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画(QPixmap(保存的是图片),QImage(保存的是图片),Qpicture(保存的是二进制文件))，save(保存),load(加载)，Rect(矩形)。**\n ----\n# File\n**不管在那个语言上，文件的操作都有一定的重要性，所以就把它学好。**\n* 普通的形式写读文件()\n\n```\n// 用到的头文件\n#include <QFile>\n#include <QFileDialg>\n#include <QFileInfo>\n```\n![](qt/qtFILE.png)\n![](qt/qtreadfile.png)\n![](qt/qtwritefile.png)\n* 是以二进制的形式保存文件\n```\n// 用到的头文件\n#include <QFile>\n#include <QDatestram>\n```\n![](qt/qt_Stream.png)\n# Server\n**记得在项目文件里加(network),这是针对于在类对象里没有提示。还有就是连则表达式(CONFIG+=c++11)**\n----\n![](qt/qt_server.png)\n**写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。**\n----\n```\n//用到的头文件\n#include <QTcpServer>\n#include <QTcpsocket>\n```\n![serven](qt/qt_tcpserven.png)\n![server](qt/qt_tcpserven1.png)\n![客户端](qt/qt_tcpserven2.png)\n**其实在上面的刚开始的第一张图就很清晰的讲到了tcp的连接过程，只要我们真的理解了就能看的明白。在这里也没什么好解释的，有很多的函数都是在函数里订好了的，只要我们搞清楚什么时候调用什么函数就行了。**\n> UDP\n* 它是面向无连接的通信，所以在这里就只需要通信的套接字(socket)。\n```\n// 用到的头文件\n#include <QUdpSocket> //.h(不要忘记在.h文件里声明socket套接字)\n#include <QHostAddress>// .cpp\n```\n![程序](qt/qt_udp1.png)\n![程序](qt/qt_udp2.png)\n![运行结果](qt/qt_udp.png)\n# tcpfile\n![流程图](qt/qt_tcpfile.png)\n**值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。**\n----\n# QThread\n**connect的第五个参数的意义(默认，队列，直接)默认的时候：分为多线程(默认使用队列)和单线程(默认使用直接)。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。** \n----\n","slug":"qt","published":1,"updated":"2019-09-12T07:17:17.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3dqz7rx000n4ez7xlmu5gze","content":"<pre><code>QT\n</code></pre><a id=\"more\"></a>\n<h1 id=\"Qt\"><a href=\"#Qt\" class=\"headerlink\" title=\"Qt\"></a>Qt</h1><h2 id=\"图形化界面–GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。\"><a href=\"#图形化界面–GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。\" class=\"headerlink\" title=\"图形化界面–GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。\"></a><em>图形化界面–GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。</em></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;QApplication&gt;//使用qt的头文件</span><br><span class=\"line\">#include &lt;QWidget&gt;//窗口控制基类</span><br><span class=\"line\">#include &lt;QPushButton&gt;//指定父对象的头文件</span><br><span class=\"line\">int main(int argc,char *argv[])&#123;</span><br><span class=\"line\">        QApplication  a(argc,argv);</span><br><span class=\"line\">        My_widget w;</span><br><span class=\"line\">        w.setwindowTitle(&quot;主要看气质&quot;);//文件头名</span><br><span class=\"line\">        QPushButton b;//声明按钮的类     </span><br><span class=\"line\">        b.setParent(&amp;w);//让按钮放在父对象的函数</span><br><span class=\"line\">        b.setText(&quot;删除&quot;);//声明按钮,并赋值</span><br><span class=\"line\">        b.move(100,100);//移动按钮</span><br><span class=\"line\">        QPushButton b1(&amp;w);//使用按钮构造函数并指向父对象</span><br><span class=\"line\">        b1.setText(&quot;确认&quot;);//声明按钮,并赋值</span><br><span class=\"line\">        b1.move(200,200);//移动按钮</span><br><span class=\"line\">        w.show();//输出函数</span><br><span class=\"line\">        return app.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/08/05/qt/qt1.png\" alt=\"运行结果\"></p>\n<p><strong>值得注意下的就是，如果不给按钮对象指向父对象，两个窗口是独立的。还有上面是用了两种方式来指向父对象，一个是用函数setParent(),另外一个是用构造函数来指向。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;QApplication&gt;</span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\">int main(int argc,char *argv[])&#123;</span><br><span class=\"line\">            QApplication a(argc,argv);</span><br><span class=\"line\">            QLabel label(&quot;Hello&quot;);</span><br><span class=\"line\">            return a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/08/05/qt/qt2_hello.png\" alt=\"运行结果\"></p>\n<p><strong>上面的代码有点不好，但要是一定要这样的话，那在main函数里面的代码是很多的。这样让别人看起来就有点不好的感觉。</strong><br><strong>QPushButton–是按钮，QWidget–是窗口</strong></p>\n<ul>\n<li>signals–信号(类似与广播，发出信号，如果有对它有意思的，就有connect连接，来把它连接在一起)</li>\n<li>connect–连接(意思是，用自己的函数(成为槽(solt))来处理这个信号)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//练练手，长长记性</span><br><span class=\"line\">//main函数里面的头文件</span><br><span class=\"line\">#include &lt;QApplication&gt;</span><br><span class=\"line\">#include &lt;QPushButton&gt;</span><br><span class=\"line\">#include &quot;My_Widget.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">//是以公有的方式继承了窗口化的类,.h文件</span><br><span class=\"line\">#include &quot;sud.h&quot;</span><br><span class=\"line\">class My_Widget:public Widget&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">        My_Widget(QWidget *parent =nullptr);</span><br><span class=\"line\">        ~My_Widget();</span><br><span class=\"line\">        void showb2();</span><br><span class=\"line\">        void showwid();</span><br><span class=\"line\">        void showxin();</span><br><span class=\"line\">private:</span><br><span class=\"line\">        QPushButton b1;</span><br><span class=\"line\">        QPushButton *b2;</span><br><span class=\"line\">        QPushButton b3;</span><br><span class=\"line\">        sud s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//.cpp文件</span><br><span class=\"line\">#include &quot;My_Widget.h&quot;</span><br><span class=\"line\">My_Widget::MyWidget(QWidget *parent =nullptr):QWidget(parent)&#123;</span><br><span class=\"line\">        b1.setParent(this);</span><br><span class=\"line\">        b1.setText(&quot;^_^&quot;);</span><br><span class=\"line\">        b1.move(100,100);</span><br><span class=\"line\">        b2=new QPushButton (this);</span><br><span class=\"line\">        b2-&gt;setText(&quot;abc&quot;);</span><br><span class=\"line\">        connect(&amp;b1,&amp;QPushButton::released,this,&amp;QPushButton::close);</span><br><span class=\"line\">        connect(b2,&amp;QPushButton::released,this,&amp;My_Widget::show);</span><br><span class=\"line\">        s.show();</span><br><span class=\"line\">        this-&gt;setWindowTitle(&quot;老大&quot;);</span><br><span class=\"line\">        b3.setParent(this);</span><br><span class=\"line\">        b3.setText(&quot;切换子窗口&quot;);</span><br><span class=\"line\">        connect(&amp;b3,&amp;QPushButton::released,this,My_Widget::showwid);</span><br><span class=\"line\">        connect(&amp;s,&amp;sud::xin,this,&amp;My_Widget::showxin);//接收信号并处理信号</span><br><span class=\"line\">        resize(400,300);</span><br><span class=\"line\">        //当信号发出时，被连接的槽函数会被回调用来处理信号发出的操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void My_Widget::showb2()&#123;</span><br><span class=\"line\">        b2-&gt;setText(&quot;123&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void My_Widget::showwid()&#123;</span><br><span class=\"line\">        s.show();</span><br><span class=\"line\">        this-&gt;hide();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void My_Widget::showxin&#123;</span><br><span class=\"line\">        this-&gt;show();</span><br><span class=\"line\">        s.hide();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//是以公有的方式继承My_Widget类的派生类</span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\">#include &lt;QPushButton&gt;</span><br><span class=\"line\">class sud : public My_Widget&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">        explicit*** sud(QWidget *parent =nullptr)</span><br><span class=\"line\">        void showwid();//用来发射信号的函数</span><br><span class=\"line\">signals:</span><br><span class=\"line\">        void xin();//信号</span><br><span class=\"line\">private:</span><br><span class=\"line\">        QPushButton b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void sud::sud(QWidget *parent):QWidget(parent)&#123;</span><br><span class=\"line\">        this-&gt;setWindowTitle(&quot;小弟&quot;);</span><br><span class=\"line\">        b.setParent(this);</span><br><span class=\"line\">        b.setText(&quot;切换父窗口&quot;);</span><br><span class=\"line\">        connect(&amp;b,QPushButton::clicked,this,&amp;sud::showwid);//发送信号的</span><br><span class=\"line\">        resize(400,300);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void sud::showwid()&#123;</span><br><span class=\"line\">        emit xin();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[] )&#123;</span><br><span class=\"line\">        QApplication a(argc,argv);</span><br><span class=\"line\">        My_Widget w;</span><br><span class=\"line\">        w.show();</span><br><span class=\"line\">        return a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h1><ul>\n<li>槽</li>\n</ul>\n<ol>\n<li>任意的成员函数，普通全局函数，静态函数</li>\n<li>槽函数需要与信号一样(返回值和参数)由于信号没有返回值，所以槽函数也没有返回值</li>\n</ol>\n<ul>\n<li>信号</li>\n</ul>\n<ol>\n<li>信号必须有关键字signals</li>\n<li>信号没有返回值，是个函数,可以有参数</li>\n<li>信号只有声明，无需为信号定义</li>\n<li>使用的方法:使用关键字emit来调用</li>\n</ol>\n<ul>\n<li><p>按钮只是回调了槽函数，而窗口的所有改动都是该窗口改变的，和按钮是没什么关联的。</p>\n</li>\n<li><p>内存</p>\n</li>\n</ul>\n<ol>\n<li>指定父对象后,直接或间接的继承于Q0bject</li>\n<li>子对象如果动态分配空间(new)，不需要手动释放(delete)，系统会自动调用析构函数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;QMenuBar&gt;//菜单栏</span><br><span class=\"line\">#include &lt;QMenu&gt;//菜单</span><br><span class=\"line\">#include &lt;QAction&gt;//控件</span><br><span class=\"line\">#include &lt;QToolBar&gt;//快捷键</span><br><span class=\"line\">#include &lt;QDebug&gt;//打印</span><br><span class=\"line\">#include &lt;QStatusBar&gt;//状态栏</span><br><span class=\"line\">#include &lt;QLabel&gt;//标签</span><br><span class=\"line\">#include &lt;QTextEdit&gt;//核心控件</span><br><span class=\"line\">#include &lt;QDockWidget&gt;//浮动窗口</span><br><span class=\"line\">* 创建菜单栏和一些控件</span><br><span class=\"line\">* 以下的代码是在构造函数的里面的，主要是懒得写了。</span><br><span class=\"line\">        QMenuBar *mbar=menuBar();//声明一个菜单栏</span><br><span class=\"line\">        Qmenu *f1=mbar-&gt;addAction(文件);//在菜单栏里写一个以文件为名的控件</span><br><span class=\"line\">        QAction *p1=f1-&gt;addAction(&quot;新建&quot;);//在文件里写一个以新建为名的控件</span><br><span class=\"line\">        connect(p1,&amp;QAction::triggered,//槽函数</span><br><span class=\"line\">        []()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                qDebug()&lt;&lt;&quot;新建被按下&quot;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        f1-&gt;addSeparator();//分割线</span><br><span class=\"line\">        QAction *p1_2=f1-&gt;addAction(&quot;打开&quot;);//同上</span><br><span class=\"line\">        Qmenu *f2=mbar-&gt;addAction(&quot;编辑&quot;);</span><br><span class=\"line\">        QAction *p2=f2-&gt;addAction(&quot;编辑&quot;);</span><br><span class=\"line\">        connect(p2,&amp;QAction::triggered,</span><br><span class=\"line\">        []()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                qDebug()&lt;&lt;&quot;编辑被按下&quot;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        QStatusBar *sbar=statusBar();//状态栏，声明状态栏</span><br><span class=\"line\">        QLabel *label= new QLabel (this);//声明标签</span><br><span class=\"line\">        sbar -&gt;addAction(new QLabel(&quot;2&quot;,this));//以从左往右的方式显示2</span><br><span class=\"line\">        sbar-&gt; addPermanentWidget(new QLabel(&quot;3&quot;,this));</span><br><span class=\"line\">        //以从右忘左的方式显示3</span><br><span class=\"line\">        QTextEdit *text=new QTextEdit(this);//核心控件，也就是文件编辑的地方</span><br><span class=\"line\">        setCentralWidget(text);</span><br><span class=\"line\">        QDockWidget *dock=new QDockWidget(this);//浮动窗口</span><br><span class=\"line\">        addDockWidget(Qt::LeftDockWidget,dock);//在左边显示</span><br><span class=\"line\">        QTextWidget *text1=new QTextWidget(this);//声明编辑</span><br><span class=\"line\">        dock-&gt;setWidget(text1);//在浮动窗口里显示文件编辑的地方</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<p><img src=\"/2019/08/05/qt/qt3_caidan.png\" alt=\"运行结果\"></p>\n<h1 id=\"关于对话框\"><a href=\"#关于对话框\" class=\"headerlink\" title=\"关于对话框\"></a>关于对话框</h1><hr>\n<ul>\n<li>是在继承于MainWindow(主窗口)的类构造函数里<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;QMainWindow&quot;//继承与主窗口</span><br><span class=\"line\">#include &lt;QMenuBar&gt;</span><br><span class=\"line\">#include &lt;Menu&gt;</span><br><span class=\"line\">#include &lt;QAction&gt;</span><br><span class=\"line\">#include &lt;QDebug&gt;</span><br><span class=\"line\">#include &lt;QMessageBox&gt;//对话框的头文件</span><br><span class=\"line\">#include &lt;QFileDialog&gt;//查找文件的对话框的头文件</span><br><span class=\"line\">MainWindow::MainWindow(QWinget *parent)</span><br><span class=\"line\">        :MainWindow(parent)&#123;</span><br><span class=\"line\">                QMenuBar *menub=menubar();</span><br><span class=\"line\">                QMenu *p1=menub-&gt;addmenu(&quot;文件&quot;);</span><br><span class=\"line\">                QAction *A1=p1-&gt;addaction(&quot;关于对话框&quot;);</span><br><span class=\"line\">                connect(A1,&amp;QAction::triggered,</span><br><span class=\"line\">                [=]()</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        QMessageBox ::about(this,&quot;about&quot;,&quot;关于Qt&quot;); </span><br><span class=\"line\">                        //简单的一个显示对话框</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                );</span><br><span class=\"line\">                QAction *A2=p1-&gt;addaction(&quot;问题对话框&quot;);</span><br><span class=\"line\">                connect(A2,&amp;QAction::triggered,</span><br><span class=\"line\">                [=]()</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        int val=QMessageBox::question(this,&quot;test&quot;,&quot;is ok ?&quot;,</span><br><span class=\"line\">                        QMessageBox::ok|</span><br><span class=\"line\">                        QMessageBox::Cancel);</span><br><span class=\"line\">                        //显示一个对话框，调用枚举函数来实现，显示的对话内容可以自己选择，也可以随机匹配，返回值是一个整数类型的，可以定义一个整数来接住函数的返回值，这样载利用switch来做到自己想要的效果</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                switch (val)&#123;</span><br><span class=\"line\">                        case QMessageBox::ok:</span><br><span class=\"line\">                        qDebug()&lt;&lt;&quot;i am ok&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                        case QMessageBox::Cancel:</span><br><span class=\"line\">                        qDebug()&lt;&lt;&quot;i am bad&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                        default:</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        QAction *A3=p1-&gt;addaction(&quot;文件对话框&quot;);</span><br><span class=\"line\">        connect(A3,&amp;QAction::triggered,</span><br><span class=\"line\">        [=]()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                QFileDialog ::getOpenFileName(this,&quot;open&quot;,&quot;/home&quot;,</span><br><span class=\"line\">                &quot;test(*.cpp *.md);;file(*.)&quot;);</span><br><span class=\"line\">                //利用Qt函数来实现查找文件的对话框，加上筛选的效果,来显示查找文件的强大性</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        );</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/2019/08/05/qt/qt4_duihua.png\" alt=\"运行结果\"></p>\n<p><img src=\"/2019/08/05/qt/qt5_duihua.png\" alt=\"运行结果\"></p>\n<h1 id=\"ui\"><a href=\"#ui\" class=\"headerlink\" title=\"ui\"></a>ui</h1><p><img src=\"/2019/08/05/qt/qt6_ui.png\" alt=\"这些是在ui模式下操作的\"></p>\n<blockquote>\n<p><strong>布局</strong></p>\n</blockquote>\n<hr>\n<p><strong>局部布局和全局布局,</strong></p>\n<h2 id=\"一样是在ui的模式下进行的，因为这样比较简单而且实际。\"><a href=\"#一样是在ui的模式下进行的，因为这样比较简单而且实际。\" class=\"headerlink\" title=\"一样是在ui的模式下进行的，因为这样比较简单而且实际。\"></a><strong>一样是在ui的模式下进行的，因为这样比较简单而且实际。</strong></h2><p><img src=\"/2019/08/05/qt/qt7_ui.png\" alt=\"运行结果\"><br><img src=\"/2019/08/05/qt/qt8_ui.png\" alt=\"运行结果\"></p>\n<h2 id=\"布局最好在ui模式，因为简单！！！\"><a href=\"#布局最好在ui模式，因为简单！！！\" class=\"headerlink\" title=\"布局最好在ui模式，因为简单！！！\"></a><strong>布局最好在ui模式，因为简单！！！</strong></h2><p><img src=\"/2019/08/05/qt/qt9_ui.png\" alt=\"简单的登录方式\"></p>\n<h1 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h1><p><strong>接下的操作是在ui的模式下完成的，并继承于Mainwindow</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#inlcude &quot;MainWindow.h&quot;</span><br><span class=\"line\">#include &lt;ui_mainwindow.h&gt;</span><br><span class=\"line\">#include &lt;QDebug&gt;//打印的头文件</span><br><span class=\"line\">#include &lt;QStringList&gt;</span><br><span class=\"line\">#include &lt;QCompleter&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">MainWindow::MainWindow(QWidget *parent):QMainwindow(parent)&#123;</span><br><span class=\"line\">        ui-&gt;setupUi(this);</span><br><span class=\"line\">        //在ui的模式下添加LineEdit(行编辑)</span><br><span class=\"line\">        QString str=ui-&gt;LineEdit-&gt;text();//获取一行里的内容</span><br><span class=\"line\">        qDebug&lt;&lt;str;//打印</span><br><span class=\"line\">        ui-&gt;LineEdit-&gt;setText(&quot;123456&quot;);//设置内容</span><br><span class=\"line\">        ui-&gt;LineEdit-&gt;setTextMargins(10,0,0,0);//更改方度(左,右,上,下)</span><br><span class=\"line\">        ui-&gt;LineEdit-&gt;setEchomode(QLineEdit::psaaword);//把内容设置为密码的模式</span><br><span class=\"line\">        QStringLest cin;//声明字符串</span><br><span class=\"line\">        cin&lt;&lt;&quot;hello&quot;&lt;&lt;&quot;how are you&quot;&lt;&lt;&quot;Hehe&quot;;//定义字符串</span><br><span class=\"line\">        QCompleter *com=new QCompleter (cin,this);//把字符串放进模型里</span><br><span class=\"line\">        com-&gt;setCaseSensitivity(Qt::CaseInsensitive);//把模型设置成不区分大小写</span><br><span class=\"line\">        ui-&gt;LineEdit-&gt;setCompleter(com);//把模型加进行编辑</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h1><p>1 方箱模型<br>2 前景和背景<br>3 控制大小<br>4 创建缩放式<br>5 处理伪状态<br><strong>关键字(setStyleSheet)</strong></p>\n<ul>\n<li><p>创建的是Widget，是在ui的模式下添加了一个label和PushButton。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// .cpp</span><br><span class=\"line\">  ui-&gt;pushButton-&gt;setStyleSheet(&quot;QPushButton&#123;&quot;</span><br><span class=\"line\">  &quot;color:rgb(0,255,255);&quot; //设置颜色，自动调制颜色</span><br><span class=\"line\">  &quot;backgroud-color:red;&quot; //设置背景颜色</span><br><span class=\"line\">  &quot;border: 2px outset grenn;&quot;//创建缩放式(设置边框像素，输出设置，输出的颜色)</span><br><span class=\"line\">  &quot;border-image:url(:/new/prefix1/头像.jpg);&quot;//设置成相片，</span><br><span class=\"line\"> &quot;&#125;&quot;</span><br><span class=\"line\">        &quot;QPushButton:hover&#123;&quot;//当鼠标抬起就更换照片</span><br><span class=\"line\">        &quot;border-image:url(:/new/prefix1/test.jpg)&quot;</span><br><span class=\"line\">        &quot;&#125;&quot;</span><br><span class=\"line\">        &quot;QPushButton:pressed&#123;&quot;//当鼠标按下就更换照片</span><br><span class=\"line\">        &quot;border-image:url(:/new/prefix1/test1.jpg)&quot;</span><br><span class=\"line\">        &quot;&#125;&quot;</span><br><span class=\"line\"> );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>border (平铺的方式) </p>\n</li>\n</ul>\n<p><img src=\"/2019/08/05/qt/qt10_ui.png\" alt=\"运行结果\"><br><img src=\"/2019/08/05/qt/qt11_ui.png\" alt=\"方箱模型\"><br><img src=\"/2019/08/05/qt/qt12_ui.png\" alt=\"伪状态\"></p>\n<h1 id=\"Event-事件\"><a href=\"#Event-事件\" class=\"headerlink\" title=\"Event(事件)\"></a>Event(事件)</h1><h2 id=\"事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。\"><a href=\"#事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。\" class=\"headerlink\" title=\"事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。\"></a><strong>事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这里是在ui的模式下添加了label，然后又添加了新文件，最后在ui里把label提升为槽函数而实现的。</span><br><span class=\"line\">// .h</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\">class Mylabel : public Qlabel&#123;</span><br><span class=\"line\">        protected://保护的(重写事件里的虚函数)</span><br><span class=\"line\">        //鼠标按下</span><br><span class=\"line\">        void mousePressEvent(QMouseEvent *ev);</span><br><span class=\"line\">        //鼠标抬起</span><br><span class=\"line\">        void mouseReleaseEvent(QMouseEvent *ev);</span><br><span class=\"line\">        //鼠标移动</span><br><span class=\"line\">        void mouseMoveEvent(QMouseEvent *ev);</span><br><span class=\"line\">        //鼠标在里面</span><br><span class=\"line\">        void enterEvent(QEvent *);</span><br><span class=\"line\">        //鼠标在外面</span><br><span class=\"line\">        void leaveEvent(QEvent *);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// .cpp</span><br><span class=\"line\">#include &quot;Mylabel.h&quot;</span><br><span class=\"line\">#include &lt;MouseEvent&gt;//事件的头文件</span><br><span class=\"line\">#include &lt;QDebug&gt; //打印</span><br><span class=\"line\">Mylabel::Mylabel(QWidget *parent):QLabel(parent)&#123;</span><br><span class=\"line\">        //设置追踪鼠标(设置了鼠标追踪就会在程序里自动追踪鼠标，没有设置的话，你还得在窗口里点一下才能出来数据)</span><br><span class=\"line\">        this-&gt;setMouseTracking(true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mylabel::mousePressEvent(QMouseEvent *ev)&#123;</span><br><span class=\"line\">        int i=ev-&gt;x();//x的坐标</span><br><span class=\"line\">        int j=ev-&gt;y();//y的坐标</span><br><span class=\"line\">QSting str=QString (&quot;&lt;center&gt;&lt;h1&gt;mouse press:(%1,%2)&lt;/h1&gt;&lt;/center&gt;&quot;)</span><br><span class=\"line\">.arg(i).arg(j);</span><br><span class=\"line\">// 语法(参数是字符) (center(字体加粗))</span><br><span class=\"line\">this-&gt;setText(str);//设置</span><br><span class=\"line\">if(ev-&gt;Button()==Qt::LefeButton)&#123;//判断鼠标按钮在左边，右边，中间</span><br><span class=\"line\">        qDebug()&lt;&lt;&quot;left&quot;;</span><br><span class=\"line\">&#125;else if(ev-&gt;Button()==Qt::RightNutton)&#123;</span><br><span class=\"line\">        qDebug()&lt;&lt;&quot;right&quot;;</span><br><span class=\"line\">&#125;else if(ev-&gt;Button()==Qt::MidButton)&#123;</span><br><span class=\"line\">        qDebug()&lt;&lt;&quot;wid&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mylabel::mouseReleaseEvent(QMouseEvent *ev)&#123;</span><br><span class=\"line\">QSting str=QString (&quot;&lt;center&gt;&lt;h1&gt;mouse press:(%1,%2)&lt;/h1&gt;&lt;/center&gt;&quot;)</span><br><span class=\"line\">.arg(ev-&gt;x()).arg(ev-&gt;y());</span><br><span class=\"line\">this-&gt;setText(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mylabel::mouseMoveEvent(QMouseEvent *ev)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">QSting str=QString (&quot;&lt;center&gt;&lt;h1&gt;mouse move:(%1,%2)&lt;/h1&gt;&lt;/center&gt;&quot;)</span><br><span class=\"line\">.arg(ev-&gt;x()).arg(ev-&gt;y());</span><br><span class=\"line\">this-&gt;setText(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mylabel::enterEvent(QEvent *e)&#123;</span><br><span class=\"line\">        QString str=QString(&quot;&lt;center&gt;&lt;h1&gt;Event:enter&lt;/h1&gt;&lt;/center&gt;&quot;);</span><br><span class=\"line\">        this-&gt;setText(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mtlabel::lavceEvent(QEvent *e)&#123;</span><br><span class=\"line\">        QString str=QString(&quot;&lt;center&gt;&lt;h1&gt;Event:leave&lt;/h1&gt;&lt;.center&gt;&quot;);</span><br><span class=\"line\">        this-&gt;setText(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/08/05/qt/qtEvent.png\" alt=\"运行结果\"></p>\n<p><img src=\"/2019/08/05/qt/qtEvent1.png\" alt=\"运行结果\"></p>\n<p><img src=\"/2019/08/05/qt/qtEvent2.png\" alt=\"运行结果\"></p>\n<p><img src=\"/2019/08/05/qt/qtEvent3.png\" alt=\"运行结果\"></p>\n<blockquote>\n<p>时间的处理与忽略</p>\n<ul>\n<li>继承于widget的前提下，简写。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// .h</span><br><span class=\"line\">void closeEvent (QEvent *event);//关闭事件</span><br><span class=\"line\">// .cpp</span><br><span class=\"line\">#include &quot;Widget.h&quot;</span><br><span class=\"line\">#include &lt;QMessageBox&gt;//对话框头文件</span><br><span class=\"line\">void Widget::closeEvent(QEvent *event)&#123;</span><br><span class=\"line\">        int test=QMessageBox::question(this , &quot;question&quot;,&quot;sure?&quot;,</span><br><span class=\"line\">        QMessageBox::Yes |</span><br><span class=\"line\">        QMessageBox::No);</span><br><span class=\"line\">        if(test==QMessageBox::Yes)&#123;</span><br><span class=\"line\">                event-&gt;accept();//处理</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">                event-&gt;ignore();//忽略</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/08/05/qt/qtEvent4.png\" alt=\"运行结果\"></p>\n<h1 id=\"绘画\"><a href=\"#绘画\" class=\"headerlink\" title=\"绘画\"></a>绘画</h1><p><img src=\"/2019/08/05/qt/qtEventpainter1.png\" alt=\"运行的程序\"><br><img src=\"/2019/08/05/qt/qtEventpainter2.png\" alt=\"运行的结果\"></p>\n<h1 id=\"绘图设备\"><a href=\"#绘图设备\" class=\"headerlink\" title=\"绘图设备\"></a>绘图设备</h1><ul>\n<li>Pixmap(在平台上不能对图片进行修改)</li>\n<li>Image(和平台无关平台上，可以对图片进行修改)</li>\n<li>picture(保存绘图的状态，以二进制的文件进行保存)</li>\n</ul>\n<p><img src=\"/2019/08/05/qt/qt_pixmap.png\" alt=\"pixmap\"><br><img src=\"/2019/08/05/qt/qt_image.png\" alt=\"image\"><br><img src=\"/2019/08/05/qt/qt_picture1.png\" alt=\"picture\"><br><img src=\"/2019/08/05/qt/qt_picture.png\" alt=\"picture\"><br><img src=\"/2019/08/05/qt/qt_picture2.png\" alt=\"[icture]\"></p>\n<h2 id=\"其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。\"><a href=\"#其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。\" class=\"headerlink\" title=\"其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。\"></a><strong>其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。</strong></h2><blockquote>\n<p>QPixmap&amp;&amp;QImage</p>\n</blockquote>\n<p><img src=\"/2019/08/05/qt/qtzhuan.png\" alt></p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2019/08/05/qt/qt_zhuan1.png\" alt></h2><h1 id=\"不规则的窗口\"><a href=\"#不规则的窗口\" class=\"headerlink\" title=\"不规则的窗口\"></a>不规则的窗口</h1><p><img src=\"/2019/08/05/qt/qt_paint.png\" alt=\"程序\"><br><img src=\"/2019/08/05/qt/qt_paint1.png\" alt=\"结果\"></p>\n<h2 id=\"绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备-this-。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画-QPixmap-保存的是图片-QImage-保存的是图片-Qpicture-保存的是二进制文件-，save-保存-load-加载-，Rect-矩形-。\"><a href=\"#绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备-this-。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画-QPixmap-保存的是图片-QImage-保存的是图片-Qpicture-保存的是二进制文件-，save-保存-load-加载-，Rect-矩形-。\" class=\"headerlink\" title=\"绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备(this)。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画(QPixmap(保存的是图片),QImage(保存的是图片),Qpicture(保存的是二进制文件))，save(保存),load(加载)，Rect(矩形)。\"></a><strong>绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备(this)。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画(QPixmap(保存的是图片),QImage(保存的是图片),Qpicture(保存的是二进制文件))，save(保存),load(加载)，Rect(矩形)。</strong></h2><h1 id=\"File\"><a href=\"#File\" class=\"headerlink\" title=\"File\"></a>File</h1><p><strong>不管在那个语言上，文件的操作都有一定的重要性，所以就把它学好。</strong></p>\n<ul>\n<li>普通的形式写读文件()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用到的头文件</span><br><span class=\"line\">#include &lt;QFile&gt;</span><br><span class=\"line\">#include &lt;QFileDialg&gt;</span><br><span class=\"line\">#include &lt;QFileInfo&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/08/05/qt/qtFILE.png\" alt><br><img src=\"/2019/08/05/qt/qtreadfile.png\" alt><br><img src=\"/2019/08/05/qt/qtwritefile.png\" alt></p>\n<ul>\n<li>是以二进制的形式保存文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用到的头文件</span><br><span class=\"line\">#include &lt;QFile&gt;</span><br><span class=\"line\">#include &lt;QDatestram&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/2019/08/05/qt/qt_Stream.png\" alt></p>\n<h1 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h1><h2 id=\"记得在项目文件里加-network-这是针对于在类对象里没有提示。还有就是连则表达式-CONFIG-c-11\"><a href=\"#记得在项目文件里加-network-这是针对于在类对象里没有提示。还有就是连则表达式-CONFIG-c-11\" class=\"headerlink\" title=\"记得在项目文件里加(network),这是针对于在类对象里没有提示。还有就是连则表达式(CONFIG+=c++11)\"></a><strong>记得在项目文件里加(network),这是针对于在类对象里没有提示。还有就是连则表达式(CONFIG+=c++11)</strong></h2><p><img src=\"/2019/08/05/qt/qt_server.png\" alt></p>\n<h2 id=\"写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。\"><a href=\"#写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。\" class=\"headerlink\" title=\"写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。\"></a><strong>写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用到的头文件</span><br><span class=\"line\">#include &lt;QTcpServer&gt;</span><br><span class=\"line\">#include &lt;QTcpsocket&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/08/05/qt/qt_tcpserven.png\" alt=\"serven\"><br><img src=\"/2019/08/05/qt/qt_tcpserven1.png\" alt=\"server\"><br><img src=\"/2019/08/05/qt/qt_tcpserven2.png\" alt=\"客户端\"><br><strong>其实在上面的刚开始的第一张图就很清晰的讲到了tcp的连接过程，只要我们真的理解了就能看的明白。在这里也没什么好解释的，有很多的函数都是在函数里订好了的，只要我们搞清楚什么时候调用什么函数就行了。</strong></p>\n<blockquote>\n<p>UDP</p>\n<ul>\n<li>它是面向无连接的通信，所以在这里就只需要通信的套接字(socket)。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用到的头文件</span><br><span class=\"line\">#include &lt;QUdpSocket&gt; //.h(不要忘记在.h文件里声明socket套接字)</span><br><span class=\"line\">#include &lt;QHostAddress&gt;// .cpp</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/08/05/qt/qt_udp1.png\" alt=\"程序\"><br><img src=\"/2019/08/05/qt/qt_udp2.png\" alt=\"程序\"><br><img src=\"/2019/08/05/qt/qt_udp.png\" alt=\"运行结果\"></p>\n<h1 id=\"tcpfile\"><a href=\"#tcpfile\" class=\"headerlink\" title=\"tcpfile\"></a>tcpfile</h1><p><img src=\"/2019/08/05/qt/qt_tcpfile.png\" alt=\"流程图\"></p>\n<h2 id=\"值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。\"><a href=\"#值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。\" class=\"headerlink\" title=\"值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。\"></a><strong>值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。</strong></h2><h1 id=\"QThread\"><a href=\"#QThread\" class=\"headerlink\" title=\"QThread\"></a>QThread</h1><h2 id=\"connect的第五个参数的意义-默认，队列，直接-默认的时候：分为多线程-默认使用队列-和单线程-默认使用直接-。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。\"><a href=\"#connect的第五个参数的意义-默认，队列，直接-默认的时候：分为多线程-默认使用队列-和单线程-默认使用直接-。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。\" class=\"headerlink\" title=\"connect的第五个参数的意义(默认，队列，直接)默认的时候：分为多线程(默认使用队列)和单线程(默认使用直接)。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。 \"></a><strong>connect的第五个参数的意义(默认，队列，直接)默认的时候：分为多线程(默认使用队列)和单线程(默认使用直接)。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。</strong> </h2>","site":{"data":{}},"excerpt":"<pre><code>QT\n</code></pre>","more":"<h1 id=\"Qt\"><a href=\"#Qt\" class=\"headerlink\" title=\"Qt\"></a>Qt</h1><h2 id=\"图形化界面–GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。\"><a href=\"#图形化界面–GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。\" class=\"headerlink\" title=\"图形化界面–GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。\"></a><em>图形化界面–GUI。这个工具对于程序员的开发是便利的，特别是开发用户的图形化界面，在Linux里也是用到了qt的。</em></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;QApplication&gt;//使用qt的头文件</span><br><span class=\"line\">#include &lt;QWidget&gt;//窗口控制基类</span><br><span class=\"line\">#include &lt;QPushButton&gt;//指定父对象的头文件</span><br><span class=\"line\">int main(int argc,char *argv[])&#123;</span><br><span class=\"line\">        QApplication  a(argc,argv);</span><br><span class=\"line\">        My_widget w;</span><br><span class=\"line\">        w.setwindowTitle(&quot;主要看气质&quot;);//文件头名</span><br><span class=\"line\">        QPushButton b;//声明按钮的类     </span><br><span class=\"line\">        b.setParent(&amp;w);//让按钮放在父对象的函数</span><br><span class=\"line\">        b.setText(&quot;删除&quot;);//声明按钮,并赋值</span><br><span class=\"line\">        b.move(100,100);//移动按钮</span><br><span class=\"line\">        QPushButton b1(&amp;w);//使用按钮构造函数并指向父对象</span><br><span class=\"line\">        b1.setText(&quot;确认&quot;);//声明按钮,并赋值</span><br><span class=\"line\">        b1.move(200,200);//移动按钮</span><br><span class=\"line\">        w.show();//输出函数</span><br><span class=\"line\">        return app.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/08/05/qt/qt1.png\" alt=\"运行结果\"></p>\n<p><strong>值得注意下的就是，如果不给按钮对象指向父对象，两个窗口是独立的。还有上面是用了两种方式来指向父对象，一个是用函数setParent(),另外一个是用构造函数来指向。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;QApplication&gt;</span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\">int main(int argc,char *argv[])&#123;</span><br><span class=\"line\">            QApplication a(argc,argv);</span><br><span class=\"line\">            QLabel label(&quot;Hello&quot;);</span><br><span class=\"line\">            return a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/08/05/qt/qt2_hello.png\" alt=\"运行结果\"></p>\n<p><strong>上面的代码有点不好，但要是一定要这样的话，那在main函数里面的代码是很多的。这样让别人看起来就有点不好的感觉。</strong><br><strong>QPushButton–是按钮，QWidget–是窗口</strong></p>\n<ul>\n<li>signals–信号(类似与广播，发出信号，如果有对它有意思的，就有connect连接，来把它连接在一起)</li>\n<li>connect–连接(意思是，用自己的函数(成为槽(solt))来处理这个信号)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//练练手，长长记性</span><br><span class=\"line\">//main函数里面的头文件</span><br><span class=\"line\">#include &lt;QApplication&gt;</span><br><span class=\"line\">#include &lt;QPushButton&gt;</span><br><span class=\"line\">#include &quot;My_Widget.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">//是以公有的方式继承了窗口化的类,.h文件</span><br><span class=\"line\">#include &quot;sud.h&quot;</span><br><span class=\"line\">class My_Widget:public Widget&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">        My_Widget(QWidget *parent =nullptr);</span><br><span class=\"line\">        ~My_Widget();</span><br><span class=\"line\">        void showb2();</span><br><span class=\"line\">        void showwid();</span><br><span class=\"line\">        void showxin();</span><br><span class=\"line\">private:</span><br><span class=\"line\">        QPushButton b1;</span><br><span class=\"line\">        QPushButton *b2;</span><br><span class=\"line\">        QPushButton b3;</span><br><span class=\"line\">        sud s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//.cpp文件</span><br><span class=\"line\">#include &quot;My_Widget.h&quot;</span><br><span class=\"line\">My_Widget::MyWidget(QWidget *parent =nullptr):QWidget(parent)&#123;</span><br><span class=\"line\">        b1.setParent(this);</span><br><span class=\"line\">        b1.setText(&quot;^_^&quot;);</span><br><span class=\"line\">        b1.move(100,100);</span><br><span class=\"line\">        b2=new QPushButton (this);</span><br><span class=\"line\">        b2-&gt;setText(&quot;abc&quot;);</span><br><span class=\"line\">        connect(&amp;b1,&amp;QPushButton::released,this,&amp;QPushButton::close);</span><br><span class=\"line\">        connect(b2,&amp;QPushButton::released,this,&amp;My_Widget::show);</span><br><span class=\"line\">        s.show();</span><br><span class=\"line\">        this-&gt;setWindowTitle(&quot;老大&quot;);</span><br><span class=\"line\">        b3.setParent(this);</span><br><span class=\"line\">        b3.setText(&quot;切换子窗口&quot;);</span><br><span class=\"line\">        connect(&amp;b3,&amp;QPushButton::released,this,My_Widget::showwid);</span><br><span class=\"line\">        connect(&amp;s,&amp;sud::xin,this,&amp;My_Widget::showxin);//接收信号并处理信号</span><br><span class=\"line\">        resize(400,300);</span><br><span class=\"line\">        //当信号发出时，被连接的槽函数会被回调用来处理信号发出的操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void My_Widget::showb2()&#123;</span><br><span class=\"line\">        b2-&gt;setText(&quot;123&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void My_Widget::showwid()&#123;</span><br><span class=\"line\">        s.show();</span><br><span class=\"line\">        this-&gt;hide();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void My_Widget::showxin&#123;</span><br><span class=\"line\">        this-&gt;show();</span><br><span class=\"line\">        s.hide();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//是以公有的方式继承My_Widget类的派生类</span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\">#include &lt;QPushButton&gt;</span><br><span class=\"line\">class sud : public My_Widget&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">        explicit*** sud(QWidget *parent =nullptr)</span><br><span class=\"line\">        void showwid();//用来发射信号的函数</span><br><span class=\"line\">signals:</span><br><span class=\"line\">        void xin();//信号</span><br><span class=\"line\">private:</span><br><span class=\"line\">        QPushButton b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void sud::sud(QWidget *parent):QWidget(parent)&#123;</span><br><span class=\"line\">        this-&gt;setWindowTitle(&quot;小弟&quot;);</span><br><span class=\"line\">        b.setParent(this);</span><br><span class=\"line\">        b.setText(&quot;切换父窗口&quot;);</span><br><span class=\"line\">        connect(&amp;b,QPushButton::clicked,this,&amp;sud::showwid);//发送信号的</span><br><span class=\"line\">        resize(400,300);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void sud::showwid()&#123;</span><br><span class=\"line\">        emit xin();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[] )&#123;</span><br><span class=\"line\">        QApplication a(argc,argv);</span><br><span class=\"line\">        My_Widget w;</span><br><span class=\"line\">        w.show();</span><br><span class=\"line\">        return a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h1><ul>\n<li>槽</li>\n</ul>\n<ol>\n<li>任意的成员函数，普通全局函数，静态函数</li>\n<li>槽函数需要与信号一样(返回值和参数)由于信号没有返回值，所以槽函数也没有返回值</li>\n</ol>\n<ul>\n<li>信号</li>\n</ul>\n<ol>\n<li>信号必须有关键字signals</li>\n<li>信号没有返回值，是个函数,可以有参数</li>\n<li>信号只有声明，无需为信号定义</li>\n<li>使用的方法:使用关键字emit来调用</li>\n</ol>\n<ul>\n<li><p>按钮只是回调了槽函数，而窗口的所有改动都是该窗口改变的，和按钮是没什么关联的。</p>\n</li>\n<li><p>内存</p>\n</li>\n</ul>\n<ol>\n<li>指定父对象后,直接或间接的继承于Q0bject</li>\n<li>子对象如果动态分配空间(new)，不需要手动释放(delete)，系统会自动调用析构函数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;QMenuBar&gt;//菜单栏</span><br><span class=\"line\">#include &lt;QMenu&gt;//菜单</span><br><span class=\"line\">#include &lt;QAction&gt;//控件</span><br><span class=\"line\">#include &lt;QToolBar&gt;//快捷键</span><br><span class=\"line\">#include &lt;QDebug&gt;//打印</span><br><span class=\"line\">#include &lt;QStatusBar&gt;//状态栏</span><br><span class=\"line\">#include &lt;QLabel&gt;//标签</span><br><span class=\"line\">#include &lt;QTextEdit&gt;//核心控件</span><br><span class=\"line\">#include &lt;QDockWidget&gt;//浮动窗口</span><br><span class=\"line\">* 创建菜单栏和一些控件</span><br><span class=\"line\">* 以下的代码是在构造函数的里面的，主要是懒得写了。</span><br><span class=\"line\">        QMenuBar *mbar=menuBar();//声明一个菜单栏</span><br><span class=\"line\">        Qmenu *f1=mbar-&gt;addAction(文件);//在菜单栏里写一个以文件为名的控件</span><br><span class=\"line\">        QAction *p1=f1-&gt;addAction(&quot;新建&quot;);//在文件里写一个以新建为名的控件</span><br><span class=\"line\">        connect(p1,&amp;QAction::triggered,//槽函数</span><br><span class=\"line\">        []()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                qDebug()&lt;&lt;&quot;新建被按下&quot;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        f1-&gt;addSeparator();//分割线</span><br><span class=\"line\">        QAction *p1_2=f1-&gt;addAction(&quot;打开&quot;);//同上</span><br><span class=\"line\">        Qmenu *f2=mbar-&gt;addAction(&quot;编辑&quot;);</span><br><span class=\"line\">        QAction *p2=f2-&gt;addAction(&quot;编辑&quot;);</span><br><span class=\"line\">        connect(p2,&amp;QAction::triggered,</span><br><span class=\"line\">        []()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                qDebug()&lt;&lt;&quot;编辑被按下&quot;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        QStatusBar *sbar=statusBar();//状态栏，声明状态栏</span><br><span class=\"line\">        QLabel *label= new QLabel (this);//声明标签</span><br><span class=\"line\">        sbar -&gt;addAction(new QLabel(&quot;2&quot;,this));//以从左往右的方式显示2</span><br><span class=\"line\">        sbar-&gt; addPermanentWidget(new QLabel(&quot;3&quot;,this));</span><br><span class=\"line\">        //以从右忘左的方式显示3</span><br><span class=\"line\">        QTextEdit *text=new QTextEdit(this);//核心控件，也就是文件编辑的地方</span><br><span class=\"line\">        setCentralWidget(text);</span><br><span class=\"line\">        QDockWidget *dock=new QDockWidget(this);//浮动窗口</span><br><span class=\"line\">        addDockWidget(Qt::LeftDockWidget,dock);//在左边显示</span><br><span class=\"line\">        QTextWidget *text1=new QTextWidget(this);//声明编辑</span><br><span class=\"line\">        dock-&gt;setWidget(text1);//在浮动窗口里显示文件编辑的地方</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<p><img src=\"/2019/08/05/qt/qt3_caidan.png\" alt=\"运行结果\"></p>\n<h1 id=\"关于对话框\"><a href=\"#关于对话框\" class=\"headerlink\" title=\"关于对话框\"></a>关于对话框</h1><hr>\n<ul>\n<li>是在继承于MainWindow(主窗口)的类构造函数里<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;QMainWindow&quot;//继承与主窗口</span><br><span class=\"line\">#include &lt;QMenuBar&gt;</span><br><span class=\"line\">#include &lt;Menu&gt;</span><br><span class=\"line\">#include &lt;QAction&gt;</span><br><span class=\"line\">#include &lt;QDebug&gt;</span><br><span class=\"line\">#include &lt;QMessageBox&gt;//对话框的头文件</span><br><span class=\"line\">#include &lt;QFileDialog&gt;//查找文件的对话框的头文件</span><br><span class=\"line\">MainWindow::MainWindow(QWinget *parent)</span><br><span class=\"line\">        :MainWindow(parent)&#123;</span><br><span class=\"line\">                QMenuBar *menub=menubar();</span><br><span class=\"line\">                QMenu *p1=menub-&gt;addmenu(&quot;文件&quot;);</span><br><span class=\"line\">                QAction *A1=p1-&gt;addaction(&quot;关于对话框&quot;);</span><br><span class=\"line\">                connect(A1,&amp;QAction::triggered,</span><br><span class=\"line\">                [=]()</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        QMessageBox ::about(this,&quot;about&quot;,&quot;关于Qt&quot;); </span><br><span class=\"line\">                        //简单的一个显示对话框</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                );</span><br><span class=\"line\">                QAction *A2=p1-&gt;addaction(&quot;问题对话框&quot;);</span><br><span class=\"line\">                connect(A2,&amp;QAction::triggered,</span><br><span class=\"line\">                [=]()</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        int val=QMessageBox::question(this,&quot;test&quot;,&quot;is ok ?&quot;,</span><br><span class=\"line\">                        QMessageBox::ok|</span><br><span class=\"line\">                        QMessageBox::Cancel);</span><br><span class=\"line\">                        //显示一个对话框，调用枚举函数来实现，显示的对话内容可以自己选择，也可以随机匹配，返回值是一个整数类型的，可以定义一个整数来接住函数的返回值，这样载利用switch来做到自己想要的效果</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                switch (val)&#123;</span><br><span class=\"line\">                        case QMessageBox::ok:</span><br><span class=\"line\">                        qDebug()&lt;&lt;&quot;i am ok&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                        case QMessageBox::Cancel:</span><br><span class=\"line\">                        qDebug()&lt;&lt;&quot;i am bad&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                        default:</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        QAction *A3=p1-&gt;addaction(&quot;文件对话框&quot;);</span><br><span class=\"line\">        connect(A3,&amp;QAction::triggered,</span><br><span class=\"line\">        [=]()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                QFileDialog ::getOpenFileName(this,&quot;open&quot;,&quot;/home&quot;,</span><br><span class=\"line\">                &quot;test(*.cpp *.md);;file(*.)&quot;);</span><br><span class=\"line\">                //利用Qt函数来实现查找文件的对话框，加上筛选的效果,来显示查找文件的强大性</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        );</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/2019/08/05/qt/qt4_duihua.png\" alt=\"运行结果\"></p>\n<p><img src=\"/2019/08/05/qt/qt5_duihua.png\" alt=\"运行结果\"></p>\n<h1 id=\"ui\"><a href=\"#ui\" class=\"headerlink\" title=\"ui\"></a>ui</h1><p><img src=\"/2019/08/05/qt/qt6_ui.png\" alt=\"这些是在ui模式下操作的\"></p>\n<blockquote>\n<p><strong>布局</strong></p>\n</blockquote>\n<hr>\n<p><strong>局部布局和全局布局,</strong></p>\n<h2 id=\"一样是在ui的模式下进行的，因为这样比较简单而且实际。\"><a href=\"#一样是在ui的模式下进行的，因为这样比较简单而且实际。\" class=\"headerlink\" title=\"一样是在ui的模式下进行的，因为这样比较简单而且实际。\"></a><strong>一样是在ui的模式下进行的，因为这样比较简单而且实际。</strong></h2><p><img src=\"/2019/08/05/qt/qt7_ui.png\" alt=\"运行结果\"><br><img src=\"/2019/08/05/qt/qt8_ui.png\" alt=\"运行结果\"></p>\n<h2 id=\"布局最好在ui模式，因为简单！！！\"><a href=\"#布局最好在ui模式，因为简单！！！\" class=\"headerlink\" title=\"布局最好在ui模式，因为简单！！！\"></a><strong>布局最好在ui模式，因为简单！！！</strong></h2><p><img src=\"/2019/08/05/qt/qt9_ui.png\" alt=\"简单的登录方式\"></p>\n<h1 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h1><p><strong>接下的操作是在ui的模式下完成的，并继承于Mainwindow</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#inlcude &quot;MainWindow.h&quot;</span><br><span class=\"line\">#include &lt;ui_mainwindow.h&gt;</span><br><span class=\"line\">#include &lt;QDebug&gt;//打印的头文件</span><br><span class=\"line\">#include &lt;QStringList&gt;</span><br><span class=\"line\">#include &lt;QCompleter&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">MainWindow::MainWindow(QWidget *parent):QMainwindow(parent)&#123;</span><br><span class=\"line\">        ui-&gt;setupUi(this);</span><br><span class=\"line\">        //在ui的模式下添加LineEdit(行编辑)</span><br><span class=\"line\">        QString str=ui-&gt;LineEdit-&gt;text();//获取一行里的内容</span><br><span class=\"line\">        qDebug&lt;&lt;str;//打印</span><br><span class=\"line\">        ui-&gt;LineEdit-&gt;setText(&quot;123456&quot;);//设置内容</span><br><span class=\"line\">        ui-&gt;LineEdit-&gt;setTextMargins(10,0,0,0);//更改方度(左,右,上,下)</span><br><span class=\"line\">        ui-&gt;LineEdit-&gt;setEchomode(QLineEdit::psaaword);//把内容设置为密码的模式</span><br><span class=\"line\">        QStringLest cin;//声明字符串</span><br><span class=\"line\">        cin&lt;&lt;&quot;hello&quot;&lt;&lt;&quot;how are you&quot;&lt;&lt;&quot;Hehe&quot;;//定义字符串</span><br><span class=\"line\">        QCompleter *com=new QCompleter (cin,this);//把字符串放进模型里</span><br><span class=\"line\">        com-&gt;setCaseSensitivity(Qt::CaseInsensitive);//把模型设置成不区分大小写</span><br><span class=\"line\">        ui-&gt;LineEdit-&gt;setCompleter(com);//把模型加进行编辑</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h1><p>1 方箱模型<br>2 前景和背景<br>3 控制大小<br>4 创建缩放式<br>5 处理伪状态<br><strong>关键字(setStyleSheet)</strong></p>\n<ul>\n<li><p>创建的是Widget，是在ui的模式下添加了一个label和PushButton。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// .cpp</span><br><span class=\"line\">  ui-&gt;pushButton-&gt;setStyleSheet(&quot;QPushButton&#123;&quot;</span><br><span class=\"line\">  &quot;color:rgb(0,255,255);&quot; //设置颜色，自动调制颜色</span><br><span class=\"line\">  &quot;backgroud-color:red;&quot; //设置背景颜色</span><br><span class=\"line\">  &quot;border: 2px outset grenn;&quot;//创建缩放式(设置边框像素，输出设置，输出的颜色)</span><br><span class=\"line\">  &quot;border-image:url(:/new/prefix1/头像.jpg);&quot;//设置成相片，</span><br><span class=\"line\"> &quot;&#125;&quot;</span><br><span class=\"line\">        &quot;QPushButton:hover&#123;&quot;//当鼠标抬起就更换照片</span><br><span class=\"line\">        &quot;border-image:url(:/new/prefix1/test.jpg)&quot;</span><br><span class=\"line\">        &quot;&#125;&quot;</span><br><span class=\"line\">        &quot;QPushButton:pressed&#123;&quot;//当鼠标按下就更换照片</span><br><span class=\"line\">        &quot;border-image:url(:/new/prefix1/test1.jpg)&quot;</span><br><span class=\"line\">        &quot;&#125;&quot;</span><br><span class=\"line\"> );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>border (平铺的方式) </p>\n</li>\n</ul>\n<p><img src=\"/2019/08/05/qt/qt10_ui.png\" alt=\"运行结果\"><br><img src=\"/2019/08/05/qt/qt11_ui.png\" alt=\"方箱模型\"><br><img src=\"/2019/08/05/qt/qt12_ui.png\" alt=\"伪状态\"></p>\n<h1 id=\"Event-事件\"><a href=\"#Event-事件\" class=\"headerlink\" title=\"Event(事件)\"></a>Event(事件)</h1><h2 id=\"事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。\"><a href=\"#事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。\" class=\"headerlink\" title=\"事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。\"></a><strong>事件，也可以说是中断。就好比你在说话的时候，有一个人在你旁边也在跟你说事情，你得停下来先听他说完，这也可以说是那个人说话的时候中断了你说话，在Qt里有专门处理中断的函数，但它还得先判断你的中断是那种类型的，它再来处理中断的事件。</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这里是在ui的模式下添加了label，然后又添加了新文件，最后在ui里把label提升为槽函数而实现的。</span><br><span class=\"line\">// .h</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\">class Mylabel : public Qlabel&#123;</span><br><span class=\"line\">        protected://保护的(重写事件里的虚函数)</span><br><span class=\"line\">        //鼠标按下</span><br><span class=\"line\">        void mousePressEvent(QMouseEvent *ev);</span><br><span class=\"line\">        //鼠标抬起</span><br><span class=\"line\">        void mouseReleaseEvent(QMouseEvent *ev);</span><br><span class=\"line\">        //鼠标移动</span><br><span class=\"line\">        void mouseMoveEvent(QMouseEvent *ev);</span><br><span class=\"line\">        //鼠标在里面</span><br><span class=\"line\">        void enterEvent(QEvent *);</span><br><span class=\"line\">        //鼠标在外面</span><br><span class=\"line\">        void leaveEvent(QEvent *);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// .cpp</span><br><span class=\"line\">#include &quot;Mylabel.h&quot;</span><br><span class=\"line\">#include &lt;MouseEvent&gt;//事件的头文件</span><br><span class=\"line\">#include &lt;QDebug&gt; //打印</span><br><span class=\"line\">Mylabel::Mylabel(QWidget *parent):QLabel(parent)&#123;</span><br><span class=\"line\">        //设置追踪鼠标(设置了鼠标追踪就会在程序里自动追踪鼠标，没有设置的话，你还得在窗口里点一下才能出来数据)</span><br><span class=\"line\">        this-&gt;setMouseTracking(true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mylabel::mousePressEvent(QMouseEvent *ev)&#123;</span><br><span class=\"line\">        int i=ev-&gt;x();//x的坐标</span><br><span class=\"line\">        int j=ev-&gt;y();//y的坐标</span><br><span class=\"line\">QSting str=QString (&quot;&lt;center&gt;&lt;h1&gt;mouse press:(%1,%2)&lt;/h1&gt;&lt;/center&gt;&quot;)</span><br><span class=\"line\">.arg(i).arg(j);</span><br><span class=\"line\">// 语法(参数是字符) (center(字体加粗))</span><br><span class=\"line\">this-&gt;setText(str);//设置</span><br><span class=\"line\">if(ev-&gt;Button()==Qt::LefeButton)&#123;//判断鼠标按钮在左边，右边，中间</span><br><span class=\"line\">        qDebug()&lt;&lt;&quot;left&quot;;</span><br><span class=\"line\">&#125;else if(ev-&gt;Button()==Qt::RightNutton)&#123;</span><br><span class=\"line\">        qDebug()&lt;&lt;&quot;right&quot;;</span><br><span class=\"line\">&#125;else if(ev-&gt;Button()==Qt::MidButton)&#123;</span><br><span class=\"line\">        qDebug()&lt;&lt;&quot;wid&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mylabel::mouseReleaseEvent(QMouseEvent *ev)&#123;</span><br><span class=\"line\">QSting str=QString (&quot;&lt;center&gt;&lt;h1&gt;mouse press:(%1,%2)&lt;/h1&gt;&lt;/center&gt;&quot;)</span><br><span class=\"line\">.arg(ev-&gt;x()).arg(ev-&gt;y());</span><br><span class=\"line\">this-&gt;setText(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mylabel::mouseMoveEvent(QMouseEvent *ev)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">QSting str=QString (&quot;&lt;center&gt;&lt;h1&gt;mouse move:(%1,%2)&lt;/h1&gt;&lt;/center&gt;&quot;)</span><br><span class=\"line\">.arg(ev-&gt;x()).arg(ev-&gt;y());</span><br><span class=\"line\">this-&gt;setText(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mylabel::enterEvent(QEvent *e)&#123;</span><br><span class=\"line\">        QString str=QString(&quot;&lt;center&gt;&lt;h1&gt;Event:enter&lt;/h1&gt;&lt;/center&gt;&quot;);</span><br><span class=\"line\">        this-&gt;setText(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Mtlabel::lavceEvent(QEvent *e)&#123;</span><br><span class=\"line\">        QString str=QString(&quot;&lt;center&gt;&lt;h1&gt;Event:leave&lt;/h1&gt;&lt;.center&gt;&quot;);</span><br><span class=\"line\">        this-&gt;setText(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/08/05/qt/qtEvent.png\" alt=\"运行结果\"></p>\n<p><img src=\"/2019/08/05/qt/qtEvent1.png\" alt=\"运行结果\"></p>\n<p><img src=\"/2019/08/05/qt/qtEvent2.png\" alt=\"运行结果\"></p>\n<p><img src=\"/2019/08/05/qt/qtEvent3.png\" alt=\"运行结果\"></p>\n<blockquote>\n<p>时间的处理与忽略</p>\n<ul>\n<li>继承于widget的前提下，简写。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// .h</span><br><span class=\"line\">void closeEvent (QEvent *event);//关闭事件</span><br><span class=\"line\">// .cpp</span><br><span class=\"line\">#include &quot;Widget.h&quot;</span><br><span class=\"line\">#include &lt;QMessageBox&gt;//对话框头文件</span><br><span class=\"line\">void Widget::closeEvent(QEvent *event)&#123;</span><br><span class=\"line\">        int test=QMessageBox::question(this , &quot;question&quot;,&quot;sure?&quot;,</span><br><span class=\"line\">        QMessageBox::Yes |</span><br><span class=\"line\">        QMessageBox::No);</span><br><span class=\"line\">        if(test==QMessageBox::Yes)&#123;</span><br><span class=\"line\">                event-&gt;accept();//处理</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">                event-&gt;ignore();//忽略</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/08/05/qt/qtEvent4.png\" alt=\"运行结果\"></p>\n<h1 id=\"绘画\"><a href=\"#绘画\" class=\"headerlink\" title=\"绘画\"></a>绘画</h1><p><img src=\"/2019/08/05/qt/qtEventpainter1.png\" alt=\"运行的程序\"><br><img src=\"/2019/08/05/qt/qtEventpainter2.png\" alt=\"运行的结果\"></p>\n<h1 id=\"绘图设备\"><a href=\"#绘图设备\" class=\"headerlink\" title=\"绘图设备\"></a>绘图设备</h1><ul>\n<li>Pixmap(在平台上不能对图片进行修改)</li>\n<li>Image(和平台无关平台上，可以对图片进行修改)</li>\n<li>picture(保存绘图的状态，以二进制的文件进行保存)</li>\n</ul>\n<p><img src=\"/2019/08/05/qt/qt_pixmap.png\" alt=\"pixmap\"><br><img src=\"/2019/08/05/qt/qt_image.png\" alt=\"image\"><br><img src=\"/2019/08/05/qt/qt_picture1.png\" alt=\"picture\"><br><img src=\"/2019/08/05/qt/qt_picture.png\" alt=\"picture\"><br><img src=\"/2019/08/05/qt/qt_picture2.png\" alt=\"[icture]\"></p>\n<h2 id=\"其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。\"><a href=\"#其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。\" class=\"headerlink\" title=\"其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。\"></a><strong>其实在写这些代码的时候遇到的问题挺多的，明明讲的和我写的是一样的，但我文件管理器就是没有图片，弄得我挺自闭的，换一种方式定义画家就解决了。</strong></h2><blockquote>\n<p>QPixmap&amp;&amp;QImage</p>\n</blockquote>\n<p><img src=\"/2019/08/05/qt/qtzhuan.png\" alt></p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2019/08/05/qt/qt_zhuan1.png\" alt></h2><h1 id=\"不规则的窗口\"><a href=\"#不规则的窗口\" class=\"headerlink\" title=\"不规则的窗口\"></a>不规则的窗口</h1><p><img src=\"/2019/08/05/qt/qt_paint.png\" alt=\"程序\"><br><img src=\"/2019/08/05/qt/qt_paint1.png\" alt=\"结果\"></p>\n<h2 id=\"绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备-this-。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画-QPixmap-保存的是图片-QImage-保存的是图片-Qpicture-保存的是二进制文件-，save-保存-load-加载-，Rect-矩形-。\"><a href=\"#绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备-this-。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画-QPixmap-保存的是图片-QImage-保存的是图片-Qpicture-保存的是二进制文件-，save-保存-load-加载-，Rect-矩形-。\" class=\"headerlink\" title=\"绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备(this)。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画(QPixmap(保存的是图片),QImage(保存的是图片),Qpicture(保存的是二进制文件))，save(保存),load(加载)，Rect(矩形)。\"></a><strong>绘画。我们一般都是在窗口上。而关于怎么样进行绘画，我们是选择重写绘画事件来完成绘画的，一般来说都是先定义画家，然后再选择绘画的设备(this)。我们也不一定就在窗口上绘画，在软件里还有三种设备可以让我们在上面绘画(QPixmap(保存的是图片),QImage(保存的是图片),Qpicture(保存的是二进制文件))，save(保存),load(加载)，Rect(矩形)。</strong></h2><h1 id=\"File\"><a href=\"#File\" class=\"headerlink\" title=\"File\"></a>File</h1><p><strong>不管在那个语言上，文件的操作都有一定的重要性，所以就把它学好。</strong></p>\n<ul>\n<li>普通的形式写读文件()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用到的头文件</span><br><span class=\"line\">#include &lt;QFile&gt;</span><br><span class=\"line\">#include &lt;QFileDialg&gt;</span><br><span class=\"line\">#include &lt;QFileInfo&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/08/05/qt/qtFILE.png\" alt><br><img src=\"/2019/08/05/qt/qtreadfile.png\" alt><br><img src=\"/2019/08/05/qt/qtwritefile.png\" alt></p>\n<ul>\n<li>是以二进制的形式保存文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用到的头文件</span><br><span class=\"line\">#include &lt;QFile&gt;</span><br><span class=\"line\">#include &lt;QDatestram&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/2019/08/05/qt/qt_Stream.png\" alt></p>\n<h1 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h1><h2 id=\"记得在项目文件里加-network-这是针对于在类对象里没有提示。还有就是连则表达式-CONFIG-c-11\"><a href=\"#记得在项目文件里加-network-这是针对于在类对象里没有提示。还有就是连则表达式-CONFIG-c-11\" class=\"headerlink\" title=\"记得在项目文件里加(network),这是针对于在类对象里没有提示。还有就是连则表达式(CONFIG+=c++11)\"></a><strong>记得在项目文件里加(network),这是针对于在类对象里没有提示。还有就是连则表达式(CONFIG+=c++11)</strong></h2><p><img src=\"/2019/08/05/qt/qt_server.png\" alt></p>\n<h2 id=\"写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。\"><a href=\"#写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。\" class=\"headerlink\" title=\"写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。\"></a><strong>写代码最重要的是逻辑要清晰，时刻的知道自己在写什么，所以，软件怎样运行我们是一定要搞清楚的。</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用到的头文件</span><br><span class=\"line\">#include &lt;QTcpServer&gt;</span><br><span class=\"line\">#include &lt;QTcpsocket&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/08/05/qt/qt_tcpserven.png\" alt=\"serven\"><br><img src=\"/2019/08/05/qt/qt_tcpserven1.png\" alt=\"server\"><br><img src=\"/2019/08/05/qt/qt_tcpserven2.png\" alt=\"客户端\"><br><strong>其实在上面的刚开始的第一张图就很清晰的讲到了tcp的连接过程，只要我们真的理解了就能看的明白。在这里也没什么好解释的，有很多的函数都是在函数里订好了的，只要我们搞清楚什么时候调用什么函数就行了。</strong></p>\n<blockquote>\n<p>UDP</p>\n<ul>\n<li>它是面向无连接的通信，所以在这里就只需要通信的套接字(socket)。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用到的头文件</span><br><span class=\"line\">#include &lt;QUdpSocket&gt; //.h(不要忘记在.h文件里声明socket套接字)</span><br><span class=\"line\">#include &lt;QHostAddress&gt;// .cpp</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"/2019/08/05/qt/qt_udp1.png\" alt=\"程序\"><br><img src=\"/2019/08/05/qt/qt_udp2.png\" alt=\"程序\"><br><img src=\"/2019/08/05/qt/qt_udp.png\" alt=\"运行结果\"></p>\n<h1 id=\"tcpfile\"><a href=\"#tcpfile\" class=\"headerlink\" title=\"tcpfile\"></a>tcpfile</h1><p><img src=\"/2019/08/05/qt/qt_tcpfile.png\" alt=\"流程图\"></p>\n<h2 id=\"值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。\"><a href=\"#值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。\" class=\"headerlink\" title=\"值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。\"></a><strong>值得注意的是，tcp在发组的时候，头文件的信息和数据是一起跟着发过去的，所以我们在这里要用定时器来缓一下时间，让它先发头文件，后发数据。这样一来我们的头文件信息和数据就不会搞混，还有就是tcp发包是不会丢失的。</strong></h2><h1 id=\"QThread\"><a href=\"#QThread\" class=\"headerlink\" title=\"QThread\"></a>QThread</h1><h2 id=\"connect的第五个参数的意义-默认，队列，直接-默认的时候：分为多线程-默认使用队列-和单线程-默认使用直接-。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。\"><a href=\"#connect的第五个参数的意义-默认，队列，直接-默认的时候：分为多线程-默认使用队列-和单线程-默认使用直接-。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。\" class=\"headerlink\" title=\"connect的第五个参数的意义(默认，队列，直接)默认的时候：分为多线程(默认使用队列)和单线程(默认使用直接)。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。 \"></a><strong>connect的第五个参数的意义(默认，队列，直接)默认的时候：分为多线程(默认使用队列)和单线程(默认使用直接)。队列：槽函数所在的线程和接收者一样。直接：槽函数所在的线程和发送者一样。</strong> </h2>"},{"title":"Java","date":"2019-09-19T02:37:00.000Z","_content":"\n![终端运行的结果](Java/java0.png) \n\nWrite Once,Run Everywhere\n <!--more-->\n\n **达到对面向对象编程思想更加深入的理解，是对面向对象的各种特性及其实现细节更加熟练的掌握。** \n\n ---\n\n *一步一个脚印的连好java的基本功。对于我来说是最好不过的，掌握java的基本语法。(类与对象，构造方法，引用传递，内部类，异常，包，java常用类库，javaIO，java类集)* \n\n1. 走技术之路(在学习java的同时，把基础的知识打好一定的基础)\n2. 定位成为技术类管理成员(掌握基础的java知识，还要有几年的工作经验)\n3. java软件开发发展前景好，移植性也很强。\n- [ ] JDK(java开发工具包)\n\n*是编程语言和javaAPI类库和java虚拟机(是完成移植性的重要机制)来组成的* \n\n- [ ] JRE(java运行时环境)\n*是javaAPI子集和java虚拟机组成* \n\n**前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。** \n---\n\n**java系统可分为：javaEE(标准版)，javaSE(企业版)，javaME(微型版)，javaCARD(智能卡版)** \n---\n\n```\n//有必要说明一下，接下来的是在linux系统下使用终端来让我电脑上的文件进行运行\n\npublic class hello{//public(公有访问类型),class(类的标识),hello(类名)\n    public static void main (String arg[]){//是main函数的基本格式,也表明main函数是静态方法\n    System.out.println(\"hello,world!\");//打印字符串\"hello,world!\"\n    }\n}\n```\n\n![终端运行的结果](Java/java0.png) \n\n---\n\n**这里要注意一下的就是文件的后缀是.java,其次是以javac 来作为第一次的关键字来操作文件，接着就会生成一个后缀为.class的文件，然后就是运行你写的文件，记住后面没有任何的后缀。** \n\n* **java是面向对象的过程，也就是说在java中只有方法而没有所谓的函数。** \n\n```\npublic class Test{\n    public static void main(String args[]){\n    scanner s=new scanner(System.in);//为了可以让用户输入，在这里使用了scanner类,因为它附属与System.in\n    System.out.println(\"请输入你的性别\");\n    String set=s.nextLint();//以字符串的形式输入\n    System.out.println(\"请输入你的姓名\");\n    String name =s.nextLint();\n    switch(set){\n    case \"男\":\n    System.out.println(name+\"男士\");\n    break;\n    case \"女\":\n    System.out.println(name+\"女士\");\n    break;\n    default :\n    System.out.println(\"输入有误\");\n    break;\n    }\n    s.close();//关闭类\n    InputStreamReader input=new InputStreamReader(System.in);//定义在键盘输入\n    BufferedReader Buff=new BufferedReader(input);//以缓冲流的形式来接受input\n    //用try和catch机制来处理异常\n    try{\n    System.out.println(\"请输入字符：\");\n    String s=Buff.readLine();\n    System.out.println(\"字符：\"+s);\n    }catch (Exception e){\n    System.out.println(\"异常\");\n    }\n}\n```\n\n\n![运行结果](Java/java2.png)\n\n![输入的方式](Java/java1.png)\n\n*在这里只是简单的让用户输入了两次都是以字符串的方式来输入的，当然你也可以让用户输入你想让用户输入的数据类型(eg:int ,double)，上面也有参照的照片。* \n\n* **合法的标识符** \n- [ ] 不能存在关键字\n- [ ] 首字母不能是数字\n- [ ] 不能存在运算符\n- [ ] 标识符是区别大小写的\n- [ ] 标识符的命令规则是强制性的\n\n`我们都知道数据的类型有int,short,float,double,byte(字节)。最常见的就是int(整形的数据类型)。在java中我们可以通过程序来输出各个数据类型的范围是多少，最大值和最小值，和数据类型\n`\n\n```\npublic class Test{\n    public static void main (String args[]){\n    int a=Integer.Size;\n    System.out.println(\"int的范围:\"+a);\n    int b=Integer.MAX_VALUE;\n    System.out.println(\"int的最大值:\"+b);\n    int c=Integer.MIN_VALUE\n    System.out.println(\"int的最小值:\"+c);\n    Class <Integer> d=Integer.TYPE;\n    System.out.println(\"数据类型:\"+d);\n    }\n}\n```\n\n```\n运行结果：\nint的范围:32\nint的最大值:2147483647\nint的最小值:-2147483648\n数据类型:int\n```\n\n---\n\n```\npublic class Test{\n            static int i=10;\n    public static void main(String args[]){\n            int a=1;\n            int b=2;\n            {\n            int b=3;//main方法的变量名是不可以重复的，一个变量只能使用一个名，在这里就是重复使用了变量b，所以程序会报错。\n            System.out.println(\"b=\"+b);\n            System.out.println(\"a=\"+a);\n            System.out.println(\"i=\"+i);\n            }\n            System.out.println(\"b=\"+b);\n            System.out.println(\"a=\"+a);\n            System.out.println(\"i=\"+i);\n\n    }\n}\n```\n\n```\n上面的程序是运行不过的，这也是java的特别之处，在c++中，变量b是可以用的，但在java中是不可以的。\n```\n\n```\npublic class Test{\n    public static void main (String args[]){\n            char ch = '\\\"';//转义字符\n            System.out.println(ch);\n            System.out.println(\"\\\"hello,world!\"\\\");\n            System.out.println(ch+\"hello,world!\"+ch);\n    }\n}\n```\n\n```\n运行结果\n\"\n\"hello,world!\"\n\"hello,world!\"\n```\n---\n\n`总结可以得知，不管是用变量来存放转义字符，还是直接使用转义字符的方式来输出字符，程序都是可以顺利运行的，当然你也可以不使用变量来存放转义字符，但一个程序里面有太多的转义字符的存在你用变量来存放不是更好使用？这样你也不容易搞混已有的转义字符的使用。` \n\n```\npublic class Test{\n    public static void main(String args[]){\n        System.out.println(2+3+\"k\");\n        System.out.println(6+6+\"aa\"+6+6);\n    }\n}\n```\n\n```\n运行结果\n5k\n12aa66\n```\n---\n\n`上面的2+3是一个表达式，所以这里是5,但后面跟的是字符和+(字符串相加)的符号，所以是5k,下面的也是一样的，唯一不一样的是在+(字符串相加)之后，计算机会自动认为后面的也是+(字符串相加)所以后面的就是12aa66。但如果把上面的双引号换成单引号就是以数字的形式先加后输出的。` \n\n# 数组\n\nimport java.util.Randow;//随机数字的包\n\n```\npublic class Test{\n    public static void main(String args[]){\n                int i=3;//这是在堆内存的分配的内存(也可以说是在编译是分配的),读取速度快，但数据的活动范围小(缺少灵活性)\n                int y=new Integer(1);//是在栈内存分配的内存(也可以说是运行时分配的内存),读取速度慢，但数据灵活性高。\n                System.out.println((int)(Math.randow()*10));//生成随机数字，0～10\n                Randow rand=new Randow();\n                int i=rand.nextInt(10);//随机生成0～10的数字\n                System.out.println(i);\n    }\n}\n```\n\nimport java.util.Randow;//导入随机数字的包\n```\npublic class test{\n    public static void main(String args[]){\n            Randow rand=new Randow();//声明随机数字的对象\n            int []numb=new int [rand.nextInt(10)];//rand.nextInt(10)这句话的意思是随机生成一个0～10的数字作为数组的长度\n            for(int i=0;i<numb.length;i++){//为数组赋值。从0～100来选择每次的赋值的数值\n                numb[i]=rand.nextInt(100);\n            }\n            for(int a : numb){//打印数组里的元素\n            System.out.println(a);\n            }\n    }\n}\n```\n\n**在c++中的指针，在java是叫做引用数据类型，相当与c++中的地址指针** \n```\npublic class test{\n    public static void main(String args[]){\n    Randow rand=new Randow();//声明随机数字的对象\n    int []a=new int[rand.nextInt(10)];//定义数组长度\n    int []b=a;//把数组a赋值给数组b\n    for(int i=0;i<a.length;i++){//为数组a赋值\n            a[i]=rand.nextInt(100);\n            System.out.println(a[i]);\n            System.out.println(b[i]);\n    }\n    }\n}\n```\n\n`上面程序的结果每次都是不要的，但值得注意的是输出的结果，肯定不会让你们失望的，因为数组b里面的元素是和数组a的元素是一样的。其实，上面最重要的一点就是数组b=数组a，它的等于是连着后面的a数组的赋值。` \n\n---\n\n```\npublic class test{\n    public static void main(String args[]){\n            Randow rand=new Randow();\n            int [][]numb=new int[3][1];//声明数组numb和给数组长度\n            for(int i=0;i<numb.length;i++){//给数组赋值并输出数组里的元素\n                for(int j=0;j<numb[i].length;j++){\n                        numb[i][j]=rand.nextInt(10);\n                        System.out.println(numb[i][j]);\n                }\n            }\n    }\n}\n```\n\n`一样的，上面的数组每运行一次程序的结果都是不一样的。` \n\n---\n```\npublic class test{\n    public static void main(String args){\n            int []numb=new int[]{10,23,41,6,11};//声明一个数组，并赋初值\n            int a=Randow rand=new Randow(3)+1;//生成随机数字，范围是1～4\n            for(int i=0;i<a;i++){//把随机数字的大小作为条件,并从一开始交换位置\n                int temp=numb[i];\n                numb[i]=numb[i+1];\n                numb[i+1]=temp;\n            }\n            for(int b:numb){//输出数组里的元素\n            System.out.println(b);,你在这个时候使用基本数据类型是不能放进去的，因为容器里面都是放            }\n\n    }\n}\n```\n\n`上面程序实现的是乱序，就是每次输出的结果都是不一样的。` \n\n---\n\n# 对象\n**类描述了对象的属性和对象的方法，类是对象的模板，更可以说，对象是类的实例，是一个实实在在存在的个体。所以说，面向对象的程序重要的是类的设计而不是对象的设计。** \n`类的声明格式:` \n- [ ] [标识符] class 类的名称\n{\n        //类的属性\n        //类的方法\n}\n`类的标识符:` \n- [ ] 默认的(default):这个类只能被这个类的对象和同一个包中的其它的类访问，即使是其它包里的这个类的子类都不能被访问，它只认同一包里的类。\n\n- [ ] 私有(private):如果一个方法或者属性被定义为私有的，那么只能在本类里访问它。\n\n- [ ] 公有(public):如果一个方法或属性被定义为公有的，那么它不仅能跨类的对象所调用，还能在其它包中被访问。\n\n- [ ] 保护(protected):如果一个方法或属性被定义为保护的，那么它能被本类的方法所访问，也能被子类所访问，即使子类在其它包里。\n\n![java访问机制](Java/java3.png) \n\n```\npublic class Test{\n    public static void main (String args[]){\n            System.out.println(\"------\"创建对象\"-------\");\n            new Apple();//匿名对象\n    }\n}\nclass Apple{\n        static String a=\"string-a\";\n        Static String b;\n        String c=\"string-c\";\n        Strint d;\n        Static{//static 属于静态代码块，最先运行的是这段代码块，而不是类的构造函数先\n                printstatic(\"before static\");\n                b=\"string-b\";\n                printstatic(\"after static\");\n        }\n        static void printstatic(String name){//这里要加静态的关键字，因为调用是静态来的所以这里也要有静态的关键字来表明这里是静态，不然是会报错的。\n                System.out.println(\"------\"+name+\"-------\");\n                System.out.println(\"a=\"+a);\n                System.out.println(\"b=\"+b);\n        }\n        Apple(){\n            print(\"before class\");\n            d=\"string-d\";\n            print(\"after class\");\n        }\n        void print(){\n                System.out.println(\"------\"+name+\"-------\");\n                System.out.println(\"a=\"+a);\n                System.out.println(\"b=\"+b);\n                System.out.println(\"c=\"+c);\n                System.out.println(\"d=\"+d);\n\n        }\n}\n```\n![运行结果](Java/java4.png) \n\n```\n上面的对象是经过匿名对象来实例化的，也就是没有给new的对象一个堆内存，一旦这句语句实现完，计算机会自动回收这个内存，将不再存在程序里，这也是java的垃圾回收机制(BC)，这也是为我们考虑的，不知道你有没有发现，上面的几个程序我都是用new来给类分配的对象，但我不但没有在类中写析构函数，也没有在main函数里delete对象的实例化。因为这一切都是java的BC机制帮我们做了。\n\n```\npublic class Test{\n\n    public static void main(String args[]){\n            String name=new String (\"java\");\n            String _name=new String (\"java\");\n            String hua=_name;\n            if(name==_name){\n            System.out.println(\"地址相同\");\n            }else{\n            System.out.println(\"地址不同\");\n            }\n            if(name.equals(_name)){\n            System.out.println(\"内容相同\");\n            }else{\n            System.out.println(\"内容不同\");\n            }\n}\n运行结果:\n地址不同\n内容相同\n```\n\n上面的程序分别实现了字符串地址(==)和字符串内容(equals方法)的比较，第一个变量和第二个变量的是经过new来分配的栈内存的地址，所以输出的是地址不相同,而最后一个的是进行的内容比较，因为初始化的原因，这里也是输出的内容相同。\n\n\n构造方法的注意事项\n- [ ] 构造方法的名称与类的名称是一样的\n- [ ] 构造方法也是和普通方法一样的，可以被重载，但构造方法的调用是通过在创建类的对象的时候自动调用的，这是与普通方法的调用是不一样的\n- [ ] 构造方法是没有返回值的\n- [ ] 构造方法是不能被static和final修饰的\n- [ ] 构造方法是不能被继承的，如果子类要使用父类的构造方法只能使用关键字(super)来进行调用\n\n```\npublic Test{\n\n    private String name;\n    Test(){\n    System.out.println(\"类的无参构造方法的调用\");\n    }\n    Test(String _name){\n        this->name=_name;\n        System.out.println(\"类的有参构造方法的调用\");\n    }\n    public static void main(String args[]){\n            new Test();//这是匿名调用类的构造方法\n            Test test=new Test();//这和上面是等价的\n            Test t1=new Test(\"小明\");\n    }\n}\n\n上面的程序做的只是简单的演示类的构造方法的重载。\n\n```\npublic Test{\n    public static void main(String args[]){\n    Apple apple;\n    apple=Apple.V();\n    System.out.println(\"姓名:\"+apple.name);\n    }\n}\nclass Apple{\n        String name;\n        private Apple (){\n        name=\"hello\";\n        }\n        private static final Apple APPLE=new Apple();\n        public static V(){\n        return APPLE;\n        }\n}\n```\n\n上面的程序的重要性是:当你不想一个类被频繁调用的是时候，可以通过对类的构造方法的私有化来实现\n\n\n\n\n# 代码块\n- [ ] 普通代码块(就是普通的放在Main方法里面的代码块)\n- [ ] 构造代码块(放在类里面，比构造方法更先一步执行的代码块)\n- [ ] 静态代码块(比构造代码块更快一步，如果和Main方法是放在同一个类的话，那它比Main方法更快一步执行)\n- [ ] 同步代码块\n\n> 普通代码块\n\n```\npublic class Test{\n        public static void main(String args[]){\n        {int x=10;//普通代码块\n        System.out.println(\"x\");\n        }//如果不要这个代码块，程序将会报错，因为在一个方法里，不能有同名的变量名\n        int x=100;\n        System.out.println(\"x\");\n}\n}\n```\n\n```\n运行结果为:\n10\n100\n```\n\n>> 构造代码块\n\n```\npublic class Test{\n    public static void main(String args[]){\n           Peron p=new peron(); \n           Peron p1=new Peron(\"笑话\");\n    }\n}\nclass Peron{\n    private int x;\n    String name;\n    {\n    System.out.println(\"构造代码块的调用\");//这是构造代码块\n    x=10;\n    }\n    Peron(){\n        System.out.println(\"类的无参构造方法的调用\\t\"+x);\n    }\n    Peron(String _name){\n    this->name=_name;\n    System.out.println(\"类的有参构造方法的调用\\t\"+x);\n    }\n}\n\n```\n```\n程序的运行结果为:\n    构造代码块的调用\n    类的无参构造方法的调用  10\n    构造代码块的调用\n    类的有参构造方法的调用  10\n```\n\n上面类中是有一块属于构造代码块，而它的速度比构造方法的调用都还快，以前我们只知道对于类来说，构造方法是第一个调用的，因为在我们声明类的对象的时候就是通过类的构造方法来实现的，但现在不一样的是，你只要在类中加个中括号({}),里面的代码实现比类的构造方法都还要快被实现，这使得我们的代码更简化一步。比如，就像上面一样，给一个成员变量复制，而不是通过它的构造方法来实现，你只需要定义一个变量，然后再加个({}),就能实现对成员变量的复制，速度还比类的构造方法快一布。\n\n**由此我们可以知道，类的代码块中的初始化是一个类的所有构造方法都共有的“交集”部分，具有个性化的初始化还是要放在各自的构造方法里** \n\n\n>>> 静态代码块\n\n```\npublic class Test{\n    static {\n    System.out.println(\"静态方法的调用\");\n    }\n    {\n    System.out.println(\"构造代码块的调用\");\n    }\n    Test(){\n    System.out.println(\"构造方法的调用\");\n    }\n    public static void main(String args[]){\n            System.out.println(\"创建第1个对象\");\n            new Test();\n            System.out.println(\"创建第1个对象\");\n            new Test();\n            System.out.println(\"创建第1个对象\");\n            new Test();\n    }\n}\n\n```\n```\n程序的运行结果为:\n    静态代码块的调用\n    创建第1个对象\n    构造代码块的调用\n    构造方法的调用\n    创建第2个对象\n    构造代码块的调用\n    构造方法的调用\n    创建第3个对象\n    构造代码块的调用\n    构造方法的调用\n\n```\n\n\n**从上面的案例可以看出来，在执行时机上，静态代码块是在类加载的时候就会执行的，因为早于类的构造代码块和类的构造方法。当一个静态代码块和Main方法在同一个类中，Main方法的调用也是在静态代码块的后面的。静态代码块的执行级别是最高的。**    \n\n\n\n```\npublic class Test{\n    public static int [] show(int []numb){\n        numb[0]=10;\n        numb[1]=12;\n        numb[2]=13;\n        return numb;\n    }\n    public static void show1(int []numb){\n        for(int i:numb){\n        System.out.print(i+\"\\t\");\n        }\n    }\n        public static void main(String args[]){\n            int [] numb =new int{1,2,3,4,5};\n            for(int i:numb){\n            System.out.print(i+\"\\t\");\n            }\n            System.out.println();\n            System.out.println(\"--------------\");\n            show(numb);\n            Show1(numb);\n\n    }\n}\n```\n\n```\n    程序的运行结果为:\n    1 2 3 4 5 \n    10 11 12 4 5\n```\n\n`上面的程序只是简单的利用java的特性用新的方式来打印数组，只需要一个变量来操作数组对象就行了，比我们之前在c++中的方式简便多了，也是代码的量也减少了，这无疑是一件好事，还利用了引用数据类型来实现对数组的操作，更加利用了静态方法来进行对数组里的元素更改。` \n\n\n```\nimport java.util.*//导入sort包\npublic class Test{\n    public static void main(String args[]){\n    int []numb={10,2,46,33,5};\n    Arrays.sort(numb);//进行数组的排序\n    System.out.println(\"排序后:\");\n    for(int i:numb){\n    System.out.print(i+\"\\t\");\n    }\n        \n    }\n}\n\n```  \n\n\n```\n程序的运行结果为:\n排序后:\n2 5 10 33 46\n```\n\n# 枚举(enum)\n`enum A{红色，黄色，白色}枚举是作为类来被调用的，在定义的同时是连着对象的构造方法一起被调用的` \n```\nenum Cloro{红色，黄色，白色}//是枚举的关键字,定义了一个枚举并初始化了\npublic class Test{\n    public static void main(String args[]){\n            //java中的枚举其实是一个类来的，在这个类里面还有很多不一样的方法，其作用都是不一样的。\n            Cloro []cloro=Cloro.values();//Cloro.values()是类的静态方法来的，但是以字符串的形式来的，所以在前面要定义一个同类型的数组来接收,方法是自动生成的\n            for(Cloro i:cloro){\n            System.out.println(i);\n            }\n            Cloro c=Cloro.valueof(Cloro.class,\"白色\");//以指定的颜色来赋给对象,这里的参数有点不一样的就是，参数是类的类型,方法是自动生成的\n            System.out.println(c);\n            \n    }\n}\n```\n\n```\n运行结果:\n红色\n黄色\n白色\n白色\n```\n\n枚举的注意事项\n- [ ] 如果把枚举的标识符定义为public的话要放在独立的文件里面而不能和main方法放在同一个文件，如果标识符是默认的话就可以放在同一个文件里\n- [ ] 使用enum来定义枚举的时候，默认会继承于java.lang.Enum类。默认会用final来修饰，因此无法派生子类。\n- [ ] 使用enum来定义的时候，初始化也要和定义一起,如果没有把赋值放在同一行，而这个enum将无法被实例法。\n- [ ] 所以使用enum来定义枚举的时候都会默认生成values方法，该方法可以方便遍历所有枚举值，而在枚举中还是有其它的自动生成的方法来给我们使用。\n\n**enum(枚举)用关键字定义的时候相当于定义了一个类，而这个类继承于Enum类。而在Enum类中的所有方法都是保护类型的，因此这些方法都可以在声明了enum对象中被使用。** \n\n```\nenum A{红色，紫色，白色}\npublic class Test{\n    public static void main(String args[]){\n            A []a=A.valuse();//把枚举中的元素都放在对应类型的数组中\n            for(A i:a){\n            System.out.println(i.name+i.ordinal());输出的是数组中的元素和数组的下标\n            }\n    }\n}\n```\n\n```\n运行结果:\n红色0\n紫色1\n白色3\n```\n\n`在枚举中的下表要是没有给定提定的数值，计算机就会自动给它一个下标，而下标的值是以数组的形式来赋值的。` \n\n\n`EnumMap是Map接口的子类，也就是说Enummap是继承于类Map的` \n\n```\nimport java.util.Map;//导包\nimport java.util.EnumMap;//导包\nenum Color{红色，黄色，绿色}\npublic class Test{\n    public static void main(String args[]){\n        EnumMap<Color,String>emap=new EnumMap<Color,String>(Color.class);//映射<><KeyType,nameType>,更重要的是EnumMap的构造方法的参数不能为空，需要指定一个枚举类\n        emap.put(Color.红色,\"RED\");//把映射的对象和值都写进去\n        emap.put(Color.黄色,\"YELLOW\");\n        emap.put(Color.绿色,\"BLUE\");\n        for(Map.Entry<Color,String>me:emap.entrySet()){//把映射的键和值都打印出来,其中的两个方法是Map中的静态方法，EnumMap作为Map的子类所以能调用其中的方法。\n        System.out.println(me.getKey()+me.getValue());\n        }\n    }\n}\n```\n\n```\n运行结果:\n红色RED\n黄色YELLOW\n绿色BLUE\n```\n\n上面的打印用的是新的打印方法，而EnumMap的类型是Map来的，所以它要Map.来点出它的方法来进行打印,Key是不允许重复的，而它的值却允许重复，EnumSet是一个集合来的\n\n```\nimport java.util.EnumSet;//导包\nimport java.util.Iterator;//导包\nenum Color{红色，绿色，紫色}\npublic class Test{\n    public static void main(String args[]){\n        EnumSet<Color> set=EnumSet.allof(Color.class);//声明集合<EnumTepy>并把对应类型的枚举类放在集合中,allof是集合EnumSet中的静态方法，用来把参数中的枚举类放在集合中作为集合的元素\n        Iterator <Color>iter=set.iterator();//声明迭代器并把集合放在迭代器中\n        while(iter.hasNext()){//参数是确认迭代器中的元素是否为空,为空的时候返回false\n        System.out.println(iter.Next());//打印迭代器中的元素\n        }\n        EnumSet <Color>aset=EnumSet.noneof(Color.class);//表示作为空的集合\n    }\n    Iterator iterator=aset.iterator();\n    while(iterator.hasNext()){\n    System.out.println(iterator.Next());//这里是打印不出来的，所以下面的结果为空\n    }\n}\n```\n\n\n```\n运行结果:\n红色\n绿色\n紫色\n```\n\n\n```\nenum Color{\n    RED(\"红色\",3),BLUE(\"蓝色\",4),YELLOW(\"黄色\",5);//定义枚举并指定颜色和下标，是以私有构造方法来显示调用枚举类的属性，(也就是说成员)\n    private String Name;//元素的名字\n    private int Indext;//元素的下标\n    private Color(String name,int indexc){//枚举类的构造方法是私有化的,所有的枚举对象都必须显示调用此构造方法。\n            this->Name=name;\n            this->Indext=indexc;\n    }\n    public static void setname(int indexc,String name){\n        for(Color c:Color.values()){\n            if(c.Indexc==indexc){\n            c.Name=name;\n            }\n        }\n    }\n    public static void setindexc(String name,int indexc){\n        for(Color c:Color.values()){\n            if(c.Name==name){\n            c.Indexc=indexc;\n            }\n        }\n    }\n    public String getname(String name){\n    return name;\n    }\n    public int getindexc(int intexc){\n    return intexc;\n    }\n\n\n}\npublic class Test{\n    public static void main(String args[]){\n        System.out.println(Color.RED.getname());//RED是枚举类型的Color的枚举实例。这些枚举实例是公有的静态对象(进一步说，它们可以视为枚举类的属性成员)\n        System.out.println(Color.RED.getindexc());\n        System.out.println(Color.BLUE.getname());\n        System.out.println(Color.BLUE.getindexc());\n        System.out.println(Color.YELLOW.getname());\n        System.out.println(Color.YELLOW.getindexc());\n        System.out.println(\"自定义元素\");\n        Color.setname(3,\"白色\");//通过属性下标来改变属性的名字\n        System.out.println(Color.RED.getname());\n        System.out.println(Color.RED.getindexc());\n        Color.setindexc(\"黄色\",7);//通过属性的名字来改变属性的下标\n        System.out.println(Color.YELLOW.getname());\n        System.out.println(Color.YELLOW.getindexc());\n    }\n}\n```\n\n```\n运行结果:\n红色\n3\n蓝色\n4\n黄色\n5\n白色\n3\n黄色\n7\n\n```\n\n在上面的程序中都是通过私有的构造方法来显示调用成员属性的，在上面属性其实是RED,BLUE,YELLOW,只不过我在这里都没对它操作，在这里比较容易混淆的是，根本不明白谁才是枚举的成员属性，你也可以通过上面的Values()(是枚举类自动生成的用来遍历枚举属性的方法),其实在上面我也用到了这个方法来对成员属性的名字和下标来进行改变它们对应的值。在最开始的时候定义的枚举的属性其实是在调用私有构造方法来实现实例化。只要把这个搞懂了，其实那些改变成员属性的方法都是很简单理解的。\n\n\n```\nenum Color{\n    红色\n    {\n        public String show(){\n            return \"RED\";\n        }\n    },\n    蓝色\n    {\n        public String show(){\n            return \"BLUE\";\n        }\n    },\n    黄色\n    {\n        public String show(){\n            return \"YELLOW\";\n        }\n    };\n    public abstract String show();//把上面的show方法定义为抽象方法(abstract)抽象关键字\n\n}\npublic class Test{\n    public static void main(String args[]){\n        \n        for(Color c:Color.values){\n        System.out.println(c.ordinal+\"\\t\"+c.name()+\"----\"+c.show());\n        }\n    }\n}\n```\n\n```\n运行结果:\n0  红色----RED\n1  蓝色----BLUE\n2  黄色----YELLOW\n```\n\n抽象方法关键字(abstract)，修饰没有主体的方法，在这里需要在枚举对象中一一单独实现，否则报\n\n\n```\nenum Weekday {Sun,Mon,Tue}\npublic class Test{\n    public static void main(String args[]){\n            Weekday w=Weekday.Sun;\n            switch(w){\n                case Mon:\n                System.out.println(Do Monday work);\n                case Sun:\n                System.out.println(Do Sunday work);\n            }\n    }\n}\n```\n\n```\n运行结果:\nDo Sunday work\n```\n\n这里是当你定义的是枚举类中的哪个元素的对象的时候，通过switch来进行选择，你输出的语句是你在switch写的语句。\n\n\n# 类\n|控制范围|private|default|protected|public|\n|----|----|----|----|----|\n|类|只能内部类允许私有，只能在当前类被访问|可以被当前包中的所有类访问|只有在内部类可以被设为保护权限,相同包中的类和其子类可以被访问|可以被所有类访问|\n|属性|只能被当前类访问|可以被相同包中的类访问|可以被当前包中的所有类访问和当前类的子类访问|可以被所有类访问|\n|方法|只能被当前类访问|可以被相同包中的类访问|可以被相同包中的类访问和当前类的子类访问|可以被所有类访问|\n\n\n\n`java中对于类来说有封装，继承，多态。` \n\n`java中类的成员变量的权限有私有，公有，保护，默认，在上面的表格中都给出了对应的权限范围，java类只有允许单继承不允许多继承，但允许多重继承，` \n\n```\nimport java.util.ArrayList;\npublic class Test{\n    public static void main(String args[]){\n    System.out.println(\"集合大小\");\n    Apple a=new Apple();//调用类的构造方法来实现对集合的操作\n    ArrayList <Interger>array=a.getarray();//声明一个集合来对类中的公有方法中的返回值进行赋值给这个集合,很重要的是，在这里传的是引用而不是数据的副本。\n    System.out.println(array.size());//打印集合的大小\n    array.add(8);//对集合的引用进行加值的操作\n    Arrjy <Interger>a1=a.getarray();又重新定义一个集合来对调用的类的公有方法的返回值进行赋值\n    System.out.println(a1.size());//打印集合的大小\n    System.out.println(\"集合元素\");\n    for(Interger i:a1){\n    System.out.println(i);\n    }\n\n    }\n}\nclass Apple{\n        private ArrayList<Interger>array=new ArrayList<Interger>();//声明一个私有集合作为类的成员变量\n        Apple(){//构造方法,对集合进行初始化\n        array.add(1);\n        array.add(1);\n        array.add(1);\n        }\n        ArrayList<Interger>getarray(){//返回集合\n        return array;\n        }\n\n}\n```\n\n```\n运行结果:\n集合大小\n3\n4\n集合元素\n1\n1\n1\n8\n```\n\n**其实在上面的程序中最难懂的是，在main方法里的集合的操作是引用的操作而不是简单的副本操作，在java中，除了基本的数据类型，其它都是引用类型,其中类也是引用类型** \n\n\n关于继承的限制\n- [ ] java中继承允许多继承，但也许多重继承\n- [ ] 从父类继承的私有成员不能被子类直接使用，要通过方法来间接调用\n- [ ] 子类在进行对象实例化的时候，先调用父类的构造方法对父类的成员变量进行赋值，然后在调用子类的构造方法，其作用是一样的。\n\n```\npublic class Test{\n    public static void mai(String args[]){\n        \n    }\n}\nfinal class A{\n    final void show(){\n    System.out.println(\"如果这个方法在不想被子类覆写，可以在方法前面加上这个修饰符来确定不被子类覆写\");\n    }\n\n}\n//class B extends A{}//是错误的,所以注释掉\n```\n\n上面的程序是不行的，因为父类的修饰符是final，它是不能被继承的\n\n```\npublic class Test{\n    public static void main(String args[]){\n        A a=new B();\n        a.show();\n    }\n}\nclass A {\n    A(){\n    System.out.println(\"父类的构造方法\")\n    }\n    void show(){\n        System.out.println(\"走\");\n    }\n}\nclass B extends A{\n    B(){\n    System.out.println(\"子类的构造方法\n    }\n    void show(){\n        System.out.println(\"飞\");\n    }\n}\nclass C extends A{\n    C(){\n        System.out.println(\"子类的构造方法\n}\n    void show(){\n        System.out.println(\"跑\");\n    }\n}\n```\n\n```\n运行结果:\n父类的构造方法\n子类的构造方法\n飞\n```\n\n上面的程序主要是实现多态的重要性，还有就是继承的小细节，继承是先调用父类的构造方法之后再调用子类的构造方法。在刚开始的时候就写过了在上面是先声明一个父类对象来进行对子类的实例化，然后在调用子类中覆写父类成员方法的方法，其实你也完全可以通过子类的对象来对子类进行实例化，在这里主要是实现类的多态。\n\n\n方法重载与覆写的区别\n- [ ] 重载是在本类中实现的，而覆写主要是在子类中重写父类的方法\n- [ ] 重载要求方法的参数个数和参数类型的顺序和参数的类型和方法名字，其中的任意一个不同。而覆写是方法名称和参数个数和类型与父类是一致的就行了\n\n\n`this&&super` \n----\n```\npublic class Test{\n    public static void main(String args[]){\n            B b=new B();\n            b.show();\n    }\n}\nclass A{\n        String name;\n        void show(){\n        this->name=\"java\";\n        }\n}\nclass B extends A{\n    String name;\n    void show(){\n        this->name=\"shanghai\";\n        super.show();\n        System.out.println(name+\"\\t\"+super.name);\n    }\n}\n\n```\n\n```\n运行结果:\nshanghai  java\n\n```\n\n|区别|this|super|\n|----|----|-----|\n|查找范围|先从本类中找到属性或方法，本类找不到再去父类寻找|不查询父类的属性或方法，直接从子类调用父类的指定属性和方法|\n|调用构造|this使用的是本类的构造|super先调用的是父类的构造方法，然后在调用子类的构造方法|\n|特殊|表示当前的对象|可以看作是父类的引用对象|\n|关系|两者的关系是属于二选一的关系，不能被同时调用|\n---\n抽象类\n----\n\n```\npublic class Test{\n        public static void main(String args[]){\n        A a=new B(\"小艾\",11);\n        a.show();\n        A a1=new C(\"笑话\",12);\n        a1.show();\n    }\n}\nabstract class A{\n        public abstract void show();\n}\nclass B extends A{\n        String name;\n        int age;\n        B(String _name,int _age){\n        }\n        public void show(){\n        System.out.println(\"学生\\t\"+name+\"\\t\"+age);\n        }\n}\nclass C extends B{\n    C(String _name,int _age){\n            super(_name,_age);\n    }\n    public show(){\n    System.out.println(\"工人\\t\"+name+\"\\t\"+age);\n    }\n}\n```\n\n```\n运行结果:\n学生  小艾  11\n工人  笑话  12\n```\n\n上面的类A是一个抽象类来的，抽象类是不能被实例化的，顾名思义，抽象类是没有实现的方法的，在上面的父类中只有定义成员方法为抽象方法的的一个定义，没有实现的行为，抽象类的实现一般是在子类中一一实现的，这也得于抽象类的特性，抽象类是不能被实例化的，这样做会报错的，一般的抽象类都是有子类的，子类的重要作用之一是实现父类中的抽象方法，这是很重要的，还有就是，定义在父类的全部抽象方法在子类中都要重写这些抽象方法，不然会报错，记住是全部都要重写。\n\n\n# 接口(interface)\n`接口是java所提供的另外一种重要的技术，是一种特殊的类，它的结构和抽象类很相似。接口里的数据成必须初始化，数据成员均为常量，常见的是全局变量。` \n`为了避免在接口中添加新的方法后要修改所有的实现类，允许定义默认方法` \n\n使用接口的原则\n- [ ] 接口必须有子类，子类依靠(关键字)implements来实现多个接口\n- [ ] 接口的子类必须重写接口中的所有抽象方法\n- [ ] 接口可以利用对象的多态性，利用子类的对象进行实例化\n- [ ] 接口和一般的类是一样的，具有成员变量和成员方法，但数据成员必须进行初始化，而初始化的值是不能被修改的，相当与是常量，方法也必须是抽象的或者是(default)，所以在接口中这两个特性是可以忽略的，因为在接口中不管是成员方法或者是成员变量都是特性都是肯定了的。\n\n\n```\npublic class Test{\n    public static void main(String args[]){\n            \n            B b=new B();\n            b.show();\n            b.print();\n        System.out.println(A.name);\n        //System.out.println(b.name);//不能通过类的实现来访问静态成员\n    }\n}\ninterface A{\n        public static String name=\"hello\";\n        public void show();\n        default void print(){\n        System.out.println(\"你好\");\n        }\n}\nclass B implements A{\n    //name=\"HELLO\";//这个是错误的\n    public void show(){\n        System.out.println(name);\n    }\n}\n\n```\n\n```\n运行结果:\nhello\n你好\nhello\n```\n\n上面的程序只是简单的介绍接口的基本定义的格式，其中有成员变量和成员方法，而其中的成员变量是全局类型的(还必须给初始化值)，成员方法分两种，一种是抽象方法(在子类是实现的方法，在接口只是声明而已)，另外是其它类型的成员方法\n\n\n**在这里在强调一次，接口与抽象类唯一不同的就是子类，对于接口来说可以实现多个接口，但抽象类是不能多继承的** \n\n```\npublic class Test{\n    public static void main(String args[]){\n        C c=new C();\n        c.show();\n    }\n}\ninterface A{\n    default void show(){\n    System.out.println(\"A接口的默认方法\");\n    }\n}\ninterface B{\n    default void show(){\n    System.out.println(\"B接口的默认方法\");\n    }\n}\nclass c implements A , B{}\n```\n\n上面的程序是错误的，因为在接口中的默认方法中如果有同名的方法，你在调用方法的同时，编译器会不知道你要调用的到底是哪一个方法，这就产生了所谓的二义性，一般来说在接口中一定不要有同名的变量,还有就是上面的接口是没有抽象类型的方法，所以在子类中是空的\n\n\n`在前面说过，接口是允许多继承的，接口中对于抽象类和接口的继承是先继承后实现` \n\n\n```\npublic class Test{\n    public static void main(String args[]){\n        F f=new F();\n        A a=f;//声明一个接口对象来指向子类，主要是在调用方法的时候让你清晰的知道在那个接口中调用的是那个方法。你也可以不写，直接用子类的实例化对象来调用\n        B b=f;\n        C c=f;\n        D d=f;\n        a.show();\n        b.prin();\n        c.print();\n        c.xiao();\n        d.printd();\n        d.xi();\n    }\n}\ninterface A{\n        public static String name=\"小新\";\n        public void show();\n}\ninterface B{\n    public void prin();\n}\ninterface  C extends A , B{//接口继承多个接口\n    public void print();\n    default void xiao(){\n    System.out.println(name+\"\\t多接口继承\");\n    }\n}\nabstract class D implements A,B{//抽象类继承多个接口\n    abstract public void printd();\n    void xi(){\n    System.out.println(name+\"\\t抽象类继承\");\n    }\n}\nclass F extends D implements C{\n    public void show(){\n    System.out.println(\"你好\");\n    }\n    public void prin(){\n    System.out.println(\"hello,world\");\n    }\n    public void print(){\n    System.out.println(\"一个接口继承多个接口\"+name);\n    }\n    public void printd(){\n    System.out.println(\"抽象类继承多个接口\");\n    }\n}\n```\n\n```\n\n\n\n运行结果:\n你好\nhello,world\n一个接口继承多个接口\n小新 多接口继承\n抽象类继承多个接口\n小新 抽象类继承\n```\n\n在上面的程序中我们可以知道，对于接口的继承，一个接口可以继承多个接口(extends)来继承，继承的同时不用进行对继承的接口进行实现。抽象类继承多个接口(implements),继承的同时一样不要进行对已继承的接口的方法实现，但子类一定要对继承的接口和抽象类中的方法进行实现,还有就是，不管是多接口继承还是抽象类继承，都是基于继承的特性来实现继承的，都会继承父接口的成员变量。对于接口的成员变量一定要在声明的同时就进行初始化。\n\n\n接口的作用--制定标准\n`接口是标准，所谓的标准，指的是各方共同遵守的一个原则。只有操作标准统一了，所有的参与者才可以按照统一的规则操作` \n\n```\npublic class Test{\n    public static void main(String args[]){\n        Computer c=new Computer();\n        c.show(new B);//拿子类的引用来作为参数调用父接口中的方法\n        c.show(new C);//拿子类的引用来作为参数调用父接口中的方法\n\n    }\n}\ninterface USB{\n        public void work();//这是抽象方法\n}\nclass B implements USB{\n    public void work(){\n        System.out.println(\"USB在工作\");\n    }\n}\nclass C implements USB{\n    public void work(){\n        System.out.println(\"USB在打印机中工作\");\n    }\n}\nclass Computer{\n    public void show(USB usb){//父接口作为方法的参数\n        usb.work();//调用类中的方法\n    }\n}\n```\n\n```\n运行结果:\nUSB在工作\nUSB在打印机中工作\n```\n\n上面展现的是接口作用--制定标准，利用接口USB来制定工作的标准，通过继承来实现接口中的方法，最后通过电脑类中的方法来调用在子类的实现\n\n接口--工厂的设计\n```\npublic class Test{\n    public static void main(String args[]){\n    A a=F.getname(\"apple\");\n        \n    }\n}\ninterface A{\n        public void eat();\n}\nclass apple implements A{\n    public void eat(){\n        System.out.println(\"吃苹果\");\n    }\n}\nclass oright implements A{\n    public void eat(){\n    System.out.println(\"吃橙子\");\n    }\n}\nclass F{\n    public static A getname(String name){\n        if(\"apple\".equals(name)){\n        return new apple();\n        }\n        if(\"oright\".equals(name)){\n        return new oright();\n        }\n        return null;\n    }\n}\n```\n\n```\n运行结果:\n吃苹果\n```\n\n此时的程序，在客户端没有和具体的子类耦合在一起，这样一来，如果再有更多的A接口子类出现，只需要修改F类即可，即:所有的接口对象都通过F类取得，在程序员自己开发的代码中，只要是遇见要取得接口对象实例的操作，都应该使用工厂设计模式。\n\n\n匿名类使用注意事项\n- [ ] 使用匿名类的时候必须是继承一个类或者是实现一个接口，但是两者不可同时兼得，只能是继承一个类或者是实现一个接口\n- [ ] 匿名内部类是不能定义构造方法的\n- [ ] 匿名内部类不存在静态方法和静态变量\n- [ ] 匿名内部类属于局部内部类，所以局部内部类的限制同样对局部内部类生效\n- [ ] 匿名内部类不能是抽象的，它必须是一个实现的继承类或者是实现接口的所有抽象方法\n\nstatic\n- [ ] 由static定义的类方法，可以直接由类名直接调用，另外的就是static属性是一个共享的属性\n\n# java常用的类\n`API(应用程序编程接口)`\n\n基本类型的包装类\n----\n|基本数据类型|基本类型的包装类|\n|------------|----------------|\n|int|Integer|\n|double|Double|\n|byte|Byte|\n|char|Char|\n|float|Float|\n|shart|Shart|\n|long|Long|\n|boolean|Boolean|\n\n装箱与拆箱\n-----\n所谓的装箱就是把基本数据类型用它们相对应的引用数据类型包起来，使它们具有对象的特质，例如把int包装成Integer类的对象\n所谓拆箱就是与装箱刚刚相反，将Integer类的对象重新简化成基本数据类型\n```\npublic class Test{\n    public static void main(String args[]){\n            Integer i=new Integer(10);\n            int x=i.intValue();\n            System.out.println(x);\n            Double b=new Double(100.00);\n            double b1=b.doubleValue();\n            System.out.println(b1);\n\n    }\n}\n```\n\n```\n运行结果:\n10\n100.00\n```\n\n上面的程序是利用拆箱来把Integer类的包装类拆成基本数据类型Int，下面的double也是一样的\n装箱的操作:就是将基本数据类型变为包装类，利用各个包装类的构造方法来完成\n拆箱的操作:将包装类变为基本数据类型，利用各自的类的xxx.Value()方法来实现\n\n基本数据类型与String类的转换\n----\n**但是以下的操作是不包括Char类的，因为String类有一个CharAt方法可以取得指定索引的字符** \n\n`将String类型转换成基本数据类型` \n\n```\npublic class Test{\n    public static void main(String args[]){\n            String s=\"123\";\n            int i=Int.parseInt(s);\n            String s1=\"123.6\";\n            double b=Double.parseDouble(s1);\n            System.out.println(i);\n            System.out.println(b);\n    }\n}\n```\n\n```\n运行结果:\n123\n123。6\n```\n\n在将字符串换成基本数据类型的时候要注意一定要符合对应的数据类型，不能把数据类型搞混。\n\n`把基本数据类型变为String类型` \n\n```\npublic class Test{\n    public static void main(String args[]){\n            int i=100;\n            String s=String.ValueOf(i);\n            System.out.println(s);\n            double b=123.6;\n            String s1=String.ValueOf(b);\n            System.out.println(s1);\n    }\n}\n\n```\n\n```\n运行结果:\n100\n123.6\n```\n\n上面是利用String类里的机制方法来进行对不同基本数据类型转换成String类。\n\n# 日期操作类\n|类名|说明|\n|----|----|\n|LocalDateTime|存储了日期和时间|\n|LocalDate|存储了日期|\n|LocalTime|存储了时间|\n\n\n```\nimport java.time.LocalDate;\nimport java.time.YearMonth;\nimport java.time.Year;\nimpore java.time.MonDay;\npublic class Test{\n    public static void main(String args[]){\n            LocalDateTime l1=LocalDateTime.now();\n            System.out.println(l1);//根据日期类来调用方法来打印现在的年月日,在这里就不打印了,自己尝试\n            Year year=Year.of(2010);\n            YearMonth yearmonth=year.at(2);\n            LocalDate localdate=yearmonth.at(28);\n            System.out.println(localdate);\n            System.out.println(localdate.isEqual(localdate));\n            MonthDay m=Monday.of(4,15);\n            localdate l=m.atyear(2015);\n            System.out.println(l);\n    }\n}\n```\n\n```\n运行结果:\n2010-2-18\ntrue\n2015-4-15\n```\n从上面的程序可以看出，在java中对日期的操作是非常强大的，可以根据自己的需求来慢慢进行设置，在上面我也给出了对于日期类的归属。\n\n\n```\nimport java.time.*;\nimport java.time.format.*;\npublic class Test{\n    public static void main(String aegs[]){\n            LocalDate localdate=LocalDate.now();//获取当前日期\n            DateTimeForMatter datetime=DateTimeForMatter.ofPattern(\"dd/mm/uuuu\");//设置日期打印的格式\n            String str=localdate.ofmat(datetime);//把当期日期放在设置好的日期格式\n            System.out.println(str);//打印出来\n    }\n}\n```\n\n```\n运行结果:\n自己尝试了，仆街。\n```\n\n在java中，设置日期的格式是用过DateTimeForMatter类来设置格式的，然后把时间放在设置好的格式里，最后通过String类来进行打印出来。\n\n# 正则\n\n|正则标识符|意义|\n|----------|----|\n|\\ |表示一位字符|\n|\\\\|表示多位字符|\n|\\n|匹配换行|\n|[abc]|a,b,c中的任意一位|\n|[^abc]|表示不是abc中的任意一位|\n|[a-zA-Z]|表示任意一位字母(不管大小写)|\n|[0-9]|表示0-9任意一位|\n|.|表示任意一位字符|\n|\\d|等价与0-9|\n|\\D|等价与[^0-9]|\n|\\s|表示一位空格|\n|\\S|表示非空格|\n|\\w|等价与[a-zA-Z0-9]|\n|\\W|等价与[^a-zA-Z0-9]|\n|^|表示正则的开头|\n|$|表示正则的结尾|\n\n```\npublic class Test{\n    public static void main(Strng args[]){\n        if(\"123\".matches\"\\\\d+\"){\n            System.out.println(\"true\");\n        }else{\n        System.out.println(\"false\");\n        }\n        String s=\"1234@163.com\";//给出字符串\n        String s1=\"\\\\w+@\\\\w+.\\\\w+\";//给出邮箱的格式(w:等价于[a-zA-Z0-9])\n        System.out.println(s.matches(s1));//验证上面的邮箱格式\n    }\n}\n```\n\n```\n运行结果:\ntrue\ntrue\n```\n\n上面的程序是通过正则来判断并输出结果的，上面的方法是正则类里的一个方法，意思是判断字符串是不是由数字组成的，是就输出true，不是就false，明显与结果是一样的。\n|方法|意义|\n|----|----|\n|boolean matches(String test)|将字符与给出的正则表达式进行匹配验证|\n|String replaceAll(String test,String replacement)|按照指定的正则进行替换|\n|String replzceFirst(String test,String replacement)|按照指定的正则进行替换首个|\n\n```\npublic class Test{\n    public static void main(String args[]){\n            String s=\"123abcd3546efg\";\n            String s1=\"\\\\d+\";多个数字\n            System.out.println(s.replaceAll(s1,\"\"));//在字符串中替换数字\n            System.out.println(s.replaceFirst(s1,\"\"));//在字符串中替换首个字符前数字\n\n    }\n}\n```\n\n```\n运行结果:\nabcdefg\nabcd3546efg\n```\n\n在上面我给出的正则表达式的表示符可以在这个程序里尽情的尝试，你也会有发现的，但重要的是对你的理解有帮助,这样学起来是理解性的学习而不是一味的烦躁。\n\nBigDecimal(大数值)\n----\n\n```\nimport java.math.BigDecimal;\npublic class Test{\n    public static void main(String args[]){\n            BigDecimal b=new BigDecimal(\"3456789101112\")\n            BigDecimal b1=new BigDecimal(\"123456789\");\n            System.out.println(b.add(b1));//加法\n            System.out.println(b.subtract(b1));//减法\n            System.out.println(b.multipy(b1));//乘法\n            System.out.println(b.multipy(b1).setScale(1,BigDecimal.ROUND_up));//乘法,但是以进一的形式来输出值\n            System.out.println(b.divide(b1,BigDecimal.ROUND_DOWN));//除法\n            BigDecimal b2[]=b.divideAndRemainder(b1);//除法，并把值放在数组里面\n            System.out.println(\"商\"+b2[0]+\"余\"+b2[1]);\n    }\n}\n\n```\n\n上面的程序主要是应对于大的数字，在int和long都无法容纳的时候就使用BigDecimal类型来进行操作，(结果自己动手)\n\n**当需要在ArrayList和HashMap中放东西的时候,你在这个时候使用基本数据类型是不能放进去的，因为容器里面都是放** <++>\n","source":"_posts/Java.md","raw":"---\ntitle: Java\ndate: 2019-09-19 10:37:00\n---\n\n![终端运行的结果](Java/java0.png) \n\nWrite Once,Run Everywhere\n <!--more-->\n\n **达到对面向对象编程思想更加深入的理解，是对面向对象的各种特性及其实现细节更加熟练的掌握。** \n\n ---\n\n *一步一个脚印的连好java的基本功。对于我来说是最好不过的，掌握java的基本语法。(类与对象，构造方法，引用传递，内部类，异常，包，java常用类库，javaIO，java类集)* \n\n1. 走技术之路(在学习java的同时，把基础的知识打好一定的基础)\n2. 定位成为技术类管理成员(掌握基础的java知识，还要有几年的工作经验)\n3. java软件开发发展前景好，移植性也很强。\n- [ ] JDK(java开发工具包)\n\n*是编程语言和javaAPI类库和java虚拟机(是完成移植性的重要机制)来组成的* \n\n- [ ] JRE(java运行时环境)\n*是javaAPI子集和java虚拟机组成* \n\n**前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。** \n---\n\n**java系统可分为：javaEE(标准版)，javaSE(企业版)，javaME(微型版)，javaCARD(智能卡版)** \n---\n\n```\n//有必要说明一下，接下来的是在linux系统下使用终端来让我电脑上的文件进行运行\n\npublic class hello{//public(公有访问类型),class(类的标识),hello(类名)\n    public static void main (String arg[]){//是main函数的基本格式,也表明main函数是静态方法\n    System.out.println(\"hello,world!\");//打印字符串\"hello,world!\"\n    }\n}\n```\n\n![终端运行的结果](Java/java0.png) \n\n---\n\n**这里要注意一下的就是文件的后缀是.java,其次是以javac 来作为第一次的关键字来操作文件，接着就会生成一个后缀为.class的文件，然后就是运行你写的文件，记住后面没有任何的后缀。** \n\n* **java是面向对象的过程，也就是说在java中只有方法而没有所谓的函数。** \n\n```\npublic class Test{\n    public static void main(String args[]){\n    scanner s=new scanner(System.in);//为了可以让用户输入，在这里使用了scanner类,因为它附属与System.in\n    System.out.println(\"请输入你的性别\");\n    String set=s.nextLint();//以字符串的形式输入\n    System.out.println(\"请输入你的姓名\");\n    String name =s.nextLint();\n    switch(set){\n    case \"男\":\n    System.out.println(name+\"男士\");\n    break;\n    case \"女\":\n    System.out.println(name+\"女士\");\n    break;\n    default :\n    System.out.println(\"输入有误\");\n    break;\n    }\n    s.close();//关闭类\n    InputStreamReader input=new InputStreamReader(System.in);//定义在键盘输入\n    BufferedReader Buff=new BufferedReader(input);//以缓冲流的形式来接受input\n    //用try和catch机制来处理异常\n    try{\n    System.out.println(\"请输入字符：\");\n    String s=Buff.readLine();\n    System.out.println(\"字符：\"+s);\n    }catch (Exception e){\n    System.out.println(\"异常\");\n    }\n}\n```\n\n\n![运行结果](Java/java2.png)\n\n![输入的方式](Java/java1.png)\n\n*在这里只是简单的让用户输入了两次都是以字符串的方式来输入的，当然你也可以让用户输入你想让用户输入的数据类型(eg:int ,double)，上面也有参照的照片。* \n\n* **合法的标识符** \n- [ ] 不能存在关键字\n- [ ] 首字母不能是数字\n- [ ] 不能存在运算符\n- [ ] 标识符是区别大小写的\n- [ ] 标识符的命令规则是强制性的\n\n`我们都知道数据的类型有int,short,float,double,byte(字节)。最常见的就是int(整形的数据类型)。在java中我们可以通过程序来输出各个数据类型的范围是多少，最大值和最小值，和数据类型\n`\n\n```\npublic class Test{\n    public static void main (String args[]){\n    int a=Integer.Size;\n    System.out.println(\"int的范围:\"+a);\n    int b=Integer.MAX_VALUE;\n    System.out.println(\"int的最大值:\"+b);\n    int c=Integer.MIN_VALUE\n    System.out.println(\"int的最小值:\"+c);\n    Class <Integer> d=Integer.TYPE;\n    System.out.println(\"数据类型:\"+d);\n    }\n}\n```\n\n```\n运行结果：\nint的范围:32\nint的最大值:2147483647\nint的最小值:-2147483648\n数据类型:int\n```\n\n---\n\n```\npublic class Test{\n            static int i=10;\n    public static void main(String args[]){\n            int a=1;\n            int b=2;\n            {\n            int b=3;//main方法的变量名是不可以重复的，一个变量只能使用一个名，在这里就是重复使用了变量b，所以程序会报错。\n            System.out.println(\"b=\"+b);\n            System.out.println(\"a=\"+a);\n            System.out.println(\"i=\"+i);\n            }\n            System.out.println(\"b=\"+b);\n            System.out.println(\"a=\"+a);\n            System.out.println(\"i=\"+i);\n\n    }\n}\n```\n\n```\n上面的程序是运行不过的，这也是java的特别之处，在c++中，变量b是可以用的，但在java中是不可以的。\n```\n\n```\npublic class Test{\n    public static void main (String args[]){\n            char ch = '\\\"';//转义字符\n            System.out.println(ch);\n            System.out.println(\"\\\"hello,world!\"\\\");\n            System.out.println(ch+\"hello,world!\"+ch);\n    }\n}\n```\n\n```\n运行结果\n\"\n\"hello,world!\"\n\"hello,world!\"\n```\n---\n\n`总结可以得知，不管是用变量来存放转义字符，还是直接使用转义字符的方式来输出字符，程序都是可以顺利运行的，当然你也可以不使用变量来存放转义字符，但一个程序里面有太多的转义字符的存在你用变量来存放不是更好使用？这样你也不容易搞混已有的转义字符的使用。` \n\n```\npublic class Test{\n    public static void main(String args[]){\n        System.out.println(2+3+\"k\");\n        System.out.println(6+6+\"aa\"+6+6);\n    }\n}\n```\n\n```\n运行结果\n5k\n12aa66\n```\n---\n\n`上面的2+3是一个表达式，所以这里是5,但后面跟的是字符和+(字符串相加)的符号，所以是5k,下面的也是一样的，唯一不一样的是在+(字符串相加)之后，计算机会自动认为后面的也是+(字符串相加)所以后面的就是12aa66。但如果把上面的双引号换成单引号就是以数字的形式先加后输出的。` \n\n# 数组\n\nimport java.util.Randow;//随机数字的包\n\n```\npublic class Test{\n    public static void main(String args[]){\n                int i=3;//这是在堆内存的分配的内存(也可以说是在编译是分配的),读取速度快，但数据的活动范围小(缺少灵活性)\n                int y=new Integer(1);//是在栈内存分配的内存(也可以说是运行时分配的内存),读取速度慢，但数据灵活性高。\n                System.out.println((int)(Math.randow()*10));//生成随机数字，0～10\n                Randow rand=new Randow();\n                int i=rand.nextInt(10);//随机生成0～10的数字\n                System.out.println(i);\n    }\n}\n```\n\nimport java.util.Randow;//导入随机数字的包\n```\npublic class test{\n    public static void main(String args[]){\n            Randow rand=new Randow();//声明随机数字的对象\n            int []numb=new int [rand.nextInt(10)];//rand.nextInt(10)这句话的意思是随机生成一个0～10的数字作为数组的长度\n            for(int i=0;i<numb.length;i++){//为数组赋值。从0～100来选择每次的赋值的数值\n                numb[i]=rand.nextInt(100);\n            }\n            for(int a : numb){//打印数组里的元素\n            System.out.println(a);\n            }\n    }\n}\n```\n\n**在c++中的指针，在java是叫做引用数据类型，相当与c++中的地址指针** \n```\npublic class test{\n    public static void main(String args[]){\n    Randow rand=new Randow();//声明随机数字的对象\n    int []a=new int[rand.nextInt(10)];//定义数组长度\n    int []b=a;//把数组a赋值给数组b\n    for(int i=0;i<a.length;i++){//为数组a赋值\n            a[i]=rand.nextInt(100);\n            System.out.println(a[i]);\n            System.out.println(b[i]);\n    }\n    }\n}\n```\n\n`上面程序的结果每次都是不要的，但值得注意的是输出的结果，肯定不会让你们失望的，因为数组b里面的元素是和数组a的元素是一样的。其实，上面最重要的一点就是数组b=数组a，它的等于是连着后面的a数组的赋值。` \n\n---\n\n```\npublic class test{\n    public static void main(String args[]){\n            Randow rand=new Randow();\n            int [][]numb=new int[3][1];//声明数组numb和给数组长度\n            for(int i=0;i<numb.length;i++){//给数组赋值并输出数组里的元素\n                for(int j=0;j<numb[i].length;j++){\n                        numb[i][j]=rand.nextInt(10);\n                        System.out.println(numb[i][j]);\n                }\n            }\n    }\n}\n```\n\n`一样的，上面的数组每运行一次程序的结果都是不一样的。` \n\n---\n```\npublic class test{\n    public static void main(String args){\n            int []numb=new int[]{10,23,41,6,11};//声明一个数组，并赋初值\n            int a=Randow rand=new Randow(3)+1;//生成随机数字，范围是1～4\n            for(int i=0;i<a;i++){//把随机数字的大小作为条件,并从一开始交换位置\n                int temp=numb[i];\n                numb[i]=numb[i+1];\n                numb[i+1]=temp;\n            }\n            for(int b:numb){//输出数组里的元素\n            System.out.println(b);,你在这个时候使用基本数据类型是不能放进去的，因为容器里面都是放            }\n\n    }\n}\n```\n\n`上面程序实现的是乱序，就是每次输出的结果都是不一样的。` \n\n---\n\n# 对象\n**类描述了对象的属性和对象的方法，类是对象的模板，更可以说，对象是类的实例，是一个实实在在存在的个体。所以说，面向对象的程序重要的是类的设计而不是对象的设计。** \n`类的声明格式:` \n- [ ] [标识符] class 类的名称\n{\n        //类的属性\n        //类的方法\n}\n`类的标识符:` \n- [ ] 默认的(default):这个类只能被这个类的对象和同一个包中的其它的类访问，即使是其它包里的这个类的子类都不能被访问，它只认同一包里的类。\n\n- [ ] 私有(private):如果一个方法或者属性被定义为私有的，那么只能在本类里访问它。\n\n- [ ] 公有(public):如果一个方法或属性被定义为公有的，那么它不仅能跨类的对象所调用，还能在其它包中被访问。\n\n- [ ] 保护(protected):如果一个方法或属性被定义为保护的，那么它能被本类的方法所访问，也能被子类所访问，即使子类在其它包里。\n\n![java访问机制](Java/java3.png) \n\n```\npublic class Test{\n    public static void main (String args[]){\n            System.out.println(\"------\"创建对象\"-------\");\n            new Apple();//匿名对象\n    }\n}\nclass Apple{\n        static String a=\"string-a\";\n        Static String b;\n        String c=\"string-c\";\n        Strint d;\n        Static{//static 属于静态代码块，最先运行的是这段代码块，而不是类的构造函数先\n                printstatic(\"before static\");\n                b=\"string-b\";\n                printstatic(\"after static\");\n        }\n        static void printstatic(String name){//这里要加静态的关键字，因为调用是静态来的所以这里也要有静态的关键字来表明这里是静态，不然是会报错的。\n                System.out.println(\"------\"+name+\"-------\");\n                System.out.println(\"a=\"+a);\n                System.out.println(\"b=\"+b);\n        }\n        Apple(){\n            print(\"before class\");\n            d=\"string-d\";\n            print(\"after class\");\n        }\n        void print(){\n                System.out.println(\"------\"+name+\"-------\");\n                System.out.println(\"a=\"+a);\n                System.out.println(\"b=\"+b);\n                System.out.println(\"c=\"+c);\n                System.out.println(\"d=\"+d);\n\n        }\n}\n```\n![运行结果](Java/java4.png) \n\n```\n上面的对象是经过匿名对象来实例化的，也就是没有给new的对象一个堆内存，一旦这句语句实现完，计算机会自动回收这个内存，将不再存在程序里，这也是java的垃圾回收机制(BC)，这也是为我们考虑的，不知道你有没有发现，上面的几个程序我都是用new来给类分配的对象，但我不但没有在类中写析构函数，也没有在main函数里delete对象的实例化。因为这一切都是java的BC机制帮我们做了。\n\n```\npublic class Test{\n\n    public static void main(String args[]){\n            String name=new String (\"java\");\n            String _name=new String (\"java\");\n            String hua=_name;\n            if(name==_name){\n            System.out.println(\"地址相同\");\n            }else{\n            System.out.println(\"地址不同\");\n            }\n            if(name.equals(_name)){\n            System.out.println(\"内容相同\");\n            }else{\n            System.out.println(\"内容不同\");\n            }\n}\n运行结果:\n地址不同\n内容相同\n```\n\n上面的程序分别实现了字符串地址(==)和字符串内容(equals方法)的比较，第一个变量和第二个变量的是经过new来分配的栈内存的地址，所以输出的是地址不相同,而最后一个的是进行的内容比较，因为初始化的原因，这里也是输出的内容相同。\n\n\n构造方法的注意事项\n- [ ] 构造方法的名称与类的名称是一样的\n- [ ] 构造方法也是和普通方法一样的，可以被重载，但构造方法的调用是通过在创建类的对象的时候自动调用的，这是与普通方法的调用是不一样的\n- [ ] 构造方法是没有返回值的\n- [ ] 构造方法是不能被static和final修饰的\n- [ ] 构造方法是不能被继承的，如果子类要使用父类的构造方法只能使用关键字(super)来进行调用\n\n```\npublic Test{\n\n    private String name;\n    Test(){\n    System.out.println(\"类的无参构造方法的调用\");\n    }\n    Test(String _name){\n        this->name=_name;\n        System.out.println(\"类的有参构造方法的调用\");\n    }\n    public static void main(String args[]){\n            new Test();//这是匿名调用类的构造方法\n            Test test=new Test();//这和上面是等价的\n            Test t1=new Test(\"小明\");\n    }\n}\n\n上面的程序做的只是简单的演示类的构造方法的重载。\n\n```\npublic Test{\n    public static void main(String args[]){\n    Apple apple;\n    apple=Apple.V();\n    System.out.println(\"姓名:\"+apple.name);\n    }\n}\nclass Apple{\n        String name;\n        private Apple (){\n        name=\"hello\";\n        }\n        private static final Apple APPLE=new Apple();\n        public static V(){\n        return APPLE;\n        }\n}\n```\n\n上面的程序的重要性是:当你不想一个类被频繁调用的是时候，可以通过对类的构造方法的私有化来实现\n\n\n\n\n# 代码块\n- [ ] 普通代码块(就是普通的放在Main方法里面的代码块)\n- [ ] 构造代码块(放在类里面，比构造方法更先一步执行的代码块)\n- [ ] 静态代码块(比构造代码块更快一步，如果和Main方法是放在同一个类的话，那它比Main方法更快一步执行)\n- [ ] 同步代码块\n\n> 普通代码块\n\n```\npublic class Test{\n        public static void main(String args[]){\n        {int x=10;//普通代码块\n        System.out.println(\"x\");\n        }//如果不要这个代码块，程序将会报错，因为在一个方法里，不能有同名的变量名\n        int x=100;\n        System.out.println(\"x\");\n}\n}\n```\n\n```\n运行结果为:\n10\n100\n```\n\n>> 构造代码块\n\n```\npublic class Test{\n    public static void main(String args[]){\n           Peron p=new peron(); \n           Peron p1=new Peron(\"笑话\");\n    }\n}\nclass Peron{\n    private int x;\n    String name;\n    {\n    System.out.println(\"构造代码块的调用\");//这是构造代码块\n    x=10;\n    }\n    Peron(){\n        System.out.println(\"类的无参构造方法的调用\\t\"+x);\n    }\n    Peron(String _name){\n    this->name=_name;\n    System.out.println(\"类的有参构造方法的调用\\t\"+x);\n    }\n}\n\n```\n```\n程序的运行结果为:\n    构造代码块的调用\n    类的无参构造方法的调用  10\n    构造代码块的调用\n    类的有参构造方法的调用  10\n```\n\n上面类中是有一块属于构造代码块，而它的速度比构造方法的调用都还快，以前我们只知道对于类来说，构造方法是第一个调用的，因为在我们声明类的对象的时候就是通过类的构造方法来实现的，但现在不一样的是，你只要在类中加个中括号({}),里面的代码实现比类的构造方法都还要快被实现，这使得我们的代码更简化一步。比如，就像上面一样，给一个成员变量复制，而不是通过它的构造方法来实现，你只需要定义一个变量，然后再加个({}),就能实现对成员变量的复制，速度还比类的构造方法快一布。\n\n**由此我们可以知道，类的代码块中的初始化是一个类的所有构造方法都共有的“交集”部分，具有个性化的初始化还是要放在各自的构造方法里** \n\n\n>>> 静态代码块\n\n```\npublic class Test{\n    static {\n    System.out.println(\"静态方法的调用\");\n    }\n    {\n    System.out.println(\"构造代码块的调用\");\n    }\n    Test(){\n    System.out.println(\"构造方法的调用\");\n    }\n    public static void main(String args[]){\n            System.out.println(\"创建第1个对象\");\n            new Test();\n            System.out.println(\"创建第1个对象\");\n            new Test();\n            System.out.println(\"创建第1个对象\");\n            new Test();\n    }\n}\n\n```\n```\n程序的运行结果为:\n    静态代码块的调用\n    创建第1个对象\n    构造代码块的调用\n    构造方法的调用\n    创建第2个对象\n    构造代码块的调用\n    构造方法的调用\n    创建第3个对象\n    构造代码块的调用\n    构造方法的调用\n\n```\n\n\n**从上面的案例可以看出来，在执行时机上，静态代码块是在类加载的时候就会执行的，因为早于类的构造代码块和类的构造方法。当一个静态代码块和Main方法在同一个类中，Main方法的调用也是在静态代码块的后面的。静态代码块的执行级别是最高的。**    \n\n\n\n```\npublic class Test{\n    public static int [] show(int []numb){\n        numb[0]=10;\n        numb[1]=12;\n        numb[2]=13;\n        return numb;\n    }\n    public static void show1(int []numb){\n        for(int i:numb){\n        System.out.print(i+\"\\t\");\n        }\n    }\n        public static void main(String args[]){\n            int [] numb =new int{1,2,3,4,5};\n            for(int i:numb){\n            System.out.print(i+\"\\t\");\n            }\n            System.out.println();\n            System.out.println(\"--------------\");\n            show(numb);\n            Show1(numb);\n\n    }\n}\n```\n\n```\n    程序的运行结果为:\n    1 2 3 4 5 \n    10 11 12 4 5\n```\n\n`上面的程序只是简单的利用java的特性用新的方式来打印数组，只需要一个变量来操作数组对象就行了，比我们之前在c++中的方式简便多了，也是代码的量也减少了，这无疑是一件好事，还利用了引用数据类型来实现对数组的操作，更加利用了静态方法来进行对数组里的元素更改。` \n\n\n```\nimport java.util.*//导入sort包\npublic class Test{\n    public static void main(String args[]){\n    int []numb={10,2,46,33,5};\n    Arrays.sort(numb);//进行数组的排序\n    System.out.println(\"排序后:\");\n    for(int i:numb){\n    System.out.print(i+\"\\t\");\n    }\n        \n    }\n}\n\n```  \n\n\n```\n程序的运行结果为:\n排序后:\n2 5 10 33 46\n```\n\n# 枚举(enum)\n`enum A{红色，黄色，白色}枚举是作为类来被调用的，在定义的同时是连着对象的构造方法一起被调用的` \n```\nenum Cloro{红色，黄色，白色}//是枚举的关键字,定义了一个枚举并初始化了\npublic class Test{\n    public static void main(String args[]){\n            //java中的枚举其实是一个类来的，在这个类里面还有很多不一样的方法，其作用都是不一样的。\n            Cloro []cloro=Cloro.values();//Cloro.values()是类的静态方法来的，但是以字符串的形式来的，所以在前面要定义一个同类型的数组来接收,方法是自动生成的\n            for(Cloro i:cloro){\n            System.out.println(i);\n            }\n            Cloro c=Cloro.valueof(Cloro.class,\"白色\");//以指定的颜色来赋给对象,这里的参数有点不一样的就是，参数是类的类型,方法是自动生成的\n            System.out.println(c);\n            \n    }\n}\n```\n\n```\n运行结果:\n红色\n黄色\n白色\n白色\n```\n\n枚举的注意事项\n- [ ] 如果把枚举的标识符定义为public的话要放在独立的文件里面而不能和main方法放在同一个文件，如果标识符是默认的话就可以放在同一个文件里\n- [ ] 使用enum来定义枚举的时候，默认会继承于java.lang.Enum类。默认会用final来修饰，因此无法派生子类。\n- [ ] 使用enum来定义的时候，初始化也要和定义一起,如果没有把赋值放在同一行，而这个enum将无法被实例法。\n- [ ] 所以使用enum来定义枚举的时候都会默认生成values方法，该方法可以方便遍历所有枚举值，而在枚举中还是有其它的自动生成的方法来给我们使用。\n\n**enum(枚举)用关键字定义的时候相当于定义了一个类，而这个类继承于Enum类。而在Enum类中的所有方法都是保护类型的，因此这些方法都可以在声明了enum对象中被使用。** \n\n```\nenum A{红色，紫色，白色}\npublic class Test{\n    public static void main(String args[]){\n            A []a=A.valuse();//把枚举中的元素都放在对应类型的数组中\n            for(A i:a){\n            System.out.println(i.name+i.ordinal());输出的是数组中的元素和数组的下标\n            }\n    }\n}\n```\n\n```\n运行结果:\n红色0\n紫色1\n白色3\n```\n\n`在枚举中的下表要是没有给定提定的数值，计算机就会自动给它一个下标，而下标的值是以数组的形式来赋值的。` \n\n\n`EnumMap是Map接口的子类，也就是说Enummap是继承于类Map的` \n\n```\nimport java.util.Map;//导包\nimport java.util.EnumMap;//导包\nenum Color{红色，黄色，绿色}\npublic class Test{\n    public static void main(String args[]){\n        EnumMap<Color,String>emap=new EnumMap<Color,String>(Color.class);//映射<><KeyType,nameType>,更重要的是EnumMap的构造方法的参数不能为空，需要指定一个枚举类\n        emap.put(Color.红色,\"RED\");//把映射的对象和值都写进去\n        emap.put(Color.黄色,\"YELLOW\");\n        emap.put(Color.绿色,\"BLUE\");\n        for(Map.Entry<Color,String>me:emap.entrySet()){//把映射的键和值都打印出来,其中的两个方法是Map中的静态方法，EnumMap作为Map的子类所以能调用其中的方法。\n        System.out.println(me.getKey()+me.getValue());\n        }\n    }\n}\n```\n\n```\n运行结果:\n红色RED\n黄色YELLOW\n绿色BLUE\n```\n\n上面的打印用的是新的打印方法，而EnumMap的类型是Map来的，所以它要Map.来点出它的方法来进行打印,Key是不允许重复的，而它的值却允许重复，EnumSet是一个集合来的\n\n```\nimport java.util.EnumSet;//导包\nimport java.util.Iterator;//导包\nenum Color{红色，绿色，紫色}\npublic class Test{\n    public static void main(String args[]){\n        EnumSet<Color> set=EnumSet.allof(Color.class);//声明集合<EnumTepy>并把对应类型的枚举类放在集合中,allof是集合EnumSet中的静态方法，用来把参数中的枚举类放在集合中作为集合的元素\n        Iterator <Color>iter=set.iterator();//声明迭代器并把集合放在迭代器中\n        while(iter.hasNext()){//参数是确认迭代器中的元素是否为空,为空的时候返回false\n        System.out.println(iter.Next());//打印迭代器中的元素\n        }\n        EnumSet <Color>aset=EnumSet.noneof(Color.class);//表示作为空的集合\n    }\n    Iterator iterator=aset.iterator();\n    while(iterator.hasNext()){\n    System.out.println(iterator.Next());//这里是打印不出来的，所以下面的结果为空\n    }\n}\n```\n\n\n```\n运行结果:\n红色\n绿色\n紫色\n```\n\n\n```\nenum Color{\n    RED(\"红色\",3),BLUE(\"蓝色\",4),YELLOW(\"黄色\",5);//定义枚举并指定颜色和下标，是以私有构造方法来显示调用枚举类的属性，(也就是说成员)\n    private String Name;//元素的名字\n    private int Indext;//元素的下标\n    private Color(String name,int indexc){//枚举类的构造方法是私有化的,所有的枚举对象都必须显示调用此构造方法。\n            this->Name=name;\n            this->Indext=indexc;\n    }\n    public static void setname(int indexc,String name){\n        for(Color c:Color.values()){\n            if(c.Indexc==indexc){\n            c.Name=name;\n            }\n        }\n    }\n    public static void setindexc(String name,int indexc){\n        for(Color c:Color.values()){\n            if(c.Name==name){\n            c.Indexc=indexc;\n            }\n        }\n    }\n    public String getname(String name){\n    return name;\n    }\n    public int getindexc(int intexc){\n    return intexc;\n    }\n\n\n}\npublic class Test{\n    public static void main(String args[]){\n        System.out.println(Color.RED.getname());//RED是枚举类型的Color的枚举实例。这些枚举实例是公有的静态对象(进一步说，它们可以视为枚举类的属性成员)\n        System.out.println(Color.RED.getindexc());\n        System.out.println(Color.BLUE.getname());\n        System.out.println(Color.BLUE.getindexc());\n        System.out.println(Color.YELLOW.getname());\n        System.out.println(Color.YELLOW.getindexc());\n        System.out.println(\"自定义元素\");\n        Color.setname(3,\"白色\");//通过属性下标来改变属性的名字\n        System.out.println(Color.RED.getname());\n        System.out.println(Color.RED.getindexc());\n        Color.setindexc(\"黄色\",7);//通过属性的名字来改变属性的下标\n        System.out.println(Color.YELLOW.getname());\n        System.out.println(Color.YELLOW.getindexc());\n    }\n}\n```\n\n```\n运行结果:\n红色\n3\n蓝色\n4\n黄色\n5\n白色\n3\n黄色\n7\n\n```\n\n在上面的程序中都是通过私有的构造方法来显示调用成员属性的，在上面属性其实是RED,BLUE,YELLOW,只不过我在这里都没对它操作，在这里比较容易混淆的是，根本不明白谁才是枚举的成员属性，你也可以通过上面的Values()(是枚举类自动生成的用来遍历枚举属性的方法),其实在上面我也用到了这个方法来对成员属性的名字和下标来进行改变它们对应的值。在最开始的时候定义的枚举的属性其实是在调用私有构造方法来实现实例化。只要把这个搞懂了，其实那些改变成员属性的方法都是很简单理解的。\n\n\n```\nenum Color{\n    红色\n    {\n        public String show(){\n            return \"RED\";\n        }\n    },\n    蓝色\n    {\n        public String show(){\n            return \"BLUE\";\n        }\n    },\n    黄色\n    {\n        public String show(){\n            return \"YELLOW\";\n        }\n    };\n    public abstract String show();//把上面的show方法定义为抽象方法(abstract)抽象关键字\n\n}\npublic class Test{\n    public static void main(String args[]){\n        \n        for(Color c:Color.values){\n        System.out.println(c.ordinal+\"\\t\"+c.name()+\"----\"+c.show());\n        }\n    }\n}\n```\n\n```\n运行结果:\n0  红色----RED\n1  蓝色----BLUE\n2  黄色----YELLOW\n```\n\n抽象方法关键字(abstract)，修饰没有主体的方法，在这里需要在枚举对象中一一单独实现，否则报\n\n\n```\nenum Weekday {Sun,Mon,Tue}\npublic class Test{\n    public static void main(String args[]){\n            Weekday w=Weekday.Sun;\n            switch(w){\n                case Mon:\n                System.out.println(Do Monday work);\n                case Sun:\n                System.out.println(Do Sunday work);\n            }\n    }\n}\n```\n\n```\n运行结果:\nDo Sunday work\n```\n\n这里是当你定义的是枚举类中的哪个元素的对象的时候，通过switch来进行选择，你输出的语句是你在switch写的语句。\n\n\n# 类\n|控制范围|private|default|protected|public|\n|----|----|----|----|----|\n|类|只能内部类允许私有，只能在当前类被访问|可以被当前包中的所有类访问|只有在内部类可以被设为保护权限,相同包中的类和其子类可以被访问|可以被所有类访问|\n|属性|只能被当前类访问|可以被相同包中的类访问|可以被当前包中的所有类访问和当前类的子类访问|可以被所有类访问|\n|方法|只能被当前类访问|可以被相同包中的类访问|可以被相同包中的类访问和当前类的子类访问|可以被所有类访问|\n\n\n\n`java中对于类来说有封装，继承，多态。` \n\n`java中类的成员变量的权限有私有，公有，保护，默认，在上面的表格中都给出了对应的权限范围，java类只有允许单继承不允许多继承，但允许多重继承，` \n\n```\nimport java.util.ArrayList;\npublic class Test{\n    public static void main(String args[]){\n    System.out.println(\"集合大小\");\n    Apple a=new Apple();//调用类的构造方法来实现对集合的操作\n    ArrayList <Interger>array=a.getarray();//声明一个集合来对类中的公有方法中的返回值进行赋值给这个集合,很重要的是，在这里传的是引用而不是数据的副本。\n    System.out.println(array.size());//打印集合的大小\n    array.add(8);//对集合的引用进行加值的操作\n    Arrjy <Interger>a1=a.getarray();又重新定义一个集合来对调用的类的公有方法的返回值进行赋值\n    System.out.println(a1.size());//打印集合的大小\n    System.out.println(\"集合元素\");\n    for(Interger i:a1){\n    System.out.println(i);\n    }\n\n    }\n}\nclass Apple{\n        private ArrayList<Interger>array=new ArrayList<Interger>();//声明一个私有集合作为类的成员变量\n        Apple(){//构造方法,对集合进行初始化\n        array.add(1);\n        array.add(1);\n        array.add(1);\n        }\n        ArrayList<Interger>getarray(){//返回集合\n        return array;\n        }\n\n}\n```\n\n```\n运行结果:\n集合大小\n3\n4\n集合元素\n1\n1\n1\n8\n```\n\n**其实在上面的程序中最难懂的是，在main方法里的集合的操作是引用的操作而不是简单的副本操作，在java中，除了基本的数据类型，其它都是引用类型,其中类也是引用类型** \n\n\n关于继承的限制\n- [ ] java中继承允许多继承，但也许多重继承\n- [ ] 从父类继承的私有成员不能被子类直接使用，要通过方法来间接调用\n- [ ] 子类在进行对象实例化的时候，先调用父类的构造方法对父类的成员变量进行赋值，然后在调用子类的构造方法，其作用是一样的。\n\n```\npublic class Test{\n    public static void mai(String args[]){\n        \n    }\n}\nfinal class A{\n    final void show(){\n    System.out.println(\"如果这个方法在不想被子类覆写，可以在方法前面加上这个修饰符来确定不被子类覆写\");\n    }\n\n}\n//class B extends A{}//是错误的,所以注释掉\n```\n\n上面的程序是不行的，因为父类的修饰符是final，它是不能被继承的\n\n```\npublic class Test{\n    public static void main(String args[]){\n        A a=new B();\n        a.show();\n    }\n}\nclass A {\n    A(){\n    System.out.println(\"父类的构造方法\")\n    }\n    void show(){\n        System.out.println(\"走\");\n    }\n}\nclass B extends A{\n    B(){\n    System.out.println(\"子类的构造方法\n    }\n    void show(){\n        System.out.println(\"飞\");\n    }\n}\nclass C extends A{\n    C(){\n        System.out.println(\"子类的构造方法\n}\n    void show(){\n        System.out.println(\"跑\");\n    }\n}\n```\n\n```\n运行结果:\n父类的构造方法\n子类的构造方法\n飞\n```\n\n上面的程序主要是实现多态的重要性，还有就是继承的小细节，继承是先调用父类的构造方法之后再调用子类的构造方法。在刚开始的时候就写过了在上面是先声明一个父类对象来进行对子类的实例化，然后在调用子类中覆写父类成员方法的方法，其实你也完全可以通过子类的对象来对子类进行实例化，在这里主要是实现类的多态。\n\n\n方法重载与覆写的区别\n- [ ] 重载是在本类中实现的，而覆写主要是在子类中重写父类的方法\n- [ ] 重载要求方法的参数个数和参数类型的顺序和参数的类型和方法名字，其中的任意一个不同。而覆写是方法名称和参数个数和类型与父类是一致的就行了\n\n\n`this&&super` \n----\n```\npublic class Test{\n    public static void main(String args[]){\n            B b=new B();\n            b.show();\n    }\n}\nclass A{\n        String name;\n        void show(){\n        this->name=\"java\";\n        }\n}\nclass B extends A{\n    String name;\n    void show(){\n        this->name=\"shanghai\";\n        super.show();\n        System.out.println(name+\"\\t\"+super.name);\n    }\n}\n\n```\n\n```\n运行结果:\nshanghai  java\n\n```\n\n|区别|this|super|\n|----|----|-----|\n|查找范围|先从本类中找到属性或方法，本类找不到再去父类寻找|不查询父类的属性或方法，直接从子类调用父类的指定属性和方法|\n|调用构造|this使用的是本类的构造|super先调用的是父类的构造方法，然后在调用子类的构造方法|\n|特殊|表示当前的对象|可以看作是父类的引用对象|\n|关系|两者的关系是属于二选一的关系，不能被同时调用|\n---\n抽象类\n----\n\n```\npublic class Test{\n        public static void main(String args[]){\n        A a=new B(\"小艾\",11);\n        a.show();\n        A a1=new C(\"笑话\",12);\n        a1.show();\n    }\n}\nabstract class A{\n        public abstract void show();\n}\nclass B extends A{\n        String name;\n        int age;\n        B(String _name,int _age){\n        }\n        public void show(){\n        System.out.println(\"学生\\t\"+name+\"\\t\"+age);\n        }\n}\nclass C extends B{\n    C(String _name,int _age){\n            super(_name,_age);\n    }\n    public show(){\n    System.out.println(\"工人\\t\"+name+\"\\t\"+age);\n    }\n}\n```\n\n```\n运行结果:\n学生  小艾  11\n工人  笑话  12\n```\n\n上面的类A是一个抽象类来的，抽象类是不能被实例化的，顾名思义，抽象类是没有实现的方法的，在上面的父类中只有定义成员方法为抽象方法的的一个定义，没有实现的行为，抽象类的实现一般是在子类中一一实现的，这也得于抽象类的特性，抽象类是不能被实例化的，这样做会报错的，一般的抽象类都是有子类的，子类的重要作用之一是实现父类中的抽象方法，这是很重要的，还有就是，定义在父类的全部抽象方法在子类中都要重写这些抽象方法，不然会报错，记住是全部都要重写。\n\n\n# 接口(interface)\n`接口是java所提供的另外一种重要的技术，是一种特殊的类，它的结构和抽象类很相似。接口里的数据成必须初始化，数据成员均为常量，常见的是全局变量。` \n`为了避免在接口中添加新的方法后要修改所有的实现类，允许定义默认方法` \n\n使用接口的原则\n- [ ] 接口必须有子类，子类依靠(关键字)implements来实现多个接口\n- [ ] 接口的子类必须重写接口中的所有抽象方法\n- [ ] 接口可以利用对象的多态性，利用子类的对象进行实例化\n- [ ] 接口和一般的类是一样的，具有成员变量和成员方法，但数据成员必须进行初始化，而初始化的值是不能被修改的，相当与是常量，方法也必须是抽象的或者是(default)，所以在接口中这两个特性是可以忽略的，因为在接口中不管是成员方法或者是成员变量都是特性都是肯定了的。\n\n\n```\npublic class Test{\n    public static void main(String args[]){\n            \n            B b=new B();\n            b.show();\n            b.print();\n        System.out.println(A.name);\n        //System.out.println(b.name);//不能通过类的实现来访问静态成员\n    }\n}\ninterface A{\n        public static String name=\"hello\";\n        public void show();\n        default void print(){\n        System.out.println(\"你好\");\n        }\n}\nclass B implements A{\n    //name=\"HELLO\";//这个是错误的\n    public void show(){\n        System.out.println(name);\n    }\n}\n\n```\n\n```\n运行结果:\nhello\n你好\nhello\n```\n\n上面的程序只是简单的介绍接口的基本定义的格式，其中有成员变量和成员方法，而其中的成员变量是全局类型的(还必须给初始化值)，成员方法分两种，一种是抽象方法(在子类是实现的方法，在接口只是声明而已)，另外是其它类型的成员方法\n\n\n**在这里在强调一次，接口与抽象类唯一不同的就是子类，对于接口来说可以实现多个接口，但抽象类是不能多继承的** \n\n```\npublic class Test{\n    public static void main(String args[]){\n        C c=new C();\n        c.show();\n    }\n}\ninterface A{\n    default void show(){\n    System.out.println(\"A接口的默认方法\");\n    }\n}\ninterface B{\n    default void show(){\n    System.out.println(\"B接口的默认方法\");\n    }\n}\nclass c implements A , B{}\n```\n\n上面的程序是错误的，因为在接口中的默认方法中如果有同名的方法，你在调用方法的同时，编译器会不知道你要调用的到底是哪一个方法，这就产生了所谓的二义性，一般来说在接口中一定不要有同名的变量,还有就是上面的接口是没有抽象类型的方法，所以在子类中是空的\n\n\n`在前面说过，接口是允许多继承的，接口中对于抽象类和接口的继承是先继承后实现` \n\n\n```\npublic class Test{\n    public static void main(String args[]){\n        F f=new F();\n        A a=f;//声明一个接口对象来指向子类，主要是在调用方法的时候让你清晰的知道在那个接口中调用的是那个方法。你也可以不写，直接用子类的实例化对象来调用\n        B b=f;\n        C c=f;\n        D d=f;\n        a.show();\n        b.prin();\n        c.print();\n        c.xiao();\n        d.printd();\n        d.xi();\n    }\n}\ninterface A{\n        public static String name=\"小新\";\n        public void show();\n}\ninterface B{\n    public void prin();\n}\ninterface  C extends A , B{//接口继承多个接口\n    public void print();\n    default void xiao(){\n    System.out.println(name+\"\\t多接口继承\");\n    }\n}\nabstract class D implements A,B{//抽象类继承多个接口\n    abstract public void printd();\n    void xi(){\n    System.out.println(name+\"\\t抽象类继承\");\n    }\n}\nclass F extends D implements C{\n    public void show(){\n    System.out.println(\"你好\");\n    }\n    public void prin(){\n    System.out.println(\"hello,world\");\n    }\n    public void print(){\n    System.out.println(\"一个接口继承多个接口\"+name);\n    }\n    public void printd(){\n    System.out.println(\"抽象类继承多个接口\");\n    }\n}\n```\n\n```\n\n\n\n运行结果:\n你好\nhello,world\n一个接口继承多个接口\n小新 多接口继承\n抽象类继承多个接口\n小新 抽象类继承\n```\n\n在上面的程序中我们可以知道，对于接口的继承，一个接口可以继承多个接口(extends)来继承，继承的同时不用进行对继承的接口进行实现。抽象类继承多个接口(implements),继承的同时一样不要进行对已继承的接口的方法实现，但子类一定要对继承的接口和抽象类中的方法进行实现,还有就是，不管是多接口继承还是抽象类继承，都是基于继承的特性来实现继承的，都会继承父接口的成员变量。对于接口的成员变量一定要在声明的同时就进行初始化。\n\n\n接口的作用--制定标准\n`接口是标准，所谓的标准，指的是各方共同遵守的一个原则。只有操作标准统一了，所有的参与者才可以按照统一的规则操作` \n\n```\npublic class Test{\n    public static void main(String args[]){\n        Computer c=new Computer();\n        c.show(new B);//拿子类的引用来作为参数调用父接口中的方法\n        c.show(new C);//拿子类的引用来作为参数调用父接口中的方法\n\n    }\n}\ninterface USB{\n        public void work();//这是抽象方法\n}\nclass B implements USB{\n    public void work(){\n        System.out.println(\"USB在工作\");\n    }\n}\nclass C implements USB{\n    public void work(){\n        System.out.println(\"USB在打印机中工作\");\n    }\n}\nclass Computer{\n    public void show(USB usb){//父接口作为方法的参数\n        usb.work();//调用类中的方法\n    }\n}\n```\n\n```\n运行结果:\nUSB在工作\nUSB在打印机中工作\n```\n\n上面展现的是接口作用--制定标准，利用接口USB来制定工作的标准，通过继承来实现接口中的方法，最后通过电脑类中的方法来调用在子类的实现\n\n接口--工厂的设计\n```\npublic class Test{\n    public static void main(String args[]){\n    A a=F.getname(\"apple\");\n        \n    }\n}\ninterface A{\n        public void eat();\n}\nclass apple implements A{\n    public void eat(){\n        System.out.println(\"吃苹果\");\n    }\n}\nclass oright implements A{\n    public void eat(){\n    System.out.println(\"吃橙子\");\n    }\n}\nclass F{\n    public static A getname(String name){\n        if(\"apple\".equals(name)){\n        return new apple();\n        }\n        if(\"oright\".equals(name)){\n        return new oright();\n        }\n        return null;\n    }\n}\n```\n\n```\n运行结果:\n吃苹果\n```\n\n此时的程序，在客户端没有和具体的子类耦合在一起，这样一来，如果再有更多的A接口子类出现，只需要修改F类即可，即:所有的接口对象都通过F类取得，在程序员自己开发的代码中，只要是遇见要取得接口对象实例的操作，都应该使用工厂设计模式。\n\n\n匿名类使用注意事项\n- [ ] 使用匿名类的时候必须是继承一个类或者是实现一个接口，但是两者不可同时兼得，只能是继承一个类或者是实现一个接口\n- [ ] 匿名内部类是不能定义构造方法的\n- [ ] 匿名内部类不存在静态方法和静态变量\n- [ ] 匿名内部类属于局部内部类，所以局部内部类的限制同样对局部内部类生效\n- [ ] 匿名内部类不能是抽象的，它必须是一个实现的继承类或者是实现接口的所有抽象方法\n\nstatic\n- [ ] 由static定义的类方法，可以直接由类名直接调用，另外的就是static属性是一个共享的属性\n\n# java常用的类\n`API(应用程序编程接口)`\n\n基本类型的包装类\n----\n|基本数据类型|基本类型的包装类|\n|------------|----------------|\n|int|Integer|\n|double|Double|\n|byte|Byte|\n|char|Char|\n|float|Float|\n|shart|Shart|\n|long|Long|\n|boolean|Boolean|\n\n装箱与拆箱\n-----\n所谓的装箱就是把基本数据类型用它们相对应的引用数据类型包起来，使它们具有对象的特质，例如把int包装成Integer类的对象\n所谓拆箱就是与装箱刚刚相反，将Integer类的对象重新简化成基本数据类型\n```\npublic class Test{\n    public static void main(String args[]){\n            Integer i=new Integer(10);\n            int x=i.intValue();\n            System.out.println(x);\n            Double b=new Double(100.00);\n            double b1=b.doubleValue();\n            System.out.println(b1);\n\n    }\n}\n```\n\n```\n运行结果:\n10\n100.00\n```\n\n上面的程序是利用拆箱来把Integer类的包装类拆成基本数据类型Int，下面的double也是一样的\n装箱的操作:就是将基本数据类型变为包装类，利用各个包装类的构造方法来完成\n拆箱的操作:将包装类变为基本数据类型，利用各自的类的xxx.Value()方法来实现\n\n基本数据类型与String类的转换\n----\n**但是以下的操作是不包括Char类的，因为String类有一个CharAt方法可以取得指定索引的字符** \n\n`将String类型转换成基本数据类型` \n\n```\npublic class Test{\n    public static void main(String args[]){\n            String s=\"123\";\n            int i=Int.parseInt(s);\n            String s1=\"123.6\";\n            double b=Double.parseDouble(s1);\n            System.out.println(i);\n            System.out.println(b);\n    }\n}\n```\n\n```\n运行结果:\n123\n123。6\n```\n\n在将字符串换成基本数据类型的时候要注意一定要符合对应的数据类型，不能把数据类型搞混。\n\n`把基本数据类型变为String类型` \n\n```\npublic class Test{\n    public static void main(String args[]){\n            int i=100;\n            String s=String.ValueOf(i);\n            System.out.println(s);\n            double b=123.6;\n            String s1=String.ValueOf(b);\n            System.out.println(s1);\n    }\n}\n\n```\n\n```\n运行结果:\n100\n123.6\n```\n\n上面是利用String类里的机制方法来进行对不同基本数据类型转换成String类。\n\n# 日期操作类\n|类名|说明|\n|----|----|\n|LocalDateTime|存储了日期和时间|\n|LocalDate|存储了日期|\n|LocalTime|存储了时间|\n\n\n```\nimport java.time.LocalDate;\nimport java.time.YearMonth;\nimport java.time.Year;\nimpore java.time.MonDay;\npublic class Test{\n    public static void main(String args[]){\n            LocalDateTime l1=LocalDateTime.now();\n            System.out.println(l1);//根据日期类来调用方法来打印现在的年月日,在这里就不打印了,自己尝试\n            Year year=Year.of(2010);\n            YearMonth yearmonth=year.at(2);\n            LocalDate localdate=yearmonth.at(28);\n            System.out.println(localdate);\n            System.out.println(localdate.isEqual(localdate));\n            MonthDay m=Monday.of(4,15);\n            localdate l=m.atyear(2015);\n            System.out.println(l);\n    }\n}\n```\n\n```\n运行结果:\n2010-2-18\ntrue\n2015-4-15\n```\n从上面的程序可以看出，在java中对日期的操作是非常强大的，可以根据自己的需求来慢慢进行设置，在上面我也给出了对于日期类的归属。\n\n\n```\nimport java.time.*;\nimport java.time.format.*;\npublic class Test{\n    public static void main(String aegs[]){\n            LocalDate localdate=LocalDate.now();//获取当前日期\n            DateTimeForMatter datetime=DateTimeForMatter.ofPattern(\"dd/mm/uuuu\");//设置日期打印的格式\n            String str=localdate.ofmat(datetime);//把当期日期放在设置好的日期格式\n            System.out.println(str);//打印出来\n    }\n}\n```\n\n```\n运行结果:\n自己尝试了，仆街。\n```\n\n在java中，设置日期的格式是用过DateTimeForMatter类来设置格式的，然后把时间放在设置好的格式里，最后通过String类来进行打印出来。\n\n# 正则\n\n|正则标识符|意义|\n|----------|----|\n|\\ |表示一位字符|\n|\\\\|表示多位字符|\n|\\n|匹配换行|\n|[abc]|a,b,c中的任意一位|\n|[^abc]|表示不是abc中的任意一位|\n|[a-zA-Z]|表示任意一位字母(不管大小写)|\n|[0-9]|表示0-9任意一位|\n|.|表示任意一位字符|\n|\\d|等价与0-9|\n|\\D|等价与[^0-9]|\n|\\s|表示一位空格|\n|\\S|表示非空格|\n|\\w|等价与[a-zA-Z0-9]|\n|\\W|等价与[^a-zA-Z0-9]|\n|^|表示正则的开头|\n|$|表示正则的结尾|\n\n```\npublic class Test{\n    public static void main(Strng args[]){\n        if(\"123\".matches\"\\\\d+\"){\n            System.out.println(\"true\");\n        }else{\n        System.out.println(\"false\");\n        }\n        String s=\"1234@163.com\";//给出字符串\n        String s1=\"\\\\w+@\\\\w+.\\\\w+\";//给出邮箱的格式(w:等价于[a-zA-Z0-9])\n        System.out.println(s.matches(s1));//验证上面的邮箱格式\n    }\n}\n```\n\n```\n运行结果:\ntrue\ntrue\n```\n\n上面的程序是通过正则来判断并输出结果的，上面的方法是正则类里的一个方法，意思是判断字符串是不是由数字组成的，是就输出true，不是就false，明显与结果是一样的。\n|方法|意义|\n|----|----|\n|boolean matches(String test)|将字符与给出的正则表达式进行匹配验证|\n|String replaceAll(String test,String replacement)|按照指定的正则进行替换|\n|String replzceFirst(String test,String replacement)|按照指定的正则进行替换首个|\n\n```\npublic class Test{\n    public static void main(String args[]){\n            String s=\"123abcd3546efg\";\n            String s1=\"\\\\d+\";多个数字\n            System.out.println(s.replaceAll(s1,\"\"));//在字符串中替换数字\n            System.out.println(s.replaceFirst(s1,\"\"));//在字符串中替换首个字符前数字\n\n    }\n}\n```\n\n```\n运行结果:\nabcdefg\nabcd3546efg\n```\n\n在上面我给出的正则表达式的表示符可以在这个程序里尽情的尝试，你也会有发现的，但重要的是对你的理解有帮助,这样学起来是理解性的学习而不是一味的烦躁。\n\nBigDecimal(大数值)\n----\n\n```\nimport java.math.BigDecimal;\npublic class Test{\n    public static void main(String args[]){\n            BigDecimal b=new BigDecimal(\"3456789101112\")\n            BigDecimal b1=new BigDecimal(\"123456789\");\n            System.out.println(b.add(b1));//加法\n            System.out.println(b.subtract(b1));//减法\n            System.out.println(b.multipy(b1));//乘法\n            System.out.println(b.multipy(b1).setScale(1,BigDecimal.ROUND_up));//乘法,但是以进一的形式来输出值\n            System.out.println(b.divide(b1,BigDecimal.ROUND_DOWN));//除法\n            BigDecimal b2[]=b.divideAndRemainder(b1);//除法，并把值放在数组里面\n            System.out.println(\"商\"+b2[0]+\"余\"+b2[1]);\n    }\n}\n\n```\n\n上面的程序主要是应对于大的数字，在int和long都无法容纳的时候就使用BigDecimal类型来进行操作，(结果自己动手)\n\n**当需要在ArrayList和HashMap中放东西的时候,你在这个时候使用基本数据类型是不能放进去的，因为容器里面都是放** <++>\n","slug":"Java","published":1,"updated":"2019-11-25T01:28:40.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3drdiqo0000d2z76ptg0pj0","content":"<p><img src=\"//evanshady.github.io/2019/09/19/Java/java0.png\" alt=\"终端运行的结果\"> </p>\n<p>Write Once,Run Everywhere<br> <a id=\"more\"></a></p>\n<p> <strong>达到对面向对象编程思想更加深入的理解，是对面向对象的各种特性及其实现细节更加熟练的掌握。</strong> </p>\n<hr>\n<p> <em>一步一个脚印的连好java的基本功。对于我来说是最好不过的，掌握java的基本语法。(类与对象，构造方法，引用传递，内部类，异常，包，java常用类库，javaIO，java类集)</em> </p>\n<ol>\n<li>走技术之路(在学习java的同时，把基础的知识打好一定的基础)</li>\n<li>定位成为技术类管理成员(掌握基础的java知识，还要有几年的工作经验)</li>\n<li>java软件开发发展前景好，移植性也很强。</li>\n</ol>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> JDK(java开发工具包)</li>\n</ul>\n<p><em>是编程语言和javaAPI类库和java虚拟机(是完成移植性的重要机制)来组成的</em> </p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> JRE(java运行时环境)<br><em>是javaAPI子集和java虚拟机组成</em> </li>\n</ul>\n<h2 id=\"前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。\"><a href=\"#前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。\" class=\"headerlink\" title=\"前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。 \"></a><strong>前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。</strong> </h2><h2 id=\"java系统可分为：javaEE-标准版-，javaSE-企业版-，javaME-微型版-，javaCARD-智能卡版\"><a href=\"#java系统可分为：javaEE-标准版-，javaSE-企业版-，javaME-微型版-，javaCARD-智能卡版\" class=\"headerlink\" title=\"java系统可分为：javaEE(标准版)，javaSE(企业版)，javaME(微型版)，javaCARD(智能卡版) \"></a><strong>java系统可分为：javaEE(标准版)，javaSE(企业版)，javaME(微型版)，javaCARD(智能卡版)</strong> </h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//有必要说明一下，接下来的是在linux系统下使用终端来让我电脑上的文件进行运行</span><br><span class=\"line\"></span><br><span class=\"line\">public class hello&#123;//public(公有访问类型),class(类的标识),hello(类名)</span><br><span class=\"line\">    public static void main (String arg[])&#123;//是main函数的基本格式,也表明main函数是静态方法</span><br><span class=\"line\">    System.out.println(&quot;hello,world!&quot;);//打印字符串&quot;hello,world!&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java0.png\" alt=\"终端运行的结果\"> </p>\n<hr>\n<p><strong>这里要注意一下的就是文件的后缀是.java,其次是以javac 来作为第一次的关键字来操作文件，接着就会生成一个后缀为.class的文件，然后就是运行你写的文件，记住后面没有任何的后缀。</strong> </p>\n<ul>\n<li><strong>java是面向对象的过程，也就是说在java中只有方法而没有所谓的函数。</strong> </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    scanner s=new scanner(System.in);//为了可以让用户输入，在这里使用了scanner类,因为它附属与System.in</span><br><span class=\"line\">    System.out.println(&quot;请输入你的性别&quot;);</span><br><span class=\"line\">    String set=s.nextLint();//以字符串的形式输入</span><br><span class=\"line\">    System.out.println(&quot;请输入你的姓名&quot;);</span><br><span class=\"line\">    String name =s.nextLint();</span><br><span class=\"line\">    switch(set)&#123;</span><br><span class=\"line\">    case &quot;男&quot;:</span><br><span class=\"line\">    System.out.println(name+&quot;男士&quot;);</span><br><span class=\"line\">    break;</span><br><span class=\"line\">    case &quot;女&quot;:</span><br><span class=\"line\">    System.out.println(name+&quot;女士&quot;);</span><br><span class=\"line\">    break;</span><br><span class=\"line\">    default :</span><br><span class=\"line\">    System.out.println(&quot;输入有误&quot;);</span><br><span class=\"line\">    break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.close();//关闭类</span><br><span class=\"line\">    InputStreamReader input=new InputStreamReader(System.in);//定义在键盘输入</span><br><span class=\"line\">    BufferedReader Buff=new BufferedReader(input);//以缓冲流的形式来接受input</span><br><span class=\"line\">    //用try和catch机制来处理异常</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">    System.out.println(&quot;请输入字符：&quot;);</span><br><span class=\"line\">    String s=Buff.readLine();</span><br><span class=\"line\">    System.out.println(&quot;字符：&quot;+s);</span><br><span class=\"line\">    &#125;catch (Exception e)&#123;</span><br><span class=\"line\">    System.out.println(&quot;异常&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java2.png\" alt=\"运行结果\"></p>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java1.png\" alt=\"输入的方式\"></p>\n<p><em>在这里只是简单的让用户输入了两次都是以字符串的方式来输入的，当然你也可以让用户输入你想让用户输入的数据类型(eg:int ,double)，上面也有参照的照片。</em> </p>\n<ul>\n<li><strong>合法的标识符</strong> </li>\n</ul>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 不能存在关键字</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 首字母不能是数字</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 不能存在运算符</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 标识符是区别大小写的</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 标识符的命令规则是强制性的</li>\n</ul>\n<p><code>我们都知道数据的类型有int,short,float,double,byte(字节)。最常见的就是int(整形的数据类型)。在java中我们可以通过程序来输出各个数据类型的范围是多少，最大值和最小值，和数据类型</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main (String args[])&#123;</span><br><span class=\"line\">    int a=Integer.Size;</span><br><span class=\"line\">    System.out.println(&quot;int的范围:&quot;+a);</span><br><span class=\"line\">    int b=Integer.MAX_VALUE;</span><br><span class=\"line\">    System.out.println(&quot;int的最大值:&quot;+b);</span><br><span class=\"line\">    int c=Integer.MIN_VALUE</span><br><span class=\"line\">    System.out.println(&quot;int的最小值:&quot;+c);</span><br><span class=\"line\">    Class &lt;Integer&gt; d=Integer.TYPE;</span><br><span class=\"line\">    System.out.println(&quot;数据类型:&quot;+d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果：</span><br><span class=\"line\">int的范围:32</span><br><span class=\"line\">int的最大值:2147483647</span><br><span class=\"line\">int的最小值:-2147483648</span><br><span class=\"line\">数据类型:int</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">            static int i=10;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">            int a=1;</span><br><span class=\"line\">            int b=2;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            int b=3;//main方法的变量名是不可以重复的，一个变量只能使用一个名，在这里就是重复使用了变量b，所以程序会报错。</span><br><span class=\"line\">            System.out.println(&quot;b=&quot;+b);</span><br><span class=\"line\">            System.out.println(&quot;a=&quot;+a);</span><br><span class=\"line\">            System.out.println(&quot;i=&quot;+i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;b=&quot;+b);</span><br><span class=\"line\">            System.out.println(&quot;a=&quot;+a);</span><br><span class=\"line\">            System.out.println(&quot;i=&quot;+i);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面的程序是运行不过的，这也是java的特别之处，在c++中，变量b是可以用的，但在java中是不可以的。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main (String args[])&#123;</span><br><span class=\"line\">            char ch = &apos;\\&quot;&apos;;//转义字符</span><br><span class=\"line\">            System.out.println(ch);</span><br><span class=\"line\">            System.out.println(&quot;\\&quot;hello,world!&quot;\\&quot;);</span><br><span class=\"line\">            System.out.println(ch+&quot;hello,world!&quot;+ch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">&quot;</span><br><span class=\"line\">&quot;hello,world!&quot;</span><br><span class=\"line\">&quot;hello,world!&quot;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><code>总结可以得知，不管是用变量来存放转义字符，还是直接使用转义字符的方式来输出字符，程序都是可以顺利运行的，当然你也可以不使用变量来存放转义字符，但一个程序里面有太多的转义字符的存在你用变量来存放不是更好使用？这样你也不容易搞混已有的转义字符的使用。</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">        System.out.println(2+3+&quot;k&quot;);</span><br><span class=\"line\">        System.out.println(6+6+&quot;aa&quot;+6+6);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">5k</span><br><span class=\"line\">12aa66</span><br></pre></td></tr></table></figure>\n<hr>\n<p><code>上面的2+3是一个表达式，所以这里是5,但后面跟的是字符和+(字符串相加)的符号，所以是5k,下面的也是一样的，唯一不一样的是在+(字符串相加)之后，计算机会自动认为后面的也是+(字符串相加)所以后面的就是12aa66。但如果把上面的双引号换成单引号就是以数字的形式先加后输出的。</code> </p>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>import java.util.Randow;//随机数字的包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">                int i=3;//这是在堆内存的分配的内存(也可以说是在编译是分配的),读取速度快，但数据的活动范围小(缺少灵活性)</span><br><span class=\"line\">                int y=new Integer(1);//是在栈内存分配的内存(也可以说是运行时分配的内存),读取速度慢，但数据灵活性高。</span><br><span class=\"line\">                System.out.println((int)(Math.randow()*10));//生成随机数字，0～10</span><br><span class=\"line\">                Randow rand=new Randow();</span><br><span class=\"line\">                int i=rand.nextInt(10);//随机生成0～10的数字</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>import java.util.Randow;//导入随机数字的包<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">            Randow rand=new Randow();//声明随机数字的对象</span><br><span class=\"line\">            int []numb=new int [rand.nextInt(10)];//rand.nextInt(10)这句话的意思是随机生成一个0～10的数字作为数组的长度</span><br><span class=\"line\">            for(int i=0;i&lt;numb.length;i++)&#123;//为数组赋值。从0～100来选择每次的赋值的数值</span><br><span class=\"line\">                numb[i]=rand.nextInt(100);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for(int a : numb)&#123;//打印数组里的元素</span><br><span class=\"line\">            System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>在c++中的指针，在java是叫做引用数据类型，相当与c++中的地址指针</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    Randow rand=new Randow();//声明随机数字的对象</span><br><span class=\"line\">    int []a=new int[rand.nextInt(10)];//定义数组长度</span><br><span class=\"line\">    int []b=a;//把数组a赋值给数组b</span><br><span class=\"line\">    for(int i=0;i&lt;a.length;i++)&#123;//为数组a赋值</span><br><span class=\"line\">            a[i]=rand.nextInt(100);</span><br><span class=\"line\">            System.out.println(a[i]);</span><br><span class=\"line\">            System.out.println(b[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>上面程序的结果每次都是不要的，但值得注意的是输出的结果，肯定不会让你们失望的，因为数组b里面的元素是和数组a的元素是一样的。其实，上面最重要的一点就是数组b=数组a，它的等于是连着后面的a数组的赋值。</code> </p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">            Randow rand=new Randow();</span><br><span class=\"line\">            int [][]numb=new int[3][1];//声明数组numb和给数组长度</span><br><span class=\"line\">            for(int i=0;i&lt;numb.length;i++)&#123;//给数组赋值并输出数组里的元素</span><br><span class=\"line\">                for(int j=0;j&lt;numb[i].length;j++)&#123;</span><br><span class=\"line\">                        numb[i][j]=rand.nextInt(10);</span><br><span class=\"line\">                        System.out.println(numb[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>一样的，上面的数组每运行一次程序的结果都是不一样的。</code> </p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">    public static void main(String args)&#123;</span><br><span class=\"line\">            int []numb=new int[]&#123;10,23,41,6,11&#125;;//声明一个数组，并赋初值</span><br><span class=\"line\">            int a=Randow rand=new Randow(3)+1;//生成随机数字，范围是1～4</span><br><span class=\"line\">            for(int i=0;i&lt;a;i++)&#123;//把随机数字的大小作为条件,并从一开始交换位置</span><br><span class=\"line\">                int temp=numb[i];</span><br><span class=\"line\">                numb[i]=numb[i+1];</span><br><span class=\"line\">                numb[i+1]=temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for(int b:numb)&#123;//输出数组里的元素</span><br><span class=\"line\">            System.out.println(b);,你在这个时候使用基本数据类型是不能放进去的，因为容器里面都是放            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>上面程序实现的是乱序，就是每次输出的结果都是不一样的。</code> </p>\n<hr>\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><p><strong>类描述了对象的属性和对象的方法，类是对象的模板，更可以说，对象是类的实例，是一个实实在在存在的个体。所以说，面向对象的程序重要的是类的设计而不是对象的设计。</strong><br><code>类的声明格式:</code> </p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> [标识符] class 类的名称<br>{<pre><code>//类的属性\n//类的方法\n</code></pre>}<br><code>类的标识符:</code> </li>\n<li><p>[ ] 默认的(default):这个类只能被这个类的对象和同一个包中的其它的类访问，即使是其它包里的这个类的子类都不能被访问，它只认同一包里的类。</p>\n</li>\n<li><p>[ ] 私有(private):如果一个方法或者属性被定义为私有的，那么只能在本类里访问它。</p>\n</li>\n<li><p>[ ] 公有(public):如果一个方法或属性被定义为公有的，那么它不仅能跨类的对象所调用，还能在其它包中被访问。</p>\n</li>\n<li><p>[ ] 保护(protected):如果一个方法或属性被定义为保护的，那么它能被本类的方法所访问，也能被子类所访问，即使子类在其它包里。</p>\n</li>\n</ul>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java3.png\" alt=\"java访问机制\"> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main (String args[])&#123;</span><br><span class=\"line\">            System.out.println(&quot;------&quot;创建对象&quot;-------&quot;);</span><br><span class=\"line\">            new Apple();//匿名对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Apple&#123;</span><br><span class=\"line\">        static String a=&quot;string-a&quot;;</span><br><span class=\"line\">        Static String b;</span><br><span class=\"line\">        String c=&quot;string-c&quot;;</span><br><span class=\"line\">        Strint d;</span><br><span class=\"line\">        Static&#123;//static 属于静态代码块，最先运行的是这段代码块，而不是类的构造函数先</span><br><span class=\"line\">                printstatic(&quot;before static&quot;);</span><br><span class=\"line\">                b=&quot;string-b&quot;;</span><br><span class=\"line\">                printstatic(&quot;after static&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static void printstatic(String name)&#123;//这里要加静态的关键字，因为调用是静态来的所以这里也要有静态的关键字来表明这里是静态，不然是会报错的。</span><br><span class=\"line\">                System.out.println(&quot;------&quot;+name+&quot;-------&quot;);</span><br><span class=\"line\">                System.out.println(&quot;a=&quot;+a);</span><br><span class=\"line\">                System.out.println(&quot;b=&quot;+b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Apple()&#123;</span><br><span class=\"line\">            print(&quot;before class&quot;);</span><br><span class=\"line\">            d=&quot;string-d&quot;;</span><br><span class=\"line\">            print(&quot;after class&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        void print()&#123;</span><br><span class=\"line\">                System.out.println(&quot;------&quot;+name+&quot;-------&quot;);</span><br><span class=\"line\">                System.out.println(&quot;a=&quot;+a);</span><br><span class=\"line\">                System.out.println(&quot;b=&quot;+b);</span><br><span class=\"line\">                System.out.println(&quot;c=&quot;+c);</span><br><span class=\"line\">                System.out.println(&quot;d=&quot;+d);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java4.png\" alt=\"运行结果\"> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面的对象是经过匿名对象来实例化的，也就是没有给new的对象一个堆内存，一旦这句语句实现完，计算机会自动回收这个内存，将不再存在程序里，这也是java的垃圾回收机制(BC)，这也是为我们考虑的，不知道你有没有发现，上面的几个程序我都是用new来给类分配的对象，但我不但没有在类中写析构函数，也没有在main函数里delete对象的实例化。因为这一切都是java的BC机制帮我们做了。</span><br></pre></td></tr></table></figure>\n<p>public class Test{</p>\n<pre><code>public static void main(String args[]){\n        String name=new String (&quot;java&quot;);\n        String _name=new String (&quot;java&quot;);\n        String hua=_name;\n        if(name==_name){\n        System.out.println(&quot;地址相同&quot;);\n        }else{\n        System.out.println(&quot;地址不同&quot;);\n        }\n        if(name.equals(_name)){\n        System.out.println(&quot;内容相同&quot;);\n        }else{\n        System.out.println(&quot;内容不同&quot;);\n        }\n</code></pre><p>}<br>运行结果:<br>地址不同<br>内容相同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序分别实现了字符串地址(==)和字符串内容(equals方法)的比较，第一个变量和第二个变量的是经过new来分配的栈内存的地址，所以输出的是地址不相同,而最后一个的是进行的内容比较，因为初始化的原因，这里也是输出的内容相同。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">构造方法的注意事项</span><br><span class=\"line\">- [ ] 构造方法的名称与类的名称是一样的</span><br><span class=\"line\">- [ ] 构造方法也是和普通方法一样的，可以被重载，但构造方法的调用是通过在创建类的对象的时候自动调用的，这是与普通方法的调用是不一样的</span><br><span class=\"line\">- [ ] 构造方法是没有返回值的</span><br><span class=\"line\">- [ ] 构造方法是不能被static和final修饰的</span><br><span class=\"line\">- [ ] 构造方法是不能被继承的，如果子类要使用父类的构造方法只能使用关键字(super)来进行调用</span><br></pre></td></tr></table></figure></p>\n<p>public Test{</p>\n<pre><code>private String name;\nTest(){\nSystem.out.println(&quot;类的无参构造方法的调用&quot;);\n}\nTest(String _name){\n    this-&gt;name=_name;\n    System.out.println(&quot;类的有参构造方法的调用&quot;);\n}\npublic static void main(String args[]){\n        new Test();//这是匿名调用类的构造方法\n        Test test=new Test();//这和上面是等价的\n        Test t1=new Test(&quot;小明&quot;);\n}\n</code></pre><p>}</p>\n<p>上面的程序做的只是简单的演示类的构造方法的重载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    Apple apple;</span><br><span class=\"line\">    apple=Apple.V();</span><br><span class=\"line\">    System.out.println(&quot;姓名:&quot;+apple.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Apple&#123;</span><br><span class=\"line\">        String name;</span><br><span class=\"line\">        private Apple ()&#123;</span><br><span class=\"line\">        name=&quot;hello&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        private static final Apple APPLE=new Apple();</span><br><span class=\"line\">        public static V()&#123;</span><br><span class=\"line\">        return APPLE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的程序的重要性是:当你不想一个类被频繁调用的是时候，可以通过对类的构造方法的私有化来实现</p>\n<h1 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h1><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 普通代码块(就是普通的放在Main方法里面的代码块)</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 构造代码块(放在类里面，比构造方法更先一步执行的代码块)</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 静态代码块(比构造代码块更快一步，如果和Main方法是放在同一个类的话，那它比Main方法更快一步执行)</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 同步代码块</li>\n</ul>\n<blockquote>\n<p>普通代码块</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">        public static void main(String args[])&#123;</span><br><span class=\"line\">        &#123;int x=10;//普通代码块</span><br><span class=\"line\">        System.out.println(&quot;x&quot;);</span><br><span class=\"line\">        &#125;//如果不要这个代码块，程序将会报错，因为在一个方法里，不能有同名的变量名</span><br><span class=\"line\">        int x=100;</span><br><span class=\"line\">        System.out.println(&quot;x&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果为:</span><br><span class=\"line\">10</span><br><span class=\"line\">100</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>构造代码块</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">           Peron p=new peron(); </span><br><span class=\"line\">           Peron p1=new Peron(&quot;笑话&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Peron&#123;</span><br><span class=\"line\">    private int x;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    System.out.println(&quot;构造代码块的调用&quot;);//这是构造代码块</span><br><span class=\"line\">    x=10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Peron()&#123;</span><br><span class=\"line\">        System.out.println(&quot;类的无参构造方法的调用\\t&quot;+x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Peron(String _name)&#123;</span><br><span class=\"line\">    this-&gt;name=_name;</span><br><span class=\"line\">    System.out.println(&quot;类的有参构造方法的调用\\t&quot;+x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序的运行结果为:</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    类的无参构造方法的调用  10</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    类的有参构造方法的调用  10</span><br></pre></td></tr></table></figure>\n<p>上面类中是有一块属于构造代码块，而它的速度比构造方法的调用都还快，以前我们只知道对于类来说，构造方法是第一个调用的，因为在我们声明类的对象的时候就是通过类的构造方法来实现的，但现在不一样的是，你只要在类中加个中括号({}),里面的代码实现比类的构造方法都还要快被实现，这使得我们的代码更简化一步。比如，就像上面一样，给一个成员变量复制，而不是通过它的构造方法来实现，你只需要定义一个变量，然后再加个({}),就能实现对成员变量的复制，速度还比类的构造方法快一布。</p>\n<p><strong>由此我们可以知道，类的代码块中的初始化是一个类的所有构造方法都共有的“交集”部分，具有个性化的初始化还是要放在各自的构造方法里</strong> </p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>静态代码块</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">    System.out.println(&quot;静态方法的调用&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    System.out.println(&quot;构造代码块的调用&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Test()&#123;</span><br><span class=\"line\">    System.out.println(&quot;构造方法的调用&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">            System.out.println(&quot;创建第1个对象&quot;);</span><br><span class=\"line\">            new Test();</span><br><span class=\"line\">            System.out.println(&quot;创建第1个对象&quot;);</span><br><span class=\"line\">            new Test();</span><br><span class=\"line\">            System.out.println(&quot;创建第1个对象&quot;);</span><br><span class=\"line\">            new Test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序的运行结果为:</span><br><span class=\"line\">    静态代码块的调用</span><br><span class=\"line\">    创建第1个对象</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    构造方法的调用</span><br><span class=\"line\">    创建第2个对象</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    构造方法的调用</span><br><span class=\"line\">    创建第3个对象</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    构造方法的调用</span><br></pre></td></tr></table></figure>\n<p><strong>从上面的案例可以看出来，在执行时机上，静态代码块是在类加载的时候就会执行的，因为早于类的构造代码块和类的构造方法。当一个静态代码块和Main方法在同一个类中，Main方法的调用也是在静态代码块的后面的。静态代码块的执行级别是最高的。</strong>    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static int [] show(int []numb)&#123;</span><br><span class=\"line\">        numb[0]=10;</span><br><span class=\"line\">        numb[1]=12;</span><br><span class=\"line\">        numb[2]=13;</span><br><span class=\"line\">        return numb;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void show1(int []numb)&#123;</span><br><span class=\"line\">        for(int i:numb)&#123;</span><br><span class=\"line\">        System.out.print(i+&quot;\\t&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        public static void main(String args[])&#123;</span><br><span class=\"line\">            int [] numb =new int&#123;1,2,3,4,5&#125;;</span><br><span class=\"line\">            for(int i:numb)&#123;</span><br><span class=\"line\">            System.out.print(i+&quot;\\t&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">            System.out.println(&quot;--------------&quot;);</span><br><span class=\"line\">            show(numb);</span><br><span class=\"line\">            Show1(numb);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序的运行结果为:</span><br><span class=\"line\">1 2 3 4 5 </span><br><span class=\"line\">10 11 12 4 5</span><br></pre></td></tr></table></figure>\n<p><code>上面的程序只是简单的利用java的特性用新的方式来打印数组，只需要一个变量来操作数组对象就行了，比我们之前在c++中的方式简便多了，也是代码的量也减少了，这无疑是一件好事，还利用了引用数据类型来实现对数组的操作，更加利用了静态方法来进行对数组里的元素更改。</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.*//导入sort包</span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    int []numb=&#123;10,2,46,33,5&#125;;</span><br><span class=\"line\">    Arrays.sort(numb);//进行数组的排序</span><br><span class=\"line\">    System.out.println(&quot;排序后:&quot;);</span><br><span class=\"line\">    for(int i:numb)&#123;</span><br><span class=\"line\">    System.out.print(i+&quot;\\t&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>程序的运行结果为:<br>排序后:<br>2 5 10 33 46<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 枚举(enum)</span><br><span class=\"line\">`enum A&#123;红色，黄色，白色&#125;枚举是作为类来被调用的，在定义的同时是连着对象的构造方法一起被调用的`</span><br></pre></td></tr></table></figure></p>\n<p>enum Cloro{红色，黄色，白色}//是枚举的关键字,定义了一个枚举并初始化了<br>public class Test{<br>    public static void main(String args[]){<br>            //java中的枚举其实是一个类来的，在这个类里面还有很多不一样的方法，其作用都是不一样的。<br>            Cloro []cloro=Cloro.values();//Cloro.values()是类的静态方法来的，但是以字符串的形式来的，所以在前面要定义一个同类型的数组来接收,方法是自动生成的<br>            for(Cloro i:cloro){<br>            System.out.println(i);<br>            }<br>            Cloro c=Cloro.valueof(Cloro.class,”白色”);//以指定的颜色来赋给对象,这里的参数有点不一样的就是，参数是类的类型,方法是自动生成的<br>            System.out.println(c);</p>\n<pre><code>}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>红色<br>黄色<br>白色<br>白色<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">枚举的注意事项</span><br><span class=\"line\">- [ ] 如果把枚举的标识符定义为public的话要放在独立的文件里面而不能和main方法放在同一个文件，如果标识符是默认的话就可以放在同一个文件里</span><br><span class=\"line\">- [ ] 使用enum来定义枚举的时候，默认会继承于java.lang.Enum类。默认会用final来修饰，因此无法派生子类。</span><br><span class=\"line\">- [ ] 使用enum来定义的时候，初始化也要和定义一起,如果没有把赋值放在同一行，而这个enum将无法被实例法。</span><br><span class=\"line\">- [ ] 所以使用enum来定义枚举的时候都会默认生成values方法，该方法可以方便遍历所有枚举值，而在枚举中还是有其它的自动生成的方法来给我们使用。</span><br><span class=\"line\"></span><br><span class=\"line\">**enum(枚举)用关键字定义的时候相当于定义了一个类，而这个类继承于Enum类。而在Enum类中的所有方法都是保护类型的，因此这些方法都可以在声明了enum对象中被使用。**</span><br></pre></td></tr></table></figure></p>\n<p>enum A{红色，紫色，白色}<br>public class Test{<br>    public static void main(String args[]){<br>            A []a=A.valuse();//把枚举中的元素都放在对应类型的数组中<br>            for(A i:a){<br>            System.out.println(i.name+i.ordinal());输出的是数组中的元素和数组的下标<br>            }<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>红色0<br>紫色1<br>白色3<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`在枚举中的下表要是没有给定提定的数值，计算机就会自动给它一个下标，而下标的值是以数组的形式来赋值的。` </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`EnumMap是Map接口的子类，也就是说Enummap是继承于类Map的`</span><br></pre></td></tr></table></figure></p>\n<p>import java.util.Map;//导包<br>import java.util.EnumMap;//导包<br>enum Color{红色，黄色，绿色}<br>public class Test{<br>    public static void main(String args[]){<br>        EnumMap&lt;Color,String&gt;emap=new EnumMap&lt;Color,String&gt;(Color.class);//映射&lt;&gt;&lt;KeyType,nameType&gt;,更重要的是EnumMap的构造方法的参数不能为空，需要指定一个枚举类<br>        emap.put(Color.红色,”RED”);//把映射的对象和值都写进去<br>        emap.put(Color.黄色,”YELLOW”);<br>        emap.put(Color.绿色,”BLUE”);<br>        for(Map.Entry&lt;Color,String&gt;me:emap.entrySet()){//把映射的键和值都打印出来,其中的两个方法是Map中的静态方法，EnumMap作为Map的子类所以能调用其中的方法。<br>        System.out.println(me.getKey()+me.getValue());<br>        }<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>红色RED<br>黄色YELLOW<br>绿色BLUE<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的打印用的是新的打印方法，而EnumMap的类型是Map来的，所以它要Map.来点出它的方法来进行打印,Key是不允许重复的，而它的值却允许重复，EnumSet是一个集合来的</span><br></pre></td></tr></table></figure></p>\n<p>import java.util.EnumSet;//导包<br>import java.util.Iterator;//导包<br>enum Color{红色，绿色，紫色}<br>public class Test{<br>    public static void main(String args[]){<br>        EnumSet<color> set=EnumSet.allof(Color.class);//声明集合<enumtepy>并把对应类型的枚举类放在集合中,allof是集合EnumSet中的静态方法，用来把参数中的枚举类放在集合中作为集合的元素<br>        Iterator <color>iter=set.iterator();//声明迭代器并把集合放在迭代器中<br>        while(iter.hasNext()){//参数是确认迭代器中的元素是否为空,为空的时候返回false<br>        System.out.println(iter.Next());//打印迭代器中的元素<br>        }<br>        EnumSet <color>aset=EnumSet.noneof(Color.class);//表示作为空的集合<br>    }<br>    Iterator iterator=aset.iterator();<br>    while(iterator.hasNext()){<br>    System.out.println(iterator.Next());//这里是打印不出来的，所以下面的结果为空<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></color></color></enumtepy></color></p>\n<p>运行结果:<br>红色<br>绿色<br>紫色<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>enum Color{<br>    RED(“红色”,3),BLUE(“蓝色”,4),YELLOW(“黄色”,5);//定义枚举并指定颜色和下标，是以私有构造方法来显示调用枚举类的属性，(也就是说成员)<br>    private String Name;//元素的名字<br>    private int Indext;//元素的下标<br>    private Color(String name,int indexc){//枚举类的构造方法是私有化的,所有的枚举对象都必须显示调用此构造方法。<br>            this-&gt;Name=name;<br>            this-&gt;Indext=indexc;<br>    }<br>    public static void setname(int indexc,String name){<br>        for(Color c:Color.values()){<br>            if(c.Indexc==indexc){<br>            c.Name=name;<br>            }<br>        }<br>    }<br>    public static void setindexc(String name,int indexc){<br>        for(Color c:Color.values()){<br>            if(c.Name==name){<br>            c.Indexc=indexc;<br>            }<br>        }<br>    }<br>    public String getname(String name){<br>    return name;<br>    }<br>    public int getindexc(int intexc){<br>    return intexc;<br>    }</p>\n<p>}<br>public class Test{<br>    public static void main(String args[]){<br>        System.out.println(Color.RED.getname());//RED是枚举类型的Color的枚举实例。这些枚举实例是公有的静态对象(进一步说，它们可以视为枚举类的属性成员)<br>        System.out.println(Color.RED.getindexc());<br>        System.out.println(Color.BLUE.getname());<br>        System.out.println(Color.BLUE.getindexc());<br>        System.out.println(Color.YELLOW.getname());<br>        System.out.println(Color.YELLOW.getindexc());<br>        System.out.println(“自定义元素”);<br>        Color.setname(3,”白色”);//通过属性下标来改变属性的名字<br>        System.out.println(Color.RED.getname());<br>        System.out.println(Color.RED.getindexc());<br>        Color.setindexc(“黄色”,7);//通过属性的名字来改变属性的下标<br>        System.out.println(Color.YELLOW.getname());<br>        System.out.println(Color.YELLOW.getindexc());<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>红色<br>3<br>蓝色<br>4<br>黄色<br>5<br>白色<br>3<br>黄色<br>7</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在上面的程序中都是通过私有的构造方法来显示调用成员属性的，在上面属性其实是RED,BLUE,YELLOW,只不过我在这里都没对它操作，在这里比较容易混淆的是，根本不明白谁才是枚举的成员属性，你也可以通过上面的Values()(是枚举类自动生成的用来遍历枚举属性的方法),其实在上面我也用到了这个方法来对成员属性的名字和下标来进行改变它们对应的值。在最开始的时候定义的枚举的属性其实是在调用私有构造方法来实现实例化。只要把这个搞懂了，其实那些改变成员属性的方法都是很简单理解的。</span><br></pre></td></tr></table></figure>\n<p>enum Color{<br>    红色<br>    {<br>        public String show(){<br>            return “RED”;<br>        }<br>    },<br>    蓝色<br>    {<br>        public String show(){<br>            return “BLUE”;<br>        }<br>    },<br>    黄色<br>    {<br>        public String show(){<br>            return “YELLOW”;<br>        }<br>    };<br>    public abstract String show();//把上面的show方法定义为抽象方法(abstract)抽象关键字</p>\n<p>}<br>public class Test{<br>    public static void main(String args[]){</p>\n<pre><code>    for(Color c:Color.values){\n    System.out.println(c.ordinal+&quot;\\t&quot;+c.name()+&quot;----&quot;+c.show());\n    }\n}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>0  红色—-RED<br>1  蓝色—-BLUE<br>2  黄色—-YELLOW<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">抽象方法关键字(abstract)，修饰没有主体的方法，在这里需要在枚举对象中一一单独实现，否则报</span><br></pre></td></tr></table></figure></p>\n<p>enum Weekday {Sun,Mon,Tue}<br>public class Test{<br>    public static void main(String args[]){<br>            Weekday w=Weekday.Sun;<br>            switch(w){<br>                case Mon:<br>                System.out.println(Do Monday work);<br>                case Sun:<br>                System.out.println(Do Sunday work);<br>            }<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>Do Sunday work<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里是当你定义的是枚举类中的哪个元素的对象的时候，通过switch来进行选择，你输出的语句是你在switch写的语句。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 类</span><br><span class=\"line\">|控制范围|private|default|protected|public|</span><br><span class=\"line\">|----|----|----|----|----|</span><br><span class=\"line\">|类|只能内部类允许私有，只能在当前类被访问|可以被当前包中的所有类访问|只有在内部类可以被设为保护权限,相同包中的类和其子类可以被访问|可以被所有类访问|</span><br><span class=\"line\">|属性|只能被当前类访问|可以被相同包中的类访问|可以被当前包中的所有类访问和当前类的子类访问|可以被所有类访问|</span><br><span class=\"line\">|方法|只能被当前类访问|可以被相同包中的类访问|可以被相同包中的类访问和当前类的子类访问|可以被所有类访问|</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`java中对于类来说有封装，继承，多态。` </span><br><span class=\"line\"></span><br><span class=\"line\">`java中类的成员变量的权限有私有，公有，保护，默认，在上面的表格中都给出了对应的权限范围，java类只有允许单继承不允许多继承，但允许多重继承，`</span><br></pre></td></tr></table></figure></p>\n<p>import java.util.ArrayList;<br>public class Test{<br>    public static void main(String args[]){<br>    System.out.println(“集合大小”);<br>    Apple a=new Apple();//调用类的构造方法来实现对集合的操作<br>    ArrayList <interger>array=a.getarray();//声明一个集合来对类中的公有方法中的返回值进行赋值给这个集合,很重要的是，在这里传的是引用而不是数据的副本。<br>    System.out.println(array.size());//打印集合的大小<br>    array.add(8);//对集合的引用进行加值的操作<br>    Arrjy <interger>a1=a.getarray();又重新定义一个集合来对调用的类的公有方法的返回值进行赋值<br>    System.out.println(a1.size());//打印集合的大小<br>    System.out.println(“集合元素”);<br>    for(Interger i:a1){<br>    System.out.println(i);<br>    }</interger></interger></p>\n<pre><code>}\n</code></pre><p>}<br>class Apple{<br>        private ArrayList<interger>array=new ArrayList<interger>();//声明一个私有集合作为类的成员变量<br>        Apple(){//构造方法,对集合进行初始化<br>        array.add(1);<br>        array.add(1);<br>        array.add(1);<br>        }<br>        ArrayList<interger>getarray(){//返回集合<br>        return array;<br>        }</interger></interger></interger></p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>集合大小<br>3<br>4<br>集合元素<br>1<br>1<br>1<br>8<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**其实在上面的程序中最难懂的是，在main方法里的集合的操作是引用的操作而不是简单的副本操作，在java中，除了基本的数据类型，其它都是引用类型,其中类也是引用类型** </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">关于继承的限制</span><br><span class=\"line\">- [ ] java中继承允许多继承，但也许多重继承</span><br><span class=\"line\">- [ ] 从父类继承的私有成员不能被子类直接使用，要通过方法来间接调用</span><br><span class=\"line\">- [ ] 子类在进行对象实例化的时候，先调用父类的构造方法对父类的成员变量进行赋值，然后在调用子类的构造方法，其作用是一样的。</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void mai(String args[]){</p>\n<pre><code>}\n</code></pre><p>}<br>final class A{<br>    final void show(){<br>    System.out.println(“如果这个方法在不想被子类覆写，可以在方法前面加上这个修饰符来确定不被子类覆写”);<br>    }</p>\n<p>}<br>//class B extends A{}//是错误的,所以注释掉<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序是不行的，因为父类的修饰符是final，它是不能被继承的</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>        A a=new B();<br>        a.show();<br>    }<br>}<br>class A {<br>    A(){<br>    System.out.println(“父类的构造方法”)<br>    }<br>    void show(){<br>        System.out.println(“走”);<br>    }<br>}<br>class B extends A{<br>    B(){<br>    System.out.println(“子类的构造方法<br>    }<br>    void show(){<br>        System.out.println(“飞”);<br>    }<br>}<br>class C extends A{<br>    C(){<br>        System.out.println(“子类的构造方法<br>}<br>    void show(){<br>        System.out.println(“跑”);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>父类的构造方法<br>子类的构造方法<br>飞<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序主要是实现多态的重要性，还有就是继承的小细节，继承是先调用父类的构造方法之后再调用子类的构造方法。在刚开始的时候就写过了在上面是先声明一个父类对象来进行对子类的实例化，然后在调用子类中覆写父类成员方法的方法，其实你也完全可以通过子类的对象来对子类进行实例化，在这里主要是实现类的多态。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">方法重载与覆写的区别</span><br><span class=\"line\">- [ ] 重载是在本类中实现的，而覆写主要是在子类中重写父类的方法</span><br><span class=\"line\">- [ ] 重载要求方法的参数个数和参数类型的顺序和参数的类型和方法名字，其中的任意一个不同。而覆写是方法名称和参数个数和类型与父类是一致的就行了</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`this&amp;&amp;super` </span><br><span class=\"line\">----</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            B b=new B();<br>            b.show();<br>    }<br>}<br>class A{<br>        String name;<br>        void show(){<br>        this-&gt;name=”java”;<br>        }<br>}<br>class B extends A{<br>    String name;<br>    void show(){<br>        this-&gt;name=”shanghai”;<br>        super.show();<br>        System.out.println(name+”\\t”+super.name);<br>    }<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果:<br>shanghai  java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">|区别|this|super|</span><br><span class=\"line\">|----|----|-----|</span><br><span class=\"line\">|查找范围|先从本类中找到属性或方法，本类找不到再去父类寻找|不查询父类的属性或方法，直接从子类调用父类的指定属性和方法|</span><br><span class=\"line\">|调用构造|this使用的是本类的构造|super先调用的是父类的构造方法，然后在调用子类的构造方法|</span><br><span class=\"line\">|特殊|表示当前的对象|可以看作是父类的引用对象|</span><br><span class=\"line\">|关系|两者的关系是属于二选一的关系，不能被同时调用|</span><br><span class=\"line\">---</span><br><span class=\"line\">抽象类</span><br><span class=\"line\">----</span><br></pre></td></tr></table></figure>\n<p>public class Test{<br>        public static void main(String args[]){<br>        A a=new B(“小艾”,11);<br>        a.show();<br>        A a1=new C(“笑话”,12);<br>        a1.show();<br>    }<br>}<br>abstract class A{<br>        public abstract void show();<br>}<br>class B extends A{<br>        String name;<br>        int age;<br>        B(String _name,int _age){<br>        }<br>        public void show(){<br>        System.out.println(“学生\\t”+name+”\\t”+age);<br>        }<br>}<br>class C extends B{<br>    C(String _name,int _age){<br>            super(_name,_age);<br>    }<br>    public show(){<br>    System.out.println(“工人\\t”+name+”\\t”+age);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>学生  小艾  11<br>工人  笑话  12<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的类A是一个抽象类来的，抽象类是不能被实例化的，顾名思义，抽象类是没有实现的方法的，在上面的父类中只有定义成员方法为抽象方法的的一个定义，没有实现的行为，抽象类的实现一般是在子类中一一实现的，这也得于抽象类的特性，抽象类是不能被实例化的，这样做会报错的，一般的抽象类都是有子类的，子类的重要作用之一是实现父类中的抽象方法，这是很重要的，还有就是，定义在父类的全部抽象方法在子类中都要重写这些抽象方法，不然会报错，记住是全部都要重写。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 接口(interface)</span><br><span class=\"line\">`接口是java所提供的另外一种重要的技术，是一种特殊的类，它的结构和抽象类很相似。接口里的数据成必须初始化，数据成员均为常量，常见的是全局变量。` </span><br><span class=\"line\">`为了避免在接口中添加新的方法后要修改所有的实现类，允许定义默认方法` </span><br><span class=\"line\"></span><br><span class=\"line\">使用接口的原则</span><br><span class=\"line\">- [ ] 接口必须有子类，子类依靠(关键字)implements来实现多个接口</span><br><span class=\"line\">- [ ] 接口的子类必须重写接口中的所有抽象方法</span><br><span class=\"line\">- [ ] 接口可以利用对象的多态性，利用子类的对象进行实例化</span><br><span class=\"line\">- [ ] 接口和一般的类是一样的，具有成员变量和成员方法，但数据成员必须进行初始化，而初始化的值是不能被修改的，相当与是常量，方法也必须是抽象的或者是(default)，所以在接口中这两个特性是可以忽略的，因为在接口中不管是成员方法或者是成员变量都是特性都是肯定了的。</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){</p>\n<pre><code>        B b=new B();\n        b.show();\n        b.print();\n    System.out.println(A.name);\n    //System.out.println(b.name);//不能通过类的实现来访问静态成员\n}\n</code></pre><p>}<br>interface A{<br>        public static String name=”hello”;<br>        public void show();<br>        default void print(){<br>        System.out.println(“你好”);<br>        }<br>}<br>class B implements A{<br>    //name=”HELLO”;//这个是错误的<br>    public void show(){<br>        System.out.println(name);<br>    }<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果:<br>hello<br>你好<br>hello<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序只是简单的介绍接口的基本定义的格式，其中有成员变量和成员方法，而其中的成员变量是全局类型的(还必须给初始化值)，成员方法分两种，一种是抽象方法(在子类是实现的方法，在接口只是声明而已)，另外是其它类型的成员方法</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**在这里在强调一次，接口与抽象类唯一不同的就是子类，对于接口来说可以实现多个接口，但抽象类是不能多继承的**</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>        C c=new C();<br>        c.show();<br>    }<br>}<br>interface A{<br>    default void show(){<br>    System.out.println(“A接口的默认方法”);<br>    }<br>}<br>interface B{<br>    default void show(){<br>    System.out.println(“B接口的默认方法”);<br>    }<br>}<br>class c implements A , B{}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序是错误的，因为在接口中的默认方法中如果有同名的方法，你在调用方法的同时，编译器会不知道你要调用的到底是哪一个方法，这就产生了所谓的二义性，一般来说在接口中一定不要有同名的变量,还有就是上面的接口是没有抽象类型的方法，所以在子类中是空的</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`在前面说过，接口是允许多继承的，接口中对于抽象类和接口的继承是先继承后实现`</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>        F f=new F();<br>        A a=f;//声明一个接口对象来指向子类，主要是在调用方法的时候让你清晰的知道在那个接口中调用的是那个方法。你也可以不写，直接用子类的实例化对象来调用<br>        B b=f;<br>        C c=f;<br>        D d=f;<br>        a.show();<br>        b.prin();<br>        c.print();<br>        c.xiao();<br>        d.printd();<br>        d.xi();<br>    }<br>}<br>interface A{<br>        public static String name=”小新”;<br>        public void show();<br>}<br>interface B{<br>    public void prin();<br>}<br>interface  C extends A , B{//接口继承多个接口<br>    public void print();<br>    default void xiao(){<br>    System.out.println(name+”\\t多接口继承”);<br>    }<br>}<br>abstract class D implements A,B{//抽象类继承多个接口<br>    abstract public void printd();<br>    void xi(){<br>    System.out.println(name+”\\t抽象类继承”);<br>    }<br>}<br>class F extends D implements C{<br>    public void show(){<br>    System.out.println(“你好”);<br>    }<br>    public void prin(){<br>    System.out.println(“hello,world”);<br>    }<br>    public void print(){<br>    System.out.println(“一个接口继承多个接口”+name);<br>    }<br>    public void printd(){<br>    System.out.println(“抽象类继承多个接口”);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>你好<br>hello,world<br>一个接口继承多个接口<br>小新 多接口继承<br>抽象类继承多个接口<br>小新 抽象类继承<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在上面的程序中我们可以知道，对于接口的继承，一个接口可以继承多个接口(extends)来继承，继承的同时不用进行对继承的接口进行实现。抽象类继承多个接口(implements),继承的同时一样不要进行对已继承的接口的方法实现，但子类一定要对继承的接口和抽象类中的方法进行实现,还有就是，不管是多接口继承还是抽象类继承，都是基于继承的特性来实现继承的，都会继承父接口的成员变量。对于接口的成员变量一定要在声明的同时就进行初始化。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">接口的作用--制定标准</span><br><span class=\"line\">`接口是标准，所谓的标准，指的是各方共同遵守的一个原则。只有操作标准统一了，所有的参与者才可以按照统一的规则操作`</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>        Computer c=new Computer();<br>        c.show(new B);//拿子类的引用来作为参数调用父接口中的方法<br>        c.show(new C);//拿子类的引用来作为参数调用父接口中的方法</p>\n<pre><code>}\n</code></pre><p>}<br>interface USB{<br>        public void work();//这是抽象方法<br>}<br>class B implements USB{<br>    public void work(){<br>        System.out.println(“USB在工作”);<br>    }<br>}<br>class C implements USB{<br>    public void work(){<br>        System.out.println(“USB在打印机中工作”);<br>    }<br>}<br>class Computer{<br>    public void show(USB usb){//父接口作为方法的参数<br>        usb.work();//调用类中的方法<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>USB在工作<br>USB在打印机中工作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面展现的是接口作用--制定标准，利用接口USB来制定工作的标准，通过继承来实现接口中的方法，最后通过电脑类中的方法来调用在子类的实现</span><br><span class=\"line\"></span><br><span class=\"line\">接口--工厂的设计</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>    A a=F.getname(“apple”);</p>\n<pre><code>}\n</code></pre><p>}<br>interface A{<br>        public void eat();<br>}<br>class apple implements A{<br>    public void eat(){<br>        System.out.println(“吃苹果”);<br>    }<br>}<br>class oright implements A{<br>    public void eat(){<br>    System.out.println(“吃橙子”);<br>    }<br>}<br>class F{<br>    public static A getname(String name){<br>        if(“apple”.equals(name)){<br>        return new apple();<br>        }<br>        if(“oright”.equals(name)){<br>        return new oright();<br>        }<br>        return null;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>吃苹果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">此时的程序，在客户端没有和具体的子类耦合在一起，这样一来，如果再有更多的A接口子类出现，只需要修改F类即可，即:所有的接口对象都通过F类取得，在程序员自己开发的代码中，只要是遇见要取得接口对象实例的操作，都应该使用工厂设计模式。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">匿名类使用注意事项</span><br><span class=\"line\">- [ ] 使用匿名类的时候必须是继承一个类或者是实现一个接口，但是两者不可同时兼得，只能是继承一个类或者是实现一个接口</span><br><span class=\"line\">- [ ] 匿名内部类是不能定义构造方法的</span><br><span class=\"line\">- [ ] 匿名内部类不存在静态方法和静态变量</span><br><span class=\"line\">- [ ] 匿名内部类属于局部内部类，所以局部内部类的限制同样对局部内部类生效</span><br><span class=\"line\">- [ ] 匿名内部类不能是抽象的，它必须是一个实现的继承类或者是实现接口的所有抽象方法</span><br><span class=\"line\"></span><br><span class=\"line\">static</span><br><span class=\"line\">- [ ] 由static定义的类方法，可以直接由类名直接调用，另外的就是static属性是一个共享的属性</span><br><span class=\"line\"></span><br><span class=\"line\"># java常用的类</span><br><span class=\"line\">`API(应用程序编程接口)`</span><br><span class=\"line\"></span><br><span class=\"line\">基本类型的包装类</span><br><span class=\"line\">----</span><br><span class=\"line\">|基本数据类型|基本类型的包装类|</span><br><span class=\"line\">|------------|----------------|</span><br><span class=\"line\">|int|Integer|</span><br><span class=\"line\">|double|Double|</span><br><span class=\"line\">|byte|Byte|</span><br><span class=\"line\">|char|Char|</span><br><span class=\"line\">|float|Float|</span><br><span class=\"line\">|shart|Shart|</span><br><span class=\"line\">|long|Long|</span><br><span class=\"line\">|boolean|Boolean|</span><br><span class=\"line\"></span><br><span class=\"line\">装箱与拆箱</span><br><span class=\"line\">-----</span><br><span class=\"line\">所谓的装箱就是把基本数据类型用它们相对应的引用数据类型包起来，使它们具有对象的特质，例如把int包装成Integer类的对象</span><br><span class=\"line\">所谓拆箱就是与装箱刚刚相反，将Integer类的对象重新简化成基本数据类型</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            Integer i=new Integer(10);<br>            int x=i.intValue();<br>            System.out.println(x);<br>            Double b=new Double(100.00);<br>            double b1=b.doubleValue();<br>            System.out.println(b1);</p>\n<pre><code>}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>10<br>100.00<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序是利用拆箱来把Integer类的包装类拆成基本数据类型Int，下面的double也是一样的</span><br><span class=\"line\">装箱的操作:就是将基本数据类型变为包装类，利用各个包装类的构造方法来完成</span><br><span class=\"line\">拆箱的操作:将包装类变为基本数据类型，利用各自的类的xxx.Value()方法来实现</span><br><span class=\"line\"></span><br><span class=\"line\">基本数据类型与String类的转换</span><br><span class=\"line\">----</span><br><span class=\"line\">**但是以下的操作是不包括Char类的，因为String类有一个CharAt方法可以取得指定索引的字符** </span><br><span class=\"line\"></span><br><span class=\"line\">`将String类型转换成基本数据类型`</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            String s=”123”;<br>            int i=Int.parseInt(s);<br>            String s1=”123.6”;<br>            double b=Double.parseDouble(s1);<br>            System.out.println(i);<br>            System.out.println(b);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>123<br>123。6<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在将字符串换成基本数据类型的时候要注意一定要符合对应的数据类型，不能把数据类型搞混。</span><br><span class=\"line\"></span><br><span class=\"line\">`把基本数据类型变为String类型`</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            int i=100;<br>            String s=String.ValueOf(i);<br>            System.out.println(s);<br>            double b=123.6;<br>            String s1=String.ValueOf(b);<br>            System.out.println(s1);<br>    }<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果:<br>100<br>123.6<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面是利用String类里的机制方法来进行对不同基本数据类型转换成String类。</span><br><span class=\"line\"></span><br><span class=\"line\"># 日期操作类</span><br><span class=\"line\">|类名|说明|</span><br><span class=\"line\">|----|----|</span><br><span class=\"line\">|LocalDateTime|存储了日期和时间|</span><br><span class=\"line\">|LocalDate|存储了日期|</span><br><span class=\"line\">|LocalTime|存储了时间|</span><br></pre></td></tr></table></figure></p>\n<p>import java.time.LocalDate;<br>import java.time.YearMonth;<br>import java.time.Year;<br>impore java.time.MonDay;<br>public class Test{<br>    public static void main(String args[]){<br>            LocalDateTime l1=LocalDateTime.now();<br>            System.out.println(l1);//根据日期类来调用方法来打印现在的年月日,在这里就不打印了,自己尝试<br>            Year year=Year.of(2010);<br>            YearMonth yearmonth=year.at(2);<br>            LocalDate localdate=yearmonth.at(28);<br>            System.out.println(localdate);<br>            System.out.println(localdate.isEqual(localdate));<br>            MonthDay m=Monday.of(4,15);<br>            localdate l=m.atyear(2015);<br>            System.out.println(l);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>2010-2-18<br>true<br>2015-4-15<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从上面的程序可以看出，在java中对日期的操作是非常强大的，可以根据自己的需求来慢慢进行设置，在上面我也给出了对于日期类的归属。</span><br></pre></td></tr></table></figure></p>\n<p>import java.time.<em>;<br>import java.time.format.</em>;<br>public class Test{<br>    public static void main(String aegs[]){<br>            LocalDate localdate=LocalDate.now();//获取当前日期<br>            DateTimeForMatter datetime=DateTimeForMatter.ofPattern(“dd/mm/uuuu”);//设置日期打印的格式<br>            String str=localdate.ofmat(datetime);//把当期日期放在设置好的日期格式<br>            System.out.println(str);//打印出来<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>自己尝试了，仆街。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在java中，设置日期的格式是用过DateTimeForMatter类来设置格式的，然后把时间放在设置好的格式里，最后通过String类来进行打印出来。</span><br><span class=\"line\"></span><br><span class=\"line\"># 正则</span><br><span class=\"line\"></span><br><span class=\"line\">|正则标识符|意义|</span><br><span class=\"line\">|----------|----|</span><br><span class=\"line\">|\\ |表示一位字符|</span><br><span class=\"line\">|\\\\|表示多位字符|</span><br><span class=\"line\">|\\n|匹配换行|</span><br><span class=\"line\">|[abc]|a,b,c中的任意一位|</span><br><span class=\"line\">|[^abc]|表示不是abc中的任意一位|</span><br><span class=\"line\">|[a-zA-Z]|表示任意一位字母(不管大小写)|</span><br><span class=\"line\">|[0-9]|表示0-9任意一位|</span><br><span class=\"line\">|.|表示任意一位字符|</span><br><span class=\"line\">|\\d|等价与0-9|</span><br><span class=\"line\">|\\D|等价与[^0-9]|</span><br><span class=\"line\">|\\s|表示一位空格|</span><br><span class=\"line\">|\\S|表示非空格|</span><br><span class=\"line\">|\\w|等价与[a-zA-Z0-9]|</span><br><span class=\"line\">|\\W|等价与[^a-zA-Z0-9]|</span><br><span class=\"line\">|^|表示正则的开头|</span><br><span class=\"line\">|$|表示正则的结尾|</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(Strng args[]){<br>        if(“123”.matches”\\d+”){<br>            System.out.println(“true”);<br>        }else{<br>        System.out.println(“false”);<br>        }<br>        String s=”<a href=\"mailto:1234@163.com\" target=\"_blank\" rel=\"noopener\">1234@163.com</a>“;//给出字符串<br>        String s1=”\\w+@\\w+.\\w+”;//给出邮箱的格式(w:等价于[a-zA-Z0-9])<br>        System.out.println(s.matches(s1));//验证上面的邮箱格式<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>true<br>true<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序是通过正则来判断并输出结果的，上面的方法是正则类里的一个方法，意思是判断字符串是不是由数字组成的，是就输出true，不是就false，明显与结果是一样的。</span><br><span class=\"line\">|方法|意义|</span><br><span class=\"line\">|----|----|</span><br><span class=\"line\">|boolean matches(String test)|将字符与给出的正则表达式进行匹配验证|</span><br><span class=\"line\">|String replaceAll(String test,String replacement)|按照指定的正则进行替换|</span><br><span class=\"line\">|String replzceFirst(String test,String replacement)|按照指定的正则进行替换首个|</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            String s=”123abcd3546efg”;<br>            String s1=”\\d+”;多个数字<br>            System.out.println(s.replaceAll(s1,””));//在字符串中替换数字<br>            System.out.println(s.replaceFirst(s1,””));//在字符串中替换首个字符前数字</p>\n<pre><code>}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>abcdefg<br>abcd3546efg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在上面我给出的正则表达式的表示符可以在这个程序里尽情的尝试，你也会有发现的，但重要的是对你的理解有帮助,这样学起来是理解性的学习而不是一味的烦躁。</span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal(大数值)</span><br><span class=\"line\">----</span><br></pre></td></tr></table></figure></p>\n<p>import java.math.BigDecimal;<br>public class Test{<br>    public static void main(String args[]){<br>            BigDecimal b=new BigDecimal(“3456789101112”)<br>            BigDecimal b1=new BigDecimal(“123456789”);<br>            System.out.println(b.add(b1));//加法<br>            System.out.println(b.subtract(b1));//减法<br>            System.out.println(b.multipy(b1));//乘法<br>            System.out.println(b.multipy(b1).setScale(1,BigDecimal.ROUND_up));//乘法,但是以进一的形式来输出值<br>            System.out.println(b.divide(b1,BigDecimal.ROUND_DOWN));//除法<br>            BigDecimal b2[]=b.divideAndRemainder(b1);//除法，并把值放在数组里面<br>            System.out.println(“商”+b2[0]+”余”+b2[1]);<br>    }<br>}</p>\n<p><code>`</code></p>\n<p>上面的程序主要是应对于大的数字，在int和long都无法容纳的时候就使用BigDecimal类型来进行操作，(结果自己动手)</p>\n<p><strong>当需要在ArrayList和HashMap中放东西的时候,你在这个时候使用基本数据类型是不能放进去的，因为容器里面都是放</strong> &lt;++&gt;</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"//evanshady.github.io/2019/09/19/Java/java0.png\" alt=\"终端运行的结果\"> </p>\n<p>Write Once,Run Everywhere<br></p>","more":"<p></p>\n<p> <strong>达到对面向对象编程思想更加深入的理解，是对面向对象的各种特性及其实现细节更加熟练的掌握。</strong> </p>\n<hr>\n<p> <em>一步一个脚印的连好java的基本功。对于我来说是最好不过的，掌握java的基本语法。(类与对象，构造方法，引用传递，内部类，异常，包，java常用类库，javaIO，java类集)</em> </p>\n<ol>\n<li>走技术之路(在学习java的同时，把基础的知识打好一定的基础)</li>\n<li>定位成为技术类管理成员(掌握基础的java知识，还要有几年的工作经验)</li>\n<li>java软件开发发展前景好，移植性也很强。</li>\n</ol>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> JDK(java开发工具包)</li>\n</ul>\n<p><em>是编程语言和javaAPI类库和java虚拟机(是完成移植性的重要机制)来组成的</em> </p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> JRE(java运行时环境)<br><em>是javaAPI子集和java虚拟机组成</em> </li>\n</ul>\n<h2 id=\"前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。\"><a href=\"#前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。\" class=\"headerlink\" title=\"前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。 \"></a><strong>前面二者的区别是：JDK包含着JRE。如果仅仅是运行java程序的话就需要JRE。如果是要自己动手写java程序就要部署JDK环境。</strong> </h2><h2 id=\"java系统可分为：javaEE-标准版-，javaSE-企业版-，javaME-微型版-，javaCARD-智能卡版\"><a href=\"#java系统可分为：javaEE-标准版-，javaSE-企业版-，javaME-微型版-，javaCARD-智能卡版\" class=\"headerlink\" title=\"java系统可分为：javaEE(标准版)，javaSE(企业版)，javaME(微型版)，javaCARD(智能卡版) \"></a><strong>java系统可分为：javaEE(标准版)，javaSE(企业版)，javaME(微型版)，javaCARD(智能卡版)</strong> </h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//有必要说明一下，接下来的是在linux系统下使用终端来让我电脑上的文件进行运行</span><br><span class=\"line\"></span><br><span class=\"line\">public class hello&#123;//public(公有访问类型),class(类的标识),hello(类名)</span><br><span class=\"line\">    public static void main (String arg[])&#123;//是main函数的基本格式,也表明main函数是静态方法</span><br><span class=\"line\">    System.out.println(&quot;hello,world!&quot;);//打印字符串&quot;hello,world!&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java0.png\" alt=\"终端运行的结果\"> </p>\n<hr>\n<p><strong>这里要注意一下的就是文件的后缀是.java,其次是以javac 来作为第一次的关键字来操作文件，接着就会生成一个后缀为.class的文件，然后就是运行你写的文件，记住后面没有任何的后缀。</strong> </p>\n<ul>\n<li><strong>java是面向对象的过程，也就是说在java中只有方法而没有所谓的函数。</strong> </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    scanner s=new scanner(System.in);//为了可以让用户输入，在这里使用了scanner类,因为它附属与System.in</span><br><span class=\"line\">    System.out.println(&quot;请输入你的性别&quot;);</span><br><span class=\"line\">    String set=s.nextLint();//以字符串的形式输入</span><br><span class=\"line\">    System.out.println(&quot;请输入你的姓名&quot;);</span><br><span class=\"line\">    String name =s.nextLint();</span><br><span class=\"line\">    switch(set)&#123;</span><br><span class=\"line\">    case &quot;男&quot;:</span><br><span class=\"line\">    System.out.println(name+&quot;男士&quot;);</span><br><span class=\"line\">    break;</span><br><span class=\"line\">    case &quot;女&quot;:</span><br><span class=\"line\">    System.out.println(name+&quot;女士&quot;);</span><br><span class=\"line\">    break;</span><br><span class=\"line\">    default :</span><br><span class=\"line\">    System.out.println(&quot;输入有误&quot;);</span><br><span class=\"line\">    break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.close();//关闭类</span><br><span class=\"line\">    InputStreamReader input=new InputStreamReader(System.in);//定义在键盘输入</span><br><span class=\"line\">    BufferedReader Buff=new BufferedReader(input);//以缓冲流的形式来接受input</span><br><span class=\"line\">    //用try和catch机制来处理异常</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">    System.out.println(&quot;请输入字符：&quot;);</span><br><span class=\"line\">    String s=Buff.readLine();</span><br><span class=\"line\">    System.out.println(&quot;字符：&quot;+s);</span><br><span class=\"line\">    &#125;catch (Exception e)&#123;</span><br><span class=\"line\">    System.out.println(&quot;异常&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java2.png\" alt=\"运行结果\"></p>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java1.png\" alt=\"输入的方式\"></p>\n<p><em>在这里只是简单的让用户输入了两次都是以字符串的方式来输入的，当然你也可以让用户输入你想让用户输入的数据类型(eg:int ,double)，上面也有参照的照片。</em> </p>\n<ul>\n<li><strong>合法的标识符</strong> </li>\n</ul>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 不能存在关键字</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 首字母不能是数字</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 不能存在运算符</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 标识符是区别大小写的</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 标识符的命令规则是强制性的</li>\n</ul>\n<p><code>我们都知道数据的类型有int,short,float,double,byte(字节)。最常见的就是int(整形的数据类型)。在java中我们可以通过程序来输出各个数据类型的范围是多少，最大值和最小值，和数据类型</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main (String args[])&#123;</span><br><span class=\"line\">    int a=Integer.Size;</span><br><span class=\"line\">    System.out.println(&quot;int的范围:&quot;+a);</span><br><span class=\"line\">    int b=Integer.MAX_VALUE;</span><br><span class=\"line\">    System.out.println(&quot;int的最大值:&quot;+b);</span><br><span class=\"line\">    int c=Integer.MIN_VALUE</span><br><span class=\"line\">    System.out.println(&quot;int的最小值:&quot;+c);</span><br><span class=\"line\">    Class &lt;Integer&gt; d=Integer.TYPE;</span><br><span class=\"line\">    System.out.println(&quot;数据类型:&quot;+d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果：</span><br><span class=\"line\">int的范围:32</span><br><span class=\"line\">int的最大值:2147483647</span><br><span class=\"line\">int的最小值:-2147483648</span><br><span class=\"line\">数据类型:int</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">            static int i=10;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">            int a=1;</span><br><span class=\"line\">            int b=2;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            int b=3;//main方法的变量名是不可以重复的，一个变量只能使用一个名，在这里就是重复使用了变量b，所以程序会报错。</span><br><span class=\"line\">            System.out.println(&quot;b=&quot;+b);</span><br><span class=\"line\">            System.out.println(&quot;a=&quot;+a);</span><br><span class=\"line\">            System.out.println(&quot;i=&quot;+i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;b=&quot;+b);</span><br><span class=\"line\">            System.out.println(&quot;a=&quot;+a);</span><br><span class=\"line\">            System.out.println(&quot;i=&quot;+i);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面的程序是运行不过的，这也是java的特别之处，在c++中，变量b是可以用的，但在java中是不可以的。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main (String args[])&#123;</span><br><span class=\"line\">            char ch = &apos;\\&quot;&apos;;//转义字符</span><br><span class=\"line\">            System.out.println(ch);</span><br><span class=\"line\">            System.out.println(&quot;\\&quot;hello,world!&quot;\\&quot;);</span><br><span class=\"line\">            System.out.println(ch+&quot;hello,world!&quot;+ch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">&quot;</span><br><span class=\"line\">&quot;hello,world!&quot;</span><br><span class=\"line\">&quot;hello,world!&quot;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><code>总结可以得知，不管是用变量来存放转义字符，还是直接使用转义字符的方式来输出字符，程序都是可以顺利运行的，当然你也可以不使用变量来存放转义字符，但一个程序里面有太多的转义字符的存在你用变量来存放不是更好使用？这样你也不容易搞混已有的转义字符的使用。</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">        System.out.println(2+3+&quot;k&quot;);</span><br><span class=\"line\">        System.out.println(6+6+&quot;aa&quot;+6+6);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果</span><br><span class=\"line\">5k</span><br><span class=\"line\">12aa66</span><br></pre></td></tr></table></figure>\n<hr>\n<p><code>上面的2+3是一个表达式，所以这里是5,但后面跟的是字符和+(字符串相加)的符号，所以是5k,下面的也是一样的，唯一不一样的是在+(字符串相加)之后，计算机会自动认为后面的也是+(字符串相加)所以后面的就是12aa66。但如果把上面的双引号换成单引号就是以数字的形式先加后输出的。</code> </p>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>import java.util.Randow;//随机数字的包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">                int i=3;//这是在堆内存的分配的内存(也可以说是在编译是分配的),读取速度快，但数据的活动范围小(缺少灵活性)</span><br><span class=\"line\">                int y=new Integer(1);//是在栈内存分配的内存(也可以说是运行时分配的内存),读取速度慢，但数据灵活性高。</span><br><span class=\"line\">                System.out.println((int)(Math.randow()*10));//生成随机数字，0～10</span><br><span class=\"line\">                Randow rand=new Randow();</span><br><span class=\"line\">                int i=rand.nextInt(10);//随机生成0～10的数字</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>import java.util.Randow;//导入随机数字的包<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">            Randow rand=new Randow();//声明随机数字的对象</span><br><span class=\"line\">            int []numb=new int [rand.nextInt(10)];//rand.nextInt(10)这句话的意思是随机生成一个0～10的数字作为数组的长度</span><br><span class=\"line\">            for(int i=0;i&lt;numb.length;i++)&#123;//为数组赋值。从0～100来选择每次的赋值的数值</span><br><span class=\"line\">                numb[i]=rand.nextInt(100);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for(int a : numb)&#123;//打印数组里的元素</span><br><span class=\"line\">            System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>在c++中的指针，在java是叫做引用数据类型，相当与c++中的地址指针</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    Randow rand=new Randow();//声明随机数字的对象</span><br><span class=\"line\">    int []a=new int[rand.nextInt(10)];//定义数组长度</span><br><span class=\"line\">    int []b=a;//把数组a赋值给数组b</span><br><span class=\"line\">    for(int i=0;i&lt;a.length;i++)&#123;//为数组a赋值</span><br><span class=\"line\">            a[i]=rand.nextInt(100);</span><br><span class=\"line\">            System.out.println(a[i]);</span><br><span class=\"line\">            System.out.println(b[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>上面程序的结果每次都是不要的，但值得注意的是输出的结果，肯定不会让你们失望的，因为数组b里面的元素是和数组a的元素是一样的。其实，上面最重要的一点就是数组b=数组a，它的等于是连着后面的a数组的赋值。</code> </p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">            Randow rand=new Randow();</span><br><span class=\"line\">            int [][]numb=new int[3][1];//声明数组numb和给数组长度</span><br><span class=\"line\">            for(int i=0;i&lt;numb.length;i++)&#123;//给数组赋值并输出数组里的元素</span><br><span class=\"line\">                for(int j=0;j&lt;numb[i].length;j++)&#123;</span><br><span class=\"line\">                        numb[i][j]=rand.nextInt(10);</span><br><span class=\"line\">                        System.out.println(numb[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>一样的，上面的数组每运行一次程序的结果都是不一样的。</code> </p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">    public static void main(String args)&#123;</span><br><span class=\"line\">            int []numb=new int[]&#123;10,23,41,6,11&#125;;//声明一个数组，并赋初值</span><br><span class=\"line\">            int a=Randow rand=new Randow(3)+1;//生成随机数字，范围是1～4</span><br><span class=\"line\">            for(int i=0;i&lt;a;i++)&#123;//把随机数字的大小作为条件,并从一开始交换位置</span><br><span class=\"line\">                int temp=numb[i];</span><br><span class=\"line\">                numb[i]=numb[i+1];</span><br><span class=\"line\">                numb[i+1]=temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for(int b:numb)&#123;//输出数组里的元素</span><br><span class=\"line\">            System.out.println(b);,你在这个时候使用基本数据类型是不能放进去的，因为容器里面都是放            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>上面程序实现的是乱序，就是每次输出的结果都是不一样的。</code> </p>\n<hr>\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><p><strong>类描述了对象的属性和对象的方法，类是对象的模板，更可以说，对象是类的实例，是一个实实在在存在的个体。所以说，面向对象的程序重要的是类的设计而不是对象的设计。</strong><br><code>类的声明格式:</code> </p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> [标识符] class 类的名称<br>{<pre><code>//类的属性\n//类的方法\n</code></pre>}<br><code>类的标识符:</code> </li>\n<li><p>[ ] 默认的(default):这个类只能被这个类的对象和同一个包中的其它的类访问，即使是其它包里的这个类的子类都不能被访问，它只认同一包里的类。</p>\n</li>\n<li><p>[ ] 私有(private):如果一个方法或者属性被定义为私有的，那么只能在本类里访问它。</p>\n</li>\n<li><p>[ ] 公有(public):如果一个方法或属性被定义为公有的，那么它不仅能跨类的对象所调用，还能在其它包中被访问。</p>\n</li>\n<li><p>[ ] 保护(protected):如果一个方法或属性被定义为保护的，那么它能被本类的方法所访问，也能被子类所访问，即使子类在其它包里。</p>\n</li>\n</ul>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java3.png\" alt=\"java访问机制\"> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main (String args[])&#123;</span><br><span class=\"line\">            System.out.println(&quot;------&quot;创建对象&quot;-------&quot;);</span><br><span class=\"line\">            new Apple();//匿名对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Apple&#123;</span><br><span class=\"line\">        static String a=&quot;string-a&quot;;</span><br><span class=\"line\">        Static String b;</span><br><span class=\"line\">        String c=&quot;string-c&quot;;</span><br><span class=\"line\">        Strint d;</span><br><span class=\"line\">        Static&#123;//static 属于静态代码块，最先运行的是这段代码块，而不是类的构造函数先</span><br><span class=\"line\">                printstatic(&quot;before static&quot;);</span><br><span class=\"line\">                b=&quot;string-b&quot;;</span><br><span class=\"line\">                printstatic(&quot;after static&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static void printstatic(String name)&#123;//这里要加静态的关键字，因为调用是静态来的所以这里也要有静态的关键字来表明这里是静态，不然是会报错的。</span><br><span class=\"line\">                System.out.println(&quot;------&quot;+name+&quot;-------&quot;);</span><br><span class=\"line\">                System.out.println(&quot;a=&quot;+a);</span><br><span class=\"line\">                System.out.println(&quot;b=&quot;+b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Apple()&#123;</span><br><span class=\"line\">            print(&quot;before class&quot;);</span><br><span class=\"line\">            d=&quot;string-d&quot;;</span><br><span class=\"line\">            print(&quot;after class&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        void print()&#123;</span><br><span class=\"line\">                System.out.println(&quot;------&quot;+name+&quot;-------&quot;);</span><br><span class=\"line\">                System.out.println(&quot;a=&quot;+a);</span><br><span class=\"line\">                System.out.println(&quot;b=&quot;+b);</span><br><span class=\"line\">                System.out.println(&quot;c=&quot;+c);</span><br><span class=\"line\">                System.out.println(&quot;d=&quot;+d);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"//evanshady.github.io/2019/09/19/Java/java4.png\" alt=\"运行结果\"> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面的对象是经过匿名对象来实例化的，也就是没有给new的对象一个堆内存，一旦这句语句实现完，计算机会自动回收这个内存，将不再存在程序里，这也是java的垃圾回收机制(BC)，这也是为我们考虑的，不知道你有没有发现，上面的几个程序我都是用new来给类分配的对象，但我不但没有在类中写析构函数，也没有在main函数里delete对象的实例化。因为这一切都是java的BC机制帮我们做了。</span><br></pre></td></tr></table></figure>\n<p>public class Test{</p>\n<pre><code>public static void main(String args[]){\n        String name=new String (&quot;java&quot;);\n        String _name=new String (&quot;java&quot;);\n        String hua=_name;\n        if(name==_name){\n        System.out.println(&quot;地址相同&quot;);\n        }else{\n        System.out.println(&quot;地址不同&quot;);\n        }\n        if(name.equals(_name)){\n        System.out.println(&quot;内容相同&quot;);\n        }else{\n        System.out.println(&quot;内容不同&quot;);\n        }\n</code></pre><p>}<br>运行结果:<br>地址不同<br>内容相同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序分别实现了字符串地址(==)和字符串内容(equals方法)的比较，第一个变量和第二个变量的是经过new来分配的栈内存的地址，所以输出的是地址不相同,而最后一个的是进行的内容比较，因为初始化的原因，这里也是输出的内容相同。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">构造方法的注意事项</span><br><span class=\"line\">- [ ] 构造方法的名称与类的名称是一样的</span><br><span class=\"line\">- [ ] 构造方法也是和普通方法一样的，可以被重载，但构造方法的调用是通过在创建类的对象的时候自动调用的，这是与普通方法的调用是不一样的</span><br><span class=\"line\">- [ ] 构造方法是没有返回值的</span><br><span class=\"line\">- [ ] 构造方法是不能被static和final修饰的</span><br><span class=\"line\">- [ ] 构造方法是不能被继承的，如果子类要使用父类的构造方法只能使用关键字(super)来进行调用</span><br></pre></td></tr></table></figure></p>\n<p>public Test{</p>\n<pre><code>private String name;\nTest(){\nSystem.out.println(&quot;类的无参构造方法的调用&quot;);\n}\nTest(String _name){\n    this-&gt;name=_name;\n    System.out.println(&quot;类的有参构造方法的调用&quot;);\n}\npublic static void main(String args[]){\n        new Test();//这是匿名调用类的构造方法\n        Test test=new Test();//这和上面是等价的\n        Test t1=new Test(&quot;小明&quot;);\n}\n</code></pre><p>}</p>\n<p>上面的程序做的只是简单的演示类的构造方法的重载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    Apple apple;</span><br><span class=\"line\">    apple=Apple.V();</span><br><span class=\"line\">    System.out.println(&quot;姓名:&quot;+apple.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Apple&#123;</span><br><span class=\"line\">        String name;</span><br><span class=\"line\">        private Apple ()&#123;</span><br><span class=\"line\">        name=&quot;hello&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        private static final Apple APPLE=new Apple();</span><br><span class=\"line\">        public static V()&#123;</span><br><span class=\"line\">        return APPLE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的程序的重要性是:当你不想一个类被频繁调用的是时候，可以通过对类的构造方法的私有化来实现</p>\n<h1 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h1><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 普通代码块(就是普通的放在Main方法里面的代码块)</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 构造代码块(放在类里面，比构造方法更先一步执行的代码块)</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 静态代码块(比构造代码块更快一步，如果和Main方法是放在同一个类的话，那它比Main方法更快一步执行)</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 同步代码块</li>\n</ul>\n<blockquote>\n<p>普通代码块</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">        public static void main(String args[])&#123;</span><br><span class=\"line\">        &#123;int x=10;//普通代码块</span><br><span class=\"line\">        System.out.println(&quot;x&quot;);</span><br><span class=\"line\">        &#125;//如果不要这个代码块，程序将会报错，因为在一个方法里，不能有同名的变量名</span><br><span class=\"line\">        int x=100;</span><br><span class=\"line\">        System.out.println(&quot;x&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果为:</span><br><span class=\"line\">10</span><br><span class=\"line\">100</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>构造代码块</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">           Peron p=new peron(); </span><br><span class=\"line\">           Peron p1=new Peron(&quot;笑话&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Peron&#123;</span><br><span class=\"line\">    private int x;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    System.out.println(&quot;构造代码块的调用&quot;);//这是构造代码块</span><br><span class=\"line\">    x=10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Peron()&#123;</span><br><span class=\"line\">        System.out.println(&quot;类的无参构造方法的调用\\t&quot;+x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Peron(String _name)&#123;</span><br><span class=\"line\">    this-&gt;name=_name;</span><br><span class=\"line\">    System.out.println(&quot;类的有参构造方法的调用\\t&quot;+x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序的运行结果为:</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    类的无参构造方法的调用  10</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    类的有参构造方法的调用  10</span><br></pre></td></tr></table></figure>\n<p>上面类中是有一块属于构造代码块，而它的速度比构造方法的调用都还快，以前我们只知道对于类来说，构造方法是第一个调用的，因为在我们声明类的对象的时候就是通过类的构造方法来实现的，但现在不一样的是，你只要在类中加个中括号({}),里面的代码实现比类的构造方法都还要快被实现，这使得我们的代码更简化一步。比如，就像上面一样，给一个成员变量复制，而不是通过它的构造方法来实现，你只需要定义一个变量，然后再加个({}),就能实现对成员变量的复制，速度还比类的构造方法快一布。</p>\n<p><strong>由此我们可以知道，类的代码块中的初始化是一个类的所有构造方法都共有的“交集”部分，具有个性化的初始化还是要放在各自的构造方法里</strong> </p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>静态代码块</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">    System.out.println(&quot;静态方法的调用&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    System.out.println(&quot;构造代码块的调用&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Test()&#123;</span><br><span class=\"line\">    System.out.println(&quot;构造方法的调用&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">            System.out.println(&quot;创建第1个对象&quot;);</span><br><span class=\"line\">            new Test();</span><br><span class=\"line\">            System.out.println(&quot;创建第1个对象&quot;);</span><br><span class=\"line\">            new Test();</span><br><span class=\"line\">            System.out.println(&quot;创建第1个对象&quot;);</span><br><span class=\"line\">            new Test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序的运行结果为:</span><br><span class=\"line\">    静态代码块的调用</span><br><span class=\"line\">    创建第1个对象</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    构造方法的调用</span><br><span class=\"line\">    创建第2个对象</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    构造方法的调用</span><br><span class=\"line\">    创建第3个对象</span><br><span class=\"line\">    构造代码块的调用</span><br><span class=\"line\">    构造方法的调用</span><br></pre></td></tr></table></figure>\n<p><strong>从上面的案例可以看出来，在执行时机上，静态代码块是在类加载的时候就会执行的，因为早于类的构造代码块和类的构造方法。当一个静态代码块和Main方法在同一个类中，Main方法的调用也是在静态代码块的后面的。静态代码块的执行级别是最高的。</strong>    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static int [] show(int []numb)&#123;</span><br><span class=\"line\">        numb[0]=10;</span><br><span class=\"line\">        numb[1]=12;</span><br><span class=\"line\">        numb[2]=13;</span><br><span class=\"line\">        return numb;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void show1(int []numb)&#123;</span><br><span class=\"line\">        for(int i:numb)&#123;</span><br><span class=\"line\">        System.out.print(i+&quot;\\t&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        public static void main(String args[])&#123;</span><br><span class=\"line\">            int [] numb =new int&#123;1,2,3,4,5&#125;;</span><br><span class=\"line\">            for(int i:numb)&#123;</span><br><span class=\"line\">            System.out.print(i+&quot;\\t&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">            System.out.println(&quot;--------------&quot;);</span><br><span class=\"line\">            show(numb);</span><br><span class=\"line\">            Show1(numb);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序的运行结果为:</span><br><span class=\"line\">1 2 3 4 5 </span><br><span class=\"line\">10 11 12 4 5</span><br></pre></td></tr></table></figure>\n<p><code>上面的程序只是简单的利用java的特性用新的方式来打印数组，只需要一个变量来操作数组对象就行了，比我们之前在c++中的方式简便多了，也是代码的量也减少了，这无疑是一件好事，还利用了引用数据类型来实现对数组的操作，更加利用了静态方法来进行对数组里的元素更改。</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.*//导入sort包</span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    int []numb=&#123;10,2,46,33,5&#125;;</span><br><span class=\"line\">    Arrays.sort(numb);//进行数组的排序</span><br><span class=\"line\">    System.out.println(&quot;排序后:&quot;);</span><br><span class=\"line\">    for(int i:numb)&#123;</span><br><span class=\"line\">    System.out.print(i+&quot;\\t&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>程序的运行结果为:<br>排序后:<br>2 5 10 33 46<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 枚举(enum)</span><br><span class=\"line\">`enum A&#123;红色，黄色，白色&#125;枚举是作为类来被调用的，在定义的同时是连着对象的构造方法一起被调用的`</span><br></pre></td></tr></table></figure></p>\n<p>enum Cloro{红色，黄色，白色}//是枚举的关键字,定义了一个枚举并初始化了<br>public class Test{<br>    public static void main(String args[]){<br>            //java中的枚举其实是一个类来的，在这个类里面还有很多不一样的方法，其作用都是不一样的。<br>            Cloro []cloro=Cloro.values();//Cloro.values()是类的静态方法来的，但是以字符串的形式来的，所以在前面要定义一个同类型的数组来接收,方法是自动生成的<br>            for(Cloro i:cloro){<br>            System.out.println(i);<br>            }<br>            Cloro c=Cloro.valueof(Cloro.class,”白色”);//以指定的颜色来赋给对象,这里的参数有点不一样的就是，参数是类的类型,方法是自动生成的<br>            System.out.println(c);</p>\n<pre><code>}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>红色<br>黄色<br>白色<br>白色<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">枚举的注意事项</span><br><span class=\"line\">- [ ] 如果把枚举的标识符定义为public的话要放在独立的文件里面而不能和main方法放在同一个文件，如果标识符是默认的话就可以放在同一个文件里</span><br><span class=\"line\">- [ ] 使用enum来定义枚举的时候，默认会继承于java.lang.Enum类。默认会用final来修饰，因此无法派生子类。</span><br><span class=\"line\">- [ ] 使用enum来定义的时候，初始化也要和定义一起,如果没有把赋值放在同一行，而这个enum将无法被实例法。</span><br><span class=\"line\">- [ ] 所以使用enum来定义枚举的时候都会默认生成values方法，该方法可以方便遍历所有枚举值，而在枚举中还是有其它的自动生成的方法来给我们使用。</span><br><span class=\"line\"></span><br><span class=\"line\">**enum(枚举)用关键字定义的时候相当于定义了一个类，而这个类继承于Enum类。而在Enum类中的所有方法都是保护类型的，因此这些方法都可以在声明了enum对象中被使用。**</span><br></pre></td></tr></table></figure></p>\n<p>enum A{红色，紫色，白色}<br>public class Test{<br>    public static void main(String args[]){<br>            A []a=A.valuse();//把枚举中的元素都放在对应类型的数组中<br>            for(A i:a){<br>            System.out.println(i.name+i.ordinal());输出的是数组中的元素和数组的下标<br>            }<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>红色0<br>紫色1<br>白色3<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`在枚举中的下表要是没有给定提定的数值，计算机就会自动给它一个下标，而下标的值是以数组的形式来赋值的。` </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`EnumMap是Map接口的子类，也就是说Enummap是继承于类Map的`</span><br></pre></td></tr></table></figure></p>\n<p>import java.util.Map;//导包<br>import java.util.EnumMap;//导包<br>enum Color{红色，黄色，绿色}<br>public class Test{<br>    public static void main(String args[]){<br>        EnumMap&lt;Color,String&gt;emap=new EnumMap&lt;Color,String&gt;(Color.class);//映射&lt;&gt;&lt;KeyType,nameType&gt;,更重要的是EnumMap的构造方法的参数不能为空，需要指定一个枚举类<br>        emap.put(Color.红色,”RED”);//把映射的对象和值都写进去<br>        emap.put(Color.黄色,”YELLOW”);<br>        emap.put(Color.绿色,”BLUE”);<br>        for(Map.Entry&lt;Color,String&gt;me:emap.entrySet()){//把映射的键和值都打印出来,其中的两个方法是Map中的静态方法，EnumMap作为Map的子类所以能调用其中的方法。<br>        System.out.println(me.getKey()+me.getValue());<br>        }<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>红色RED<br>黄色YELLOW<br>绿色BLUE<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的打印用的是新的打印方法，而EnumMap的类型是Map来的，所以它要Map.来点出它的方法来进行打印,Key是不允许重复的，而它的值却允许重复，EnumSet是一个集合来的</span><br></pre></td></tr></table></figure></p>\n<p>import java.util.EnumSet;//导包<br>import java.util.Iterator;//导包<br>enum Color{红色，绿色，紫色}<br>public class Test{<br>    public static void main(String args[]){<br>        EnumSet<color> set=EnumSet.allof(Color.class);//声明集合<enumtepy>并把对应类型的枚举类放在集合中,allof是集合EnumSet中的静态方法，用来把参数中的枚举类放在集合中作为集合的元素<br>        Iterator <color>iter=set.iterator();//声明迭代器并把集合放在迭代器中<br>        while(iter.hasNext()){//参数是确认迭代器中的元素是否为空,为空的时候返回false<br>        System.out.println(iter.Next());//打印迭代器中的元素<br>        }<br>        EnumSet <color>aset=EnumSet.noneof(Color.class);//表示作为空的集合<br>    }<br>    Iterator iterator=aset.iterator();<br>    while(iterator.hasNext()){<br>    System.out.println(iterator.Next());//这里是打印不出来的，所以下面的结果为空<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></color></color></enumtepy></color></p>\n<p>运行结果:<br>红色<br>绿色<br>紫色<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>enum Color{<br>    RED(“红色”,3),BLUE(“蓝色”,4),YELLOW(“黄色”,5);//定义枚举并指定颜色和下标，是以私有构造方法来显示调用枚举类的属性，(也就是说成员)<br>    private String Name;//元素的名字<br>    private int Indext;//元素的下标<br>    private Color(String name,int indexc){//枚举类的构造方法是私有化的,所有的枚举对象都必须显示调用此构造方法。<br>            this-&gt;Name=name;<br>            this-&gt;Indext=indexc;<br>    }<br>    public static void setname(int indexc,String name){<br>        for(Color c:Color.values()){<br>            if(c.Indexc==indexc){<br>            c.Name=name;<br>            }<br>        }<br>    }<br>    public static void setindexc(String name,int indexc){<br>        for(Color c:Color.values()){<br>            if(c.Name==name){<br>            c.Indexc=indexc;<br>            }<br>        }<br>    }<br>    public String getname(String name){<br>    return name;<br>    }<br>    public int getindexc(int intexc){<br>    return intexc;<br>    }</p>\n<p>}<br>public class Test{<br>    public static void main(String args[]){<br>        System.out.println(Color.RED.getname());//RED是枚举类型的Color的枚举实例。这些枚举实例是公有的静态对象(进一步说，它们可以视为枚举类的属性成员)<br>        System.out.println(Color.RED.getindexc());<br>        System.out.println(Color.BLUE.getname());<br>        System.out.println(Color.BLUE.getindexc());<br>        System.out.println(Color.YELLOW.getname());<br>        System.out.println(Color.YELLOW.getindexc());<br>        System.out.println(“自定义元素”);<br>        Color.setname(3,”白色”);//通过属性下标来改变属性的名字<br>        System.out.println(Color.RED.getname());<br>        System.out.println(Color.RED.getindexc());<br>        Color.setindexc(“黄色”,7);//通过属性的名字来改变属性的下标<br>        System.out.println(Color.YELLOW.getname());<br>        System.out.println(Color.YELLOW.getindexc());<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>红色<br>3<br>蓝色<br>4<br>黄色<br>5<br>白色<br>3<br>黄色<br>7</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在上面的程序中都是通过私有的构造方法来显示调用成员属性的，在上面属性其实是RED,BLUE,YELLOW,只不过我在这里都没对它操作，在这里比较容易混淆的是，根本不明白谁才是枚举的成员属性，你也可以通过上面的Values()(是枚举类自动生成的用来遍历枚举属性的方法),其实在上面我也用到了这个方法来对成员属性的名字和下标来进行改变它们对应的值。在最开始的时候定义的枚举的属性其实是在调用私有构造方法来实现实例化。只要把这个搞懂了，其实那些改变成员属性的方法都是很简单理解的。</span><br></pre></td></tr></table></figure>\n<p>enum Color{<br>    红色<br>    {<br>        public String show(){<br>            return “RED”;<br>        }<br>    },<br>    蓝色<br>    {<br>        public String show(){<br>            return “BLUE”;<br>        }<br>    },<br>    黄色<br>    {<br>        public String show(){<br>            return “YELLOW”;<br>        }<br>    };<br>    public abstract String show();//把上面的show方法定义为抽象方法(abstract)抽象关键字</p>\n<p>}<br>public class Test{<br>    public static void main(String args[]){</p>\n<pre><code>    for(Color c:Color.values){\n    System.out.println(c.ordinal+&quot;\\t&quot;+c.name()+&quot;----&quot;+c.show());\n    }\n}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>0  红色—-RED<br>1  蓝色—-BLUE<br>2  黄色—-YELLOW<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">抽象方法关键字(abstract)，修饰没有主体的方法，在这里需要在枚举对象中一一单独实现，否则报</span><br></pre></td></tr></table></figure></p>\n<p>enum Weekday {Sun,Mon,Tue}<br>public class Test{<br>    public static void main(String args[]){<br>            Weekday w=Weekday.Sun;<br>            switch(w){<br>                case Mon:<br>                System.out.println(Do Monday work);<br>                case Sun:<br>                System.out.println(Do Sunday work);<br>            }<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>Do Sunday work<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里是当你定义的是枚举类中的哪个元素的对象的时候，通过switch来进行选择，你输出的语句是你在switch写的语句。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 类</span><br><span class=\"line\">|控制范围|private|default|protected|public|</span><br><span class=\"line\">|----|----|----|----|----|</span><br><span class=\"line\">|类|只能内部类允许私有，只能在当前类被访问|可以被当前包中的所有类访问|只有在内部类可以被设为保护权限,相同包中的类和其子类可以被访问|可以被所有类访问|</span><br><span class=\"line\">|属性|只能被当前类访问|可以被相同包中的类访问|可以被当前包中的所有类访问和当前类的子类访问|可以被所有类访问|</span><br><span class=\"line\">|方法|只能被当前类访问|可以被相同包中的类访问|可以被相同包中的类访问和当前类的子类访问|可以被所有类访问|</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`java中对于类来说有封装，继承，多态。` </span><br><span class=\"line\"></span><br><span class=\"line\">`java中类的成员变量的权限有私有，公有，保护，默认，在上面的表格中都给出了对应的权限范围，java类只有允许单继承不允许多继承，但允许多重继承，`</span><br></pre></td></tr></table></figure></p>\n<p>import java.util.ArrayList;<br>public class Test{<br>    public static void main(String args[]){<br>    System.out.println(“集合大小”);<br>    Apple a=new Apple();//调用类的构造方法来实现对集合的操作<br>    ArrayList <interger>array=a.getarray();//声明一个集合来对类中的公有方法中的返回值进行赋值给这个集合,很重要的是，在这里传的是引用而不是数据的副本。<br>    System.out.println(array.size());//打印集合的大小<br>    array.add(8);//对集合的引用进行加值的操作<br>    Arrjy <interger>a1=a.getarray();又重新定义一个集合来对调用的类的公有方法的返回值进行赋值<br>    System.out.println(a1.size());//打印集合的大小<br>    System.out.println(“集合元素”);<br>    for(Interger i:a1){<br>    System.out.println(i);<br>    }</interger></interger></p>\n<pre><code>}\n</code></pre><p>}<br>class Apple{<br>        private ArrayList<interger>array=new ArrayList<interger>();//声明一个私有集合作为类的成员变量<br>        Apple(){//构造方法,对集合进行初始化<br>        array.add(1);<br>        array.add(1);<br>        array.add(1);<br>        }<br>        ArrayList<interger>getarray(){//返回集合<br>        return array;<br>        }</interger></interger></interger></p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>集合大小<br>3<br>4<br>集合元素<br>1<br>1<br>1<br>8<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**其实在上面的程序中最难懂的是，在main方法里的集合的操作是引用的操作而不是简单的副本操作，在java中，除了基本的数据类型，其它都是引用类型,其中类也是引用类型** </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">关于继承的限制</span><br><span class=\"line\">- [ ] java中继承允许多继承，但也许多重继承</span><br><span class=\"line\">- [ ] 从父类继承的私有成员不能被子类直接使用，要通过方法来间接调用</span><br><span class=\"line\">- [ ] 子类在进行对象实例化的时候，先调用父类的构造方法对父类的成员变量进行赋值，然后在调用子类的构造方法，其作用是一样的。</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void mai(String args[]){</p>\n<pre><code>}\n</code></pre><p>}<br>final class A{<br>    final void show(){<br>    System.out.println(“如果这个方法在不想被子类覆写，可以在方法前面加上这个修饰符来确定不被子类覆写”);<br>    }</p>\n<p>}<br>//class B extends A{}//是错误的,所以注释掉<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序是不行的，因为父类的修饰符是final，它是不能被继承的</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>        A a=new B();<br>        a.show();<br>    }<br>}<br>class A {<br>    A(){<br>    System.out.println(“父类的构造方法”)<br>    }<br>    void show(){<br>        System.out.println(“走”);<br>    }<br>}<br>class B extends A{<br>    B(){<br>    System.out.println(“子类的构造方法<br>    }<br>    void show(){<br>        System.out.println(“飞”);<br>    }<br>}<br>class C extends A{<br>    C(){<br>        System.out.println(“子类的构造方法<br>}<br>    void show(){<br>        System.out.println(“跑”);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>父类的构造方法<br>子类的构造方法<br>飞<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序主要是实现多态的重要性，还有就是继承的小细节，继承是先调用父类的构造方法之后再调用子类的构造方法。在刚开始的时候就写过了在上面是先声明一个父类对象来进行对子类的实例化，然后在调用子类中覆写父类成员方法的方法，其实你也完全可以通过子类的对象来对子类进行实例化，在这里主要是实现类的多态。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">方法重载与覆写的区别</span><br><span class=\"line\">- [ ] 重载是在本类中实现的，而覆写主要是在子类中重写父类的方法</span><br><span class=\"line\">- [ ] 重载要求方法的参数个数和参数类型的顺序和参数的类型和方法名字，其中的任意一个不同。而覆写是方法名称和参数个数和类型与父类是一致的就行了</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`this&amp;&amp;super` </span><br><span class=\"line\">----</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            B b=new B();<br>            b.show();<br>    }<br>}<br>class A{<br>        String name;<br>        void show(){<br>        this-&gt;name=”java”;<br>        }<br>}<br>class B extends A{<br>    String name;<br>    void show(){<br>        this-&gt;name=”shanghai”;<br>        super.show();<br>        System.out.println(name+”\\t”+super.name);<br>    }<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果:<br>shanghai  java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">|区别|this|super|</span><br><span class=\"line\">|----|----|-----|</span><br><span class=\"line\">|查找范围|先从本类中找到属性或方法，本类找不到再去父类寻找|不查询父类的属性或方法，直接从子类调用父类的指定属性和方法|</span><br><span class=\"line\">|调用构造|this使用的是本类的构造|super先调用的是父类的构造方法，然后在调用子类的构造方法|</span><br><span class=\"line\">|特殊|表示当前的对象|可以看作是父类的引用对象|</span><br><span class=\"line\">|关系|两者的关系是属于二选一的关系，不能被同时调用|</span><br><span class=\"line\">---</span><br><span class=\"line\">抽象类</span><br><span class=\"line\">----</span><br></pre></td></tr></table></figure>\n<p>public class Test{<br>        public static void main(String args[]){<br>        A a=new B(“小艾”,11);<br>        a.show();<br>        A a1=new C(“笑话”,12);<br>        a1.show();<br>    }<br>}<br>abstract class A{<br>        public abstract void show();<br>}<br>class B extends A{<br>        String name;<br>        int age;<br>        B(String _name,int _age){<br>        }<br>        public void show(){<br>        System.out.println(“学生\\t”+name+”\\t”+age);<br>        }<br>}<br>class C extends B{<br>    C(String _name,int _age){<br>            super(_name,_age);<br>    }<br>    public show(){<br>    System.out.println(“工人\\t”+name+”\\t”+age);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>学生  小艾  11<br>工人  笑话  12<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的类A是一个抽象类来的，抽象类是不能被实例化的，顾名思义，抽象类是没有实现的方法的，在上面的父类中只有定义成员方法为抽象方法的的一个定义，没有实现的行为，抽象类的实现一般是在子类中一一实现的，这也得于抽象类的特性，抽象类是不能被实例化的，这样做会报错的，一般的抽象类都是有子类的，子类的重要作用之一是实现父类中的抽象方法，这是很重要的，还有就是，定义在父类的全部抽象方法在子类中都要重写这些抽象方法，不然会报错，记住是全部都要重写。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 接口(interface)</span><br><span class=\"line\">`接口是java所提供的另外一种重要的技术，是一种特殊的类，它的结构和抽象类很相似。接口里的数据成必须初始化，数据成员均为常量，常见的是全局变量。` </span><br><span class=\"line\">`为了避免在接口中添加新的方法后要修改所有的实现类，允许定义默认方法` </span><br><span class=\"line\"></span><br><span class=\"line\">使用接口的原则</span><br><span class=\"line\">- [ ] 接口必须有子类，子类依靠(关键字)implements来实现多个接口</span><br><span class=\"line\">- [ ] 接口的子类必须重写接口中的所有抽象方法</span><br><span class=\"line\">- [ ] 接口可以利用对象的多态性，利用子类的对象进行实例化</span><br><span class=\"line\">- [ ] 接口和一般的类是一样的，具有成员变量和成员方法，但数据成员必须进行初始化，而初始化的值是不能被修改的，相当与是常量，方法也必须是抽象的或者是(default)，所以在接口中这两个特性是可以忽略的，因为在接口中不管是成员方法或者是成员变量都是特性都是肯定了的。</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){</p>\n<pre><code>        B b=new B();\n        b.show();\n        b.print();\n    System.out.println(A.name);\n    //System.out.println(b.name);//不能通过类的实现来访问静态成员\n}\n</code></pre><p>}<br>interface A{<br>        public static String name=”hello”;<br>        public void show();<br>        default void print(){<br>        System.out.println(“你好”);<br>        }<br>}<br>class B implements A{<br>    //name=”HELLO”;//这个是错误的<br>    public void show(){<br>        System.out.println(name);<br>    }<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果:<br>hello<br>你好<br>hello<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序只是简单的介绍接口的基本定义的格式，其中有成员变量和成员方法，而其中的成员变量是全局类型的(还必须给初始化值)，成员方法分两种，一种是抽象方法(在子类是实现的方法，在接口只是声明而已)，另外是其它类型的成员方法</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**在这里在强调一次，接口与抽象类唯一不同的就是子类，对于接口来说可以实现多个接口，但抽象类是不能多继承的**</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>        C c=new C();<br>        c.show();<br>    }<br>}<br>interface A{<br>    default void show(){<br>    System.out.println(“A接口的默认方法”);<br>    }<br>}<br>interface B{<br>    default void show(){<br>    System.out.println(“B接口的默认方法”);<br>    }<br>}<br>class c implements A , B{}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序是错误的，因为在接口中的默认方法中如果有同名的方法，你在调用方法的同时，编译器会不知道你要调用的到底是哪一个方法，这就产生了所谓的二义性，一般来说在接口中一定不要有同名的变量,还有就是上面的接口是没有抽象类型的方法，所以在子类中是空的</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`在前面说过，接口是允许多继承的，接口中对于抽象类和接口的继承是先继承后实现`</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>        F f=new F();<br>        A a=f;//声明一个接口对象来指向子类，主要是在调用方法的时候让你清晰的知道在那个接口中调用的是那个方法。你也可以不写，直接用子类的实例化对象来调用<br>        B b=f;<br>        C c=f;<br>        D d=f;<br>        a.show();<br>        b.prin();<br>        c.print();<br>        c.xiao();<br>        d.printd();<br>        d.xi();<br>    }<br>}<br>interface A{<br>        public static String name=”小新”;<br>        public void show();<br>}<br>interface B{<br>    public void prin();<br>}<br>interface  C extends A , B{//接口继承多个接口<br>    public void print();<br>    default void xiao(){<br>    System.out.println(name+”\\t多接口继承”);<br>    }<br>}<br>abstract class D implements A,B{//抽象类继承多个接口<br>    abstract public void printd();<br>    void xi(){<br>    System.out.println(name+”\\t抽象类继承”);<br>    }<br>}<br>class F extends D implements C{<br>    public void show(){<br>    System.out.println(“你好”);<br>    }<br>    public void prin(){<br>    System.out.println(“hello,world”);<br>    }<br>    public void print(){<br>    System.out.println(“一个接口继承多个接口”+name);<br>    }<br>    public void printd(){<br>    System.out.println(“抽象类继承多个接口”);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>你好<br>hello,world<br>一个接口继承多个接口<br>小新 多接口继承<br>抽象类继承多个接口<br>小新 抽象类继承<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在上面的程序中我们可以知道，对于接口的继承，一个接口可以继承多个接口(extends)来继承，继承的同时不用进行对继承的接口进行实现。抽象类继承多个接口(implements),继承的同时一样不要进行对已继承的接口的方法实现，但子类一定要对继承的接口和抽象类中的方法进行实现,还有就是，不管是多接口继承还是抽象类继承，都是基于继承的特性来实现继承的，都会继承父接口的成员变量。对于接口的成员变量一定要在声明的同时就进行初始化。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">接口的作用--制定标准</span><br><span class=\"line\">`接口是标准，所谓的标准，指的是各方共同遵守的一个原则。只有操作标准统一了，所有的参与者才可以按照统一的规则操作`</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>        Computer c=new Computer();<br>        c.show(new B);//拿子类的引用来作为参数调用父接口中的方法<br>        c.show(new C);//拿子类的引用来作为参数调用父接口中的方法</p>\n<pre><code>}\n</code></pre><p>}<br>interface USB{<br>        public void work();//这是抽象方法<br>}<br>class B implements USB{<br>    public void work(){<br>        System.out.println(“USB在工作”);<br>    }<br>}<br>class C implements USB{<br>    public void work(){<br>        System.out.println(“USB在打印机中工作”);<br>    }<br>}<br>class Computer{<br>    public void show(USB usb){//父接口作为方法的参数<br>        usb.work();//调用类中的方法<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>USB在工作<br>USB在打印机中工作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面展现的是接口作用--制定标准，利用接口USB来制定工作的标准，通过继承来实现接口中的方法，最后通过电脑类中的方法来调用在子类的实现</span><br><span class=\"line\"></span><br><span class=\"line\">接口--工厂的设计</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>    A a=F.getname(“apple”);</p>\n<pre><code>}\n</code></pre><p>}<br>interface A{<br>        public void eat();<br>}<br>class apple implements A{<br>    public void eat(){<br>        System.out.println(“吃苹果”);<br>    }<br>}<br>class oright implements A{<br>    public void eat(){<br>    System.out.println(“吃橙子”);<br>    }<br>}<br>class F{<br>    public static A getname(String name){<br>        if(“apple”.equals(name)){<br>        return new apple();<br>        }<br>        if(“oright”.equals(name)){<br>        return new oright();<br>        }<br>        return null;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>吃苹果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">此时的程序，在客户端没有和具体的子类耦合在一起，这样一来，如果再有更多的A接口子类出现，只需要修改F类即可，即:所有的接口对象都通过F类取得，在程序员自己开发的代码中，只要是遇见要取得接口对象实例的操作，都应该使用工厂设计模式。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">匿名类使用注意事项</span><br><span class=\"line\">- [ ] 使用匿名类的时候必须是继承一个类或者是实现一个接口，但是两者不可同时兼得，只能是继承一个类或者是实现一个接口</span><br><span class=\"line\">- [ ] 匿名内部类是不能定义构造方法的</span><br><span class=\"line\">- [ ] 匿名内部类不存在静态方法和静态变量</span><br><span class=\"line\">- [ ] 匿名内部类属于局部内部类，所以局部内部类的限制同样对局部内部类生效</span><br><span class=\"line\">- [ ] 匿名内部类不能是抽象的，它必须是一个实现的继承类或者是实现接口的所有抽象方法</span><br><span class=\"line\"></span><br><span class=\"line\">static</span><br><span class=\"line\">- [ ] 由static定义的类方法，可以直接由类名直接调用，另外的就是static属性是一个共享的属性</span><br><span class=\"line\"></span><br><span class=\"line\"># java常用的类</span><br><span class=\"line\">`API(应用程序编程接口)`</span><br><span class=\"line\"></span><br><span class=\"line\">基本类型的包装类</span><br><span class=\"line\">----</span><br><span class=\"line\">|基本数据类型|基本类型的包装类|</span><br><span class=\"line\">|------------|----------------|</span><br><span class=\"line\">|int|Integer|</span><br><span class=\"line\">|double|Double|</span><br><span class=\"line\">|byte|Byte|</span><br><span class=\"line\">|char|Char|</span><br><span class=\"line\">|float|Float|</span><br><span class=\"line\">|shart|Shart|</span><br><span class=\"line\">|long|Long|</span><br><span class=\"line\">|boolean|Boolean|</span><br><span class=\"line\"></span><br><span class=\"line\">装箱与拆箱</span><br><span class=\"line\">-----</span><br><span class=\"line\">所谓的装箱就是把基本数据类型用它们相对应的引用数据类型包起来，使它们具有对象的特质，例如把int包装成Integer类的对象</span><br><span class=\"line\">所谓拆箱就是与装箱刚刚相反，将Integer类的对象重新简化成基本数据类型</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            Integer i=new Integer(10);<br>            int x=i.intValue();<br>            System.out.println(x);<br>            Double b=new Double(100.00);<br>            double b1=b.doubleValue();<br>            System.out.println(b1);</p>\n<pre><code>}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>10<br>100.00<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序是利用拆箱来把Integer类的包装类拆成基本数据类型Int，下面的double也是一样的</span><br><span class=\"line\">装箱的操作:就是将基本数据类型变为包装类，利用各个包装类的构造方法来完成</span><br><span class=\"line\">拆箱的操作:将包装类变为基本数据类型，利用各自的类的xxx.Value()方法来实现</span><br><span class=\"line\"></span><br><span class=\"line\">基本数据类型与String类的转换</span><br><span class=\"line\">----</span><br><span class=\"line\">**但是以下的操作是不包括Char类的，因为String类有一个CharAt方法可以取得指定索引的字符** </span><br><span class=\"line\"></span><br><span class=\"line\">`将String类型转换成基本数据类型`</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            String s=”123”;<br>            int i=Int.parseInt(s);<br>            String s1=”123.6”;<br>            double b=Double.parseDouble(s1);<br>            System.out.println(i);<br>            System.out.println(b);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>123<br>123。6<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在将字符串换成基本数据类型的时候要注意一定要符合对应的数据类型，不能把数据类型搞混。</span><br><span class=\"line\"></span><br><span class=\"line\">`把基本数据类型变为String类型`</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            int i=100;<br>            String s=String.ValueOf(i);<br>            System.out.println(s);<br>            double b=123.6;<br>            String s1=String.ValueOf(b);<br>            System.out.println(s1);<br>    }<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果:<br>100<br>123.6<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面是利用String类里的机制方法来进行对不同基本数据类型转换成String类。</span><br><span class=\"line\"></span><br><span class=\"line\"># 日期操作类</span><br><span class=\"line\">|类名|说明|</span><br><span class=\"line\">|----|----|</span><br><span class=\"line\">|LocalDateTime|存储了日期和时间|</span><br><span class=\"line\">|LocalDate|存储了日期|</span><br><span class=\"line\">|LocalTime|存储了时间|</span><br></pre></td></tr></table></figure></p>\n<p>import java.time.LocalDate;<br>import java.time.YearMonth;<br>import java.time.Year;<br>impore java.time.MonDay;<br>public class Test{<br>    public static void main(String args[]){<br>            LocalDateTime l1=LocalDateTime.now();<br>            System.out.println(l1);//根据日期类来调用方法来打印现在的年月日,在这里就不打印了,自己尝试<br>            Year year=Year.of(2010);<br>            YearMonth yearmonth=year.at(2);<br>            LocalDate localdate=yearmonth.at(28);<br>            System.out.println(localdate);<br>            System.out.println(localdate.isEqual(localdate));<br>            MonthDay m=Monday.of(4,15);<br>            localdate l=m.atyear(2015);<br>            System.out.println(l);<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>2010-2-18<br>true<br>2015-4-15<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从上面的程序可以看出，在java中对日期的操作是非常强大的，可以根据自己的需求来慢慢进行设置，在上面我也给出了对于日期类的归属。</span><br></pre></td></tr></table></figure></p>\n<p>import java.time.<em>;<br>import java.time.format.</em>;<br>public class Test{<br>    public static void main(String aegs[]){<br>            LocalDate localdate=LocalDate.now();//获取当前日期<br>            DateTimeForMatter datetime=DateTimeForMatter.ofPattern(“dd/mm/uuuu”);//设置日期打印的格式<br>            String str=localdate.ofmat(datetime);//把当期日期放在设置好的日期格式<br>            System.out.println(str);//打印出来<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>自己尝试了，仆街。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在java中，设置日期的格式是用过DateTimeForMatter类来设置格式的，然后把时间放在设置好的格式里，最后通过String类来进行打印出来。</span><br><span class=\"line\"></span><br><span class=\"line\"># 正则</span><br><span class=\"line\"></span><br><span class=\"line\">|正则标识符|意义|</span><br><span class=\"line\">|----------|----|</span><br><span class=\"line\">|\\ |表示一位字符|</span><br><span class=\"line\">|\\\\|表示多位字符|</span><br><span class=\"line\">|\\n|匹配换行|</span><br><span class=\"line\">|[abc]|a,b,c中的任意一位|</span><br><span class=\"line\">|[^abc]|表示不是abc中的任意一位|</span><br><span class=\"line\">|[a-zA-Z]|表示任意一位字母(不管大小写)|</span><br><span class=\"line\">|[0-9]|表示0-9任意一位|</span><br><span class=\"line\">|.|表示任意一位字符|</span><br><span class=\"line\">|\\d|等价与0-9|</span><br><span class=\"line\">|\\D|等价与[^0-9]|</span><br><span class=\"line\">|\\s|表示一位空格|</span><br><span class=\"line\">|\\S|表示非空格|</span><br><span class=\"line\">|\\w|等价与[a-zA-Z0-9]|</span><br><span class=\"line\">|\\W|等价与[^a-zA-Z0-9]|</span><br><span class=\"line\">|^|表示正则的开头|</span><br><span class=\"line\">|$|表示正则的结尾|</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(Strng args[]){<br>        if(“123”.matches”\\d+”){<br>            System.out.println(“true”);<br>        }else{<br>        System.out.println(“false”);<br>        }<br>        String s=”<a href=\"mailto:1234@163.com\" target=\"_blank\" rel=\"noopener\">1234@163.com</a>“;//给出字符串<br>        String s1=”\\w+@\\w+.\\w+”;//给出邮箱的格式(w:等价于[a-zA-Z0-9])<br>        System.out.println(s.matches(s1));//验证上面的邮箱格式<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>true<br>true<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的程序是通过正则来判断并输出结果的，上面的方法是正则类里的一个方法，意思是判断字符串是不是由数字组成的，是就输出true，不是就false，明显与结果是一样的。</span><br><span class=\"line\">|方法|意义|</span><br><span class=\"line\">|----|----|</span><br><span class=\"line\">|boolean matches(String test)|将字符与给出的正则表达式进行匹配验证|</span><br><span class=\"line\">|String replaceAll(String test,String replacement)|按照指定的正则进行替换|</span><br><span class=\"line\">|String replzceFirst(String test,String replacement)|按照指定的正则进行替换首个|</span><br></pre></td></tr></table></figure></p>\n<p>public class Test{<br>    public static void main(String args[]){<br>            String s=”123abcd3546efg”;<br>            String s1=”\\d+”;多个数字<br>            System.out.println(s.replaceAll(s1,””));//在字符串中替换数字<br>            System.out.println(s.replaceFirst(s1,””));//在字符串中替换首个字符前数字</p>\n<pre><code>}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>运行结果:<br>abcdefg<br>abcd3546efg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在上面我给出的正则表达式的表示符可以在这个程序里尽情的尝试，你也会有发现的，但重要的是对你的理解有帮助,这样学起来是理解性的学习而不是一味的烦躁。</span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal(大数值)</span><br><span class=\"line\">----</span><br></pre></td></tr></table></figure></p>\n<p>import java.math.BigDecimal;<br>public class Test{<br>    public static void main(String args[]){<br>            BigDecimal b=new BigDecimal(“3456789101112”)<br>            BigDecimal b1=new BigDecimal(“123456789”);<br>            System.out.println(b.add(b1));//加法<br>            System.out.println(b.subtract(b1));//减法<br>            System.out.println(b.multipy(b1));//乘法<br>            System.out.println(b.multipy(b1).setScale(1,BigDecimal.ROUND_up));//乘法,但是以进一的形式来输出值<br>            System.out.println(b.divide(b1,BigDecimal.ROUND_DOWN));//除法<br>            BigDecimal b2[]=b.divideAndRemainder(b1);//除法，并把值放在数组里面<br>            System.out.println(“商”+b2[0]+”余”+b2[1]);<br>    }<br>}</p>\n<p><code>`</code></p>\n<p>上面的程序主要是应对于大的数字，在int和long都无法容纳的时候就使用BigDecimal类型来进行操作，(结果自己动手)</p>\n<p><strong>当需要在ArrayList和HashMap中放东西的时候,你在这个时候使用基本数据类型是不能放进去的，因为容器里面都是放</strong> &lt;++&gt;</p>"}],"PostAsset":[{"_id":"source/_posts/i3/228568.jpg","slug":"228568.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/608422.jpg","slug":"608422.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/mysql/mysql1.png","slug":"mysql1.png","post":"ck3dqz7rp000e4ez72xqe7dv1","modified":0,"renderable":0},{"_id":"source/_posts/mysql/mysql4.png","slug":"mysql4.png","post":"ck3dqz7rp000e4ez72xqe7dv1","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtEventpainter1.png","slug":"qtEventpainter1.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/i3/927682.jpg","slug":"927682.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/Class/Lpur2.png","slug":"Lpur2.png","post":"ck3dqz7qj00004ez72ofvjorl","modified":0,"renderable":0},{"_id":"source/_posts/Code/Code1.png","slug":"Code1.png","post":"ck3dqz7qo00014ez7cmeeu0gq","modified":0,"renderable":0},{"_id":"source/_posts/Noteslinux1/chattr.png","slug":"chattr.png","post":"ck3dqz7qw00054ez7y28w5syg","modified":0,"renderable":0},{"_id":"source/_posts/test/a.jpg","slug":"a.jpg","post":"ck3dqz7ru000j4ez797cw9x6j","modified":0,"renderable":0},{"_id":"source/_posts/file/file.png","slug":"file.png","post":"ck3dqz7ri000b4ez7sakizs05","modified":0,"renderable":0},{"_id":"source/_posts/file/file1.png","slug":"file1.png","post":"ck3dqz7ri000b4ez7sakizs05","modified":0,"renderable":0},{"_id":"source/_posts/tar/tar.png","slug":"tar.png","post":"ck3dqz7rr000g4ez7cave8c25","modified":0,"renderable":0},{"_id":"source/_posts/tar/tar1.png","slug":"tar1.png","post":"ck3dqz7rr000g4ez7cave8c25","modified":0,"renderable":0},{"_id":"source/_posts/小萝莉/sda.jpg","slug":"sda.jpg","post":"ck3dqz7rw000l4ez74mxq26t0","modified":0,"renderable":0},{"_id":"source/_posts/小萝莉/test.png","slug":"test.png","post":"ck3dqz7rw000l4ez74mxq26t0","modified":0,"renderable":0},{"_id":"source/_posts/C-Book/c-Book.png","slug":"c-Book.png","post":"ck3dqz7qr00034ez7f20u8yej","modified":0,"renderable":0},{"_id":"source/_posts/C-Book/c-Book1.png","slug":"c-Book1.png","post":"ck3dqz7qr00034ez7f20u8yej","modified":0,"renderable":0},{"_id":"source/_posts/C-Book/c-Book2.png","slug":"c-Book2.png","post":"ck3dqz7qr00034ez7f20u8yej","modified":0,"renderable":0},{"_id":"source/_posts/C-Book/c-Book3.png","slug":"c-Book3.png","post":"ck3dqz7qr00034ez7f20u8yej","modified":0,"renderable":0},{"_id":"source/_posts/C-Book/c-Book4.png","slug":"c-Book4.png","post":"ck3dqz7qr00034ez7f20u8yej","modified":0,"renderable":0},{"_id":"source/_posts/C-Book/c-Book5.png","slug":"c-Book5.png","post":"ck3dqz7qr00034ez7f20u8yej","modified":0,"renderable":0},{"_id":"source/_posts/mysql/mysql0.png","slug":"mysql0.png","post":"ck3dqz7rp000e4ez72xqe7dv1","modified":0,"renderable":0},{"_id":"source/_posts/mysql/mysql2.png","slug":"mysql2.png","post":"ck3dqz7rp000e4ez72xqe7dv1","modified":0,"renderable":0},{"_id":"source/_posts/mysql/mysql3.png","slug":"mysql3.png","post":"ck3dqz7rp000e4ez72xqe7dv1","modified":0,"renderable":0},{"_id":"source/_posts/mysql/mysql5.png","slug":"mysql5.png","post":"ck3dqz7rp000e4ez72xqe7dv1","modified":0,"renderable":0},{"_id":"source/_posts/c-Notes/WC.png","slug":"WC.png","post":"ck3dqz7r100064ez70vb1pub5","modified":0,"renderable":0},{"_id":"source/_posts/c-Notes/YC.png","slug":"YC.png","post":"ck3dqz7r100064ez70vb1pub5","modified":0,"renderable":0},{"_id":"source/_posts/c-Notes/YC1.png","slug":"YC1.png","post":"ck3dqz7r100064ez70vb1pub5","modified":0,"renderable":0},{"_id":"source/_posts/c-Notes/YC2.png","slug":"YC2.png","post":"ck3dqz7r100064ez70vb1pub5","modified":0,"renderable":0},{"_id":"source/_posts/c-Notes/YC3.png","slug":"YC3.png","post":"ck3dqz7r100064ez70vb1pub5","modified":0,"renderable":0},{"_id":"source/_posts/c-Notes/YC4.png","slug":"YC4.png","post":"ck3dqz7r100064ez70vb1pub5","modified":0,"renderable":0},{"_id":"source/_posts/c-Notes/YC5.png","slug":"YC5.png","post":"ck3dqz7r100064ez70vb1pub5","modified":0,"renderable":0},{"_id":"source/_posts/i3/113997.jpg","slug":"113997.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/166859.jpg","slug":"166859.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/169068.jpg","slug":"169068.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/213983.jpg","slug":"213983.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/228129.jpg","slug":"228129.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/228532.jpg","slug":"228532.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/228533.jpg","slug":"228533.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/231046.jpg","slug":"231046.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/246420.jpg","slug":"246420.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/246755.jpg","slug":"246755.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/247971.jpg","slug":"247971.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/251996.jpg","slug":"251996.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/252202.jpg","slug":"252202.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/41912.jpg","slug":"41912.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/424059.jpg","slug":"424059.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/556990.jpg","slug":"556990.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/654159.png","slug":"654159.png","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/674994.jpg","slug":"674994.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/710742.jpg","slug":"710742.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/81939.jpg","slug":"81939.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/931367.jpg","slug":"931367.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/crayon_shin_chan-002.jpg","slug":"crayon_shin_chan-002.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/test1.jpg","slug":"test1.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/test2.jpg","slug":"test2.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/test3.jpeg","slug":"test3.jpeg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/test5.jpeg","slug":"test5.jpeg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/test7.jpg","slug":"test7.jpg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/i3/头像.jpeg","slug":"头像.jpeg","post":"ck3dqz7rm000d4ez707i1wgvr","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt1.png","slug":"qt1.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt10_ui.png","slug":"qt10_ui.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt11_ui.png","slug":"qt11_ui.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt12_ui.png","slug":"qt12_ui.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt2_hello.png","slug":"qt2_hello.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt3_caidan.png","slug":"qt3_caidan.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt4_duihua.png","slug":"qt4_duihua.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt5_duihua.png","slug":"qt5_duihua.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt6_ui.png","slug":"qt6_ui.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt7_ui.png","slug":"qt7_ui.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt8_ui.png","slug":"qt8_ui.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt9_ui.png","slug":"qt9_ui.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtEvent.png","slug":"qtEvent.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtEvent1.png","slug":"qtEvent1.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtEvent2.png","slug":"qtEvent2.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtEvent3.png","slug":"qtEvent3.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtEvent4.png","slug":"qtEvent4.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtEventpainter2.png","slug":"qtEventpainter2.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtFILE.png","slug":"qtFILE.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_Read.png","slug":"qt_Read.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_Stream.png","slug":"qt_Stream.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_image.png","slug":"qt_image.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_paint.png","slug":"qt_paint.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_paint1.png","slug":"qt_paint1.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_picture.png","slug":"qt_picture.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_picture1.png","slug":"qt_picture1.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_picture2.png","slug":"qt_picture2.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_pixmap.png","slug":"qt_pixmap.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_pixmap2.png","slug":"qt_pixmap2.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_server.png","slug":"qt_server.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_tcpfile.png","slug":"qt_tcpfile.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_tcpserven.png","slug":"qt_tcpserven.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_tcpserven1.png","slug":"qt_tcpserven1.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_tcpserven2.png","slug":"qt_tcpserven2.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_udp.png","slug":"qt_udp.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_udp1.png","slug":"qt_udp1.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_udp2.png","slug":"qt_udp2.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qt_zhuan1.png","slug":"qt_zhuan1.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtreadfile.png","slug":"qtreadfile.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtwritefile.png","slug":"qtwritefile.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/qt/qtzhuan.png","slug":"qtzhuan.png","post":"ck3dqz7rx000n4ez7xlmu5gze","modified":0,"renderable":0},{"_id":"source/_posts/test-2/java4.png","slug":"java4.png","post":"ck3dqz7rt000i4ez7xxycsueh","modified":0,"renderable":0},{"_id":"source/_posts/Java/java0.png","slug":"java0.png","post":"ck3drdiqo0000d2z76ptg0pj0","modified":0,"renderable":0},{"_id":"source/_posts/Java/java1.png","slug":"java1.png","post":"ck3drdiqo0000d2z76ptg0pj0","modified":0,"renderable":0},{"_id":"source/_posts/Java/java2.png","slug":"java2.png","post":"ck3drdiqo0000d2z76ptg0pj0","modified":0,"renderable":0},{"_id":"source/_posts/Java/java3.png","slug":"java3.png","post":"ck3drdiqo0000d2z76ptg0pj0","modified":0,"renderable":0},{"_id":"source/_posts/Java/java4.png","slug":"java4.png","post":"ck3drdiqo0000d2z76ptg0pj0","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ck3dqz7qq00024ez73a76ia66","tag_id":"ck3dqz7qt00044ez7bzylgc5g","_id":"ck3dqz7rd00094ez7sgydyco5"},{"post_id":"ck3dqz7qw00054ez7y28w5syg","tag_id":"ck3dqz7qt00044ez7bzylgc5g","_id":"ck3dqz7rm000c4ez7shneqw85"},{"post_id":"ck3dqz7rv000k4ez7xv3ven5c","tag_id":"ck3dqz7rx000m4ez77u9dcuka","_id":"ck3dqz7ry000o4ez7lg9vqe6c"}],"Tag":[{"name":"Test","_id":"ck3dqz7qt00044ez7bzylgc5g"},{"name":"test","_id":"ck3dqz7rx000m4ez77u9dcuka"}]}}